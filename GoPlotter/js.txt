// buttonFunctions.js - MCEB Pub 7 Compliant Field Management (Standalone Version)

// ===== UTILITY FUNCTIONS =====

function showNotification(message, type = 'info') {
    // Check if external notification system exists
    if (window.showNotification && typeof window.showNotification === 'function') {
        window.showNotification(message, type);
        return;
    }

    // Fallback notification system
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 4px;
        color: white;
        font-weight: 500;
        z-index: 10000;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;

    switch (type) {
        case 'success':
            notification.style.backgroundColor = '#28a745';
            break;
        case 'error':
            notification.style.backgroundColor = '#dc3545';
            break;
        case 'warning':
            notification.style.backgroundColor = '#ffc107';
            notification.style.color = '#000';
            break;
        default:
            notification.style.backgroundColor = '#007bff';
    }

    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
        notification.remove();
    }, 4000);
}

function addValidationListeners(container) {
    const inputs = container.querySelectorAll('input, select');
    inputs.forEach(input => {
        input.addEventListener('blur', (e) => {
            validateField(e.target);
        });
        if (input.maxLength) {
            input.addEventListener('input', (e) => {
                updateCharacterCounter(e.target);
            });
        }
    });
}

function updateCharacterCounter(field) {
    const maxLength = field.maxLength;
    if (!maxLength) return;

    let counter = field.parentNode.querySelector('.char-counter');
    if (!counter) {
        counter = document.createElement('div');
        counter.className = 'char-counter';
        counter.style.cssText = `
            font-size: 0.8em;
            color: #666;
            text-align: right;
            margin-top: 2px;
        `;
        field.parentNode.appendChild(counter);
    }

    const remaining = maxLength - field.value.length;
    counter.textContent = `${field.value.length}/${maxLength}`;

    if (remaining < 5) {
        counter.style.color = '#dc3545';
    } else if (remaining < 10) {
        counter.style.color = '#ffc107';
    } else {
        counter.style.color = '#666';
    }
}

function validateField(field) {
    const fieldType = field.dataset.field;
    let isValid = true;

    // Clear existing errors
    clearFieldErrors(field);

    switch (fieldType) {
        case '114': // Emission Designator
            isValid = validateEmissionDesignator(field);
            break;
        case '113': // Station Class
            isValid = validateStationClass(field);
            break;
        case '115': // Transmitter Power
            isValid = validateTransmitterPower(field);
            break;
    }

    return isValid;
}

function clearFieldErrors(field) {
    field.style.borderColor = '';
    const existingErrors = field.parentNode.querySelectorAll('.field-error');
    existingErrors.forEach(error => error.remove());
}

// Placeholder validation functions (implement as needed)
function validateEmissionDesignator(field) {
    // Add emission designator validation logic
    return true;
}

function validateStationClass(field) {
    // Add station class validation logic
    return true;
}

function validateTransmitterPower(field) {
    // Add transmitter power validation logic
    return true;
}

// ===== MAIN FIELD CREATION FUNCTIONS =====
document.addEventListener('DOMContentLoaded', () => {
    // ✅ Connect to the correct button ID
    const addEmissionBtn = document.getElementById('addEmissionGroup');
    if (addEmissionBtn) {
        addEmissionBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('🔄 Add Emission Group button clicked');
            addEmissionCharacteristicsEntry();
        });
        console.log('✅ Add Emission Group button connected');
    } else {
        console.error('❌ addEmissionGroup button not found');
    }
});

function addEmissionCharacteristicsEntry() {
    const container = document.getElementById('emission-characteristics-entries');
    if (!container) {
        showNotification('Emission characteristics container not found', 'error');
        return;
    }

    const entryCount = container.querySelectorAll('.emission-entry').length + 1;

    // Skip creating base entry (already exists as protected)
    if (entryCount === 1) {
        showNotification('Base emission characteristics already exist', 'warning');
        return;
    }

    if (entryCount > 20) {
        showNotification('Maximum 20 emission characteristic occurrences allowed per MCEB Pub 7', 'error');
        return;
    }

    const newEntry = document.createElement('div');
    newEntry.className = 'dynamic-entry emission-entry'; // Note: NOT protected-field
    newEntry.dataset.entry = entryCount;

    // Include remove button for additional entries only
    newEntry.innerHTML = `
        <div class="entry-header">
            <span class="entry-title">Emission Characteristics #${entryCount}</span>
            <button class="remove-entry-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
        </div>
        <div class="form-row">
            <label for="field113_${entryCount}">113 - Station Class:</label>
            <select id="field113_${entryCount}" class="form-control" data-field="113">
                <option value="">Select Station Class...</option>
                <option value="FB">FB - Fixed Base</option>
                <option value="FB2">FB2 - Fixed Base (Secondary)</option>
                <option value="ML">ML - Mobile Land</option>
                <option value="MA">MA - Mobile Aircraft</option>
                <option value="MO">MO - Mobile Other</option>
                <option value="BC">BC - Broadcasting</option>
                <option value="AC">AC - Aeronautical</option>
                <option value="AF">AF - Aeronautical Fixed</option>
                <option value="CG">CG - Coast Guard</option>
                <option value="HA">HA - Amateur</option>
                <option value="XE">XE - Experimental</option>
            </select>
        </div>
        <div class="form-row">
            <label for="field114_${entryCount}">114 - Emission Designator:</label>
            <input type="text" id="field114_${entryCount}" class="form-control" 
                   maxlength="11" placeholder="3K00J3E, 16K0F3E, 2K70J3E" data-field="114">
            <small class="field-help">Format: bandwidth + emission class (max 11 chars per MCEB Pub 7)</small>
        </div>
        <div class="form-row">
            <label for="field115_${entryCount}">115 - Transmitter Power:</label>
            <input type="text" id="field115_${entryCount}" class="form-control" 
                   maxlength="9" placeholder="K10, W50, M5" data-field="115">
            <small class="field-help">Format: power value + unit (K=kW, W=watts, M=MW, max 9 chars)</small>
        </div>
        <div class="form-row">
            <label for="field116_${entryCount}">116 - Power Type:</label>
            <select id="field116_${entryCount}" class="form-control" data-field="116">
                <option value="">Select Power Type...</option>
                <option value="C">C - Carrier Power (N0N, A3E broadcasting)</option>
                <option value="M">M - Mean Power (A/A, A/G/A, FM emissions)</option>
                <option value="P">P - Peak Envelope Power (pulsed equipment)</option>
            </select>
        </div>
    `;

    container.appendChild(newEntry);
    addValidationListeners(newEntry);
    console.log(`✅ Added emission characteristics entry #${entryCount}`);
    showNotification(`Emission characteristics #${entryCount} added`, 'success');
}

document.addEventListener('DOMContentLoaded', () => {
    // ✅ Connect Transmitter Button (using existing button from sidebar.txt)
    const addEquipBtn = document.getElementById('addTransmitterEntry');
    if (addEquipBtn) {
        addEquipBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('🔄 Add Transmitter Entry button clicked');
            addTransmitterEntry(); // Your renamed function
        });
        console.log('✅ Add Transmitter Entry button connected');
    } else {
        console.error('❌ addTransmitterEntry button not found');
    }
});

function addTransmitterEntry() {
    const container = document.getElementById('transmitter-entries');
    if (!container) {
        showNotification('Transmitter container not found', 'error');
        return;
    }

    const entryCount = container.querySelectorAll('.transmitter-entry').length + 1;

    // Skip creating base entry (already exists as protected)
    if (entryCount === 1) {
        showNotification('Base Transmitter entry already exists', 'warning');
        return;
    }

    if (entryCount > 10) {
        showNotification('Maximum 10 Transmitter occurrences allowed per MCEB Pub 7', 'error');
        return;
    }

    const newEntry = document.createElement('div');
    newEntry.className = 'dynamic-entry transmitter-entry';
    newEntry.dataset.entry = entryCount;
    newEntry.innerHTML = `
        <div class="entry-header">
            <span class="entry-title">Transmitter #${entryCount}</span>
            <button class="remove-entry-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
        </div>
        <div class="form-row">
            <label for="field340_${entryCount}">340 - Transmitter Nomenclature:</label>
            <input type="text" id="field340_${entryCount}" class="form-control" 
                   maxlength="18" placeholder="G,AN/PRC-160(V)" data-field="340">
            <small class="field-help">Format: Transmitter type + nomenclature (max 18 chars)</small>
        </div>
        <div class="form-row">
            <label for="field343_${entryCount}">343 - Transmitter Certification ID:</label>
            <input type="text" id="field343_${entryCount}" class="form-control" 
                   maxlength="15" placeholder="J/F 12/11171" data-field="343">
            <small class="field-help">Military Transmitter certification number (max 15 chars)</small>
        </div>
    `;

    container.appendChild(newEntry);
    addValidationListeners(newEntry);
    console.log(`✅ Added Transmitter entry #${entryCount}`);
    showNotification(`Transmitter #${entryCount} added`, 'success');
}

document.addEventListener('DOMContentLoaded', () => {
    // ✅ Connect Receiver Button (using existing button from sidebar.txt)
    const addEquipBtn = document.getElementById('addReceiverEntry');
    if (addEquipBtn) {
        addEquipBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('🔄 Add Receiver Entry button clicked');
            addReceiverEntry(); // Your renamed function
        });
        console.log('✅ Add Receiver Entry button connected');
    } else {
        console.error('❌ addReceiverEntry button not found');
    }
});

function addReceiverEntry() {
    const container = document.getElementById('receiver-entries') ||
        document.querySelector('[data-section="Receiver"] .section-content #receiver-entries');

    if (!container) {
        showNotification('Receiver container not found', 'error');
        return;
    }

    const entryCount = container.querySelectorAll('.receiver-entry').length + 1;

    // Skip creating base entry (already exists as protected)
    if (entryCount === 1) {
        showNotification('Base Receiver entry already exists', 'warning');
        return;
    }

    if (entryCount > 10) {
        showNotification('Maximum 10 Receiver occurrences allowed per MCEB Pub 7', 'error');
        return;
    }

    const newEntry = document.createElement('div');
    newEntry.className = 'dynamic-entry receiver-entry';
    newEntry.dataset.entry = entryCount;
    newEntry.innerHTML = `
        <div class="entry-header">
            <span class="entry-title">Receiver #${entryCount}</span>
            <button class="remove-entry-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
        </div>
        <div class="form-row">
            <label for="field440_${entryCount}">440 - Equipment Nomenclature:</label>
            <input type="text" id="field440_${entryCount}" class="form-control" 
                   maxlength="18" placeholder="G,AN/PRC-160(V)" data-field="440">
            <small class="field-help">Format: Equipment type + nomenclature (max 18 chars)</small>
        </div>
        <div class="form-row">
            <label for="field443_${entryCount}">443 - Equipment Certification ID:</label>
            <input type="text" id="field443_${entryCount}" class="form-control" 
                   maxlength="15" placeholder="J/F 12/11171" data-field="443">
            <small class="field-help">Military equipment certification number (max 15 chars)</small>
        </div>
    `;

    container.appendChild(newEntry);
    addValidationListeners(newEntry);
    console.log(`✅ Added Receiver entry #${entryCount}`);
    showNotification(`Receiver #${entryCount} added`, 'success');
}

async function populateIracNotesSelect(selectElement) {
    try {
        // Ensure IRAC notes are loaded and flattened
        if (!window.iracNotesManager.loaded) {
            await window.iracNotesManager.loadNotes();
        }

        selectElement.innerHTML = '<option value="">Select IRAC Note...</option>';

        // Categories for Field 500 (IRAC coordination notes only)
        const field500Categories = [
            { key: 'coordination', label: 'Coordination Notes (C-series)' },
            { key: 'emission', label: 'Emission Notes (E-series)' },
            { key: 'limitation', label: 'Limitation Notes (L-series)' },
            { key: 'special', label: 'Special Notes (S-series)' },
            { key: 'priority', label: 'Priority Notes (P-series)' }
            // Note: M-series notes go in field 501, not field 500
        ];

        field500Categories.forEach(category => {
            const notes = window.iracNotesManager.getNotesByCategory(category.key);
            if (notes.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = `${category.label} (${notes.length} entries)`;

                notes.forEach(note => {
                    const option = document.createElement('option');
                    option.value = note.code;
                    option.textContent = `${note.code} - ${note.title}`;

                    // Add tooltip with full description if available
                    if (note.description) {
                        option.title = note.description;
                    }

                    optgroup.appendChild(option);
                });

                selectElement.appendChild(optgroup);
            }
        });

        console.log('✅ IRAC notes select populated with', Object.keys(window.iracNotesManager.notes).length, 'total notes');

    } catch (error) {
        console.error('Error populating IRAC notes select:', error);
        selectElement.innerHTML = '<option value="">Error loading notes</option>';
    }
}

// 500 IRAC Notes Entry (MCEB Pub 7 Compliant)
document.addEventListener('DOMContentLoaded', async () => {
    // ✅ Connect Notes Button (using existing button from sidebar.txt)
    const addIracBtn = document.getElementById('addIRACNotesEntry');
    if (addIracBtn) {
        addIracBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('🔄 Add Notes Entry button clicked');
            addIRACNotesEntry(); // Your renamed function
        });
        console.log('✅ Add Notes Entry button connected');
    } else {
        console.error('❌ addIRACNotesEntry button not found');
    }

    // 🆕 ADD THIS: Initialize existing IRAC notes dropdown
    const existingSelect = document.querySelector('#field500_1.irac-notes-select');
    if (existingSelect) {
        await populateIracNotesSelect(existingSelect);
        console.log('✅ Initial IRAC notes dropdown populated');
    }
});

async function addIRACNotesEntry() {
    const container = document.getElementById('irac-notes-entries') ||
        document.querySelector('[data-section="supplementary"] .section-content #irac-notes-entries');
    if (!container) {
        showNotification('IRAC notes container not found', 'error');
        return;
    }

    const entryCount = container.querySelectorAll('.notes-entry').length + 1;

    if (entryCount > 10) {
        showNotification('Maximum 10 IRAC note occurrences allowed per MCEB Pub 7 field 500', 'error');
        return;
    }

    const newEntry = document.createElement('div');
    newEntry.className = 'dynamic-entry notes-entry';
    newEntry.dataset.entry = entryCount;

    newEntry.innerHTML = `
        <div class="entry-header">
            <span class="entry-title">IRAC Note #${entryCount}</span>
            <button class="remove-entry-btn" onclick="this.parentElement.parentElement.remove()">✕</button>
        </div>
        <div class="form-row">
            <label for="field500_${entryCount}">500 - IRAC Notes:</label>
            <select id="field500_${entryCount}" class="form-control irac-notes-select" data-field="500">
                <option value="">Loading IRAC notes...</option>
            </select>
            <small class="field-help">Official IRAC coordination note codes (MCEB Pub 7 Annex E)</small>
        </div>
        <div class="irac-note-details" style="display:none;">
            <small class="note-description"></small>
        </div>
    `;

    // Add to container first
    container.appendChild(newEntry);

    // Then populate the select
    const selectElement = newEntry.querySelector('.irac-notes-select');
    await populateIracNotesSelect(selectElement);

    addValidationListeners(newEntry);
    console.log(`✅ Added IRAC note entry #${entryCount}`);
    showNotification(`IRAC note #${entryCount} added`, 'success');
}

// Add marker creation to sidebar (similar to existing entry functions)
function addMarkerFromSidebar() {
    // Create marker input form
    const markerForm = document.createElement('div');
    markerForm.className = 'dynamic-entry marker-entry';
    markerForm.innerHTML = `
        <div class="form-row">
            <label for="marker-lat">Latitude:</label>
            <input type="number" id="marker-lat" class="form-control" 
                   step="0.0001" placeholder="30.4300">
        </div>
        <div class="form-row">
            <label for="marker-lng">Longitude:</label>
            <input type="number" id="marker-lng" class="form-control" 
                   step="0.0001" placeholder="-86.6950">
        </div>
        <button onclick="createMarkerFromCoords()">Create Marker</button>
    `;
}

window.iracNotesManager = {
    loaded: false,
    notes: {},
    categorizedNotes: {},
    metadata: {},

    async loadNotes() {
        try {
            console.log('🔄 Loading IRAC notes from external reference file...');

            const response = await fetch('/references/irac-notes-reference.json');

            if (response.ok) {
                const referenceData = await response.json();

                // ✅ STEP 1: Extract categorized notes from your structured format
                this.categorizedNotes = {
                    coordination: referenceData.coordination || {},
                    emission: referenceData.emission || {},
                    limitation: referenceData.limitation || {},
                    special: referenceData.special || {},
                    priority: referenceData.priority || {},
                    minute: referenceData.minute || {}
                };

                // Extract metadata for compliance checking
                this.metadata = referenceData.metadata || {};

                // ✅ STEP 2: FLATTEN ALL NOTES INTO SINGLE OBJECT
                this.notes = {};

                // Process each category
                Object.entries(this.categorizedNotes).forEach(([categoryName, categoryNotes]) => {
                    console.log(`📊 Processing ${categoryName} category...`);

                    Object.entries(categoryNotes).forEach(([code, noteData]) => {
                        // Handle different data structures in your JSON
                        if (typeof noteData === 'string') {
                            // Simple string value
                            this.notes[code] = noteData;
                        } else if (noteData && typeof noteData === 'object') {
                            // Complex object with title/description
                            this.notes[code] = noteData.title || noteData.description || code;
                        } else {
                            // Fallback to code itself
                            this.notes[code] = code;
                        }
                    });
                });

                console.log('✅ IRAC Notes loaded from external file:', Object.keys(this.notes).length, 'entries');
                console.log('📊 Categories processed:', Object.keys(this.categorizedNotes));
                console.log('📊 Flattened notes sample:', Object.keys(this.notes).slice(0, 10));

            } else {
                throw new Error(`HTTP ${response.status}: Failed to load external reference file`);
            }

        } catch (error) {
            console.warn('⚠️ Failed to load external IRAC notes reference, using fallback:', error.message);

            // ✅ FALLBACK: Create both categorized and flattened structures
            this.categorizedNotes = {
                coordination: {
                    "C010": { title: "Gulf Area Frequency Coordinator" },
                    "C019": { title: "Army Frequency Management Office" }
                },
                emission: {
                    "E029": { title: "Upper sideband transmission" }
                },
                limitation: {
                    "L012": { title: "Emergency use only" }
                },
                special: {
                    "S063": { title: "Search and rescue communications" },
                    "S142": { title: "Drone Control" },
                    "S148": { title: "National emergency communications" }
                },
                priority: {},
                minute: {}
            };

            // Flatten fallback data
            this.notes = {};
            Object.values(this.categorizedNotes).forEach(category => {
                Object.entries(category).forEach(([code, noteData]) => {
                    this.notes[code] = noteData.title || code;
                });
            });

            console.log('✅ IRAC Notes loaded from fallback data:', Object.keys(this.notes).length, 'entries');
        } finally {
            this.loaded = true;
        }
    },

    // ✅ ENHANCED METHOD that works with both flattened and categorized data
    getNotesByCategory(category) {
        const categoryMap = {
            'coordination': 'coordination',
            'emission': 'emission',
            'limitation': 'limitation',
            'special': 'special',
            'priority': 'priority',
            'minute': 'minute',
        };

        const mappedCategory = categoryMap[category];
        if (!mappedCategory) {
            console.warn(`Category '${category}' not found`);
            return [];
        }

        // Use categorized data if available, otherwise filter flattened data
        if (this.categorizedNotes[mappedCategory]) {
            return Object.entries(this.categorizedNotes[mappedCategory]).map(([code, noteData]) => ({
                code,
                title: noteData.title || noteData.description || noteData || code,
                description: noteData.description || noteData.title || noteData || '',
                agency: noteData.agency || [],
                category: noteData.category || mappedCategory
            }));
        } else {
            // Fallback: filter flattened notes by prefix
            const categoryPrefixes = {
                'coordination': 'C',
                'emission': 'E',
                'limitation': 'L',
                'special': 'S',
                'priority': 'P',
                'minute': 'M'
            };

            const prefix = categoryPrefixes[category];
            if (!prefix) return [];

            return Object.entries(this.notes)
                .filter(([code]) => code.startsWith(prefix))
                .map(([code, title]) => ({
                    code,
                    title: title || code
                }));
        }
    },

    // Get all notes in flattened format
    getAllNotes() {
        return Object.entries(this.notes).map(([code, title]) => ({
            code,
            title: title || code
        }));
    }
};

// Add this to buttonFunctions.txt after the existing IRAC Notes section
document.addEventListener('DOMContentLoaded', () => {
    // ✅ Connect Clear All Markers Button (Overview tab)
    const clearAllBtn = document.getElementById('clearAllMarkers');
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('🔄 Clear All Markers button clicked');

            // Call clearAllMarkers function from map.txt
            if (window.clearAllMarkers && typeof window.clearAllMarkers === 'function') {
                window.clearAllMarkers();
            } else {
                console.error('clearAllMarkers function not found');
                showNotification('❌ Clear all function not available', 'error');
            }
        });
        console.log('✅ Clear All Markers button connected');
    } else {
        console.error('❌ clearAllMarkers button not found - check button ID in Overview tab');
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // Connect Object tab delete button
    const objectDeleteBtn = document.getElementById('deleteObjectBtn');
    if (objectDeleteBtn) {
        objectDeleteBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('🔄 Object delete button clicked');

            // Confirm deletion with user
            if (confirm('Delete this object and all associated SFAF data?\n\nThis action cannot be undone.')) {
                deleteCurrentObject();
            }
        });
        console.log('✅ Object delete button connected');
    } else {
        console.error('❌ Object delete button not found');
    }
});

async function deleteCurrentObject() {
    try {
        const currentObjectId = window.currentSFAFMarker?.id;
        if (!currentObjectId) {
            showNotification('❌ No object selected for deletion', 'error');
            return;
        }
        
        console.log('🔄 Attempting to delete marker:', currentObjectId);
        
        // IMMEDIATE: Start visual cleanup before backend call
        const targetMarker = window.markers?.get(currentObjectId);
        if (targetMarker && typeof targetMarker.setOpacity === 'function') {
            targetMarker.setOpacity(0.3); // Make marker semi-transparent immediately
        }
        
        // Call backend delete API
        const response = await fetch(`/api/markers/${currentObjectId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            console.log('✅ Backend deletion successful');
            
            // IMMEDIATE: Clear object tab state first
            clearObjectTabState();
            
            // IMMEDIATE: Remove marker from all frontend systems
            removeMarkerFromMap(currentObjectId);
            
            // IMMEDIATE: Close sidebar
            if (typeof closePersistentSidebar === 'function') {
                closePersistentSidebar();
            }
            
            // IMMEDIATE: Additional cleanup with shorter delays
            setTimeout(() => {
                // Final cleanup sweep
                const remainingElements = document.querySelectorAll('.leaflet-marker-icon, .leaflet-marker-shadow');
                remainingElements.forEach(element => {
                    if (!element.offsetParent) {
                        element.remove();
                    }
                });
                
                // Force map refresh
                if (window.map && typeof window.map.invalidateSize === 'function') {
                    window.map.invalidateSize();
                }
            }, 50);
            
            showNotification('✅ Object deleted successfully', 'success');
            
        } else {
            // Restore marker opacity if deletion failed
            if (targetMarker && typeof targetMarker.setOpacity === 'function') {
                targetMarker.setOpacity(1.0);
            }
            
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
    } catch (error) {
        console.error('❌ Delete operation failed:', error);
        showNotification(`❌ Failed to delete object: ${error.message}`, 'error');
    }
}

function clearObjectTabState() {
    console.log('🔄 Clearing Object tab state');
    
    // Clear current object references
    window.currentSFAFMarker = null;
    window.currentSelectedMarker = null;
    
    // Clear all form fields in Object tab (excluding IRAC-specific fields)
    document.querySelectorAll('#tab-object input, #tab-object select, #tab-object textarea').forEach(field => {
        // Skip IRAC notes fields
        if (!field.classList.contains('irac-notes-select') && 
            !field.closest('.irac-note-details')) {
            
            if (field.type === 'checkbox' || field.type === 'radio') {
                field.checked = false;
            } else {
                field.value = '';
            }
        }
    });
    
    console.log('✅ Object tab state cleared');
}

function removeMarkerFromMap(markerId) {
    try {
        console.log('🔄 Removing marker from map:', markerId);
        
        // 1. Remove from markers Map storage (primary cleanup)
        if (window.markers && window.markers.has(markerId)) {
            const marker = window.markers.get(markerId);
            if (marker) {
                // Try multiple removal methods
                if (typeof marker.remove === 'function') {
                    marker.remove();
                    console.log('✅ Marker removed via marker.remove()');
                } else if (window.map && typeof window.map.removeLayer === 'function') {
                    window.map.removeLayer(marker);
                    console.log('✅ Marker removed via map.removeLayer()');
                }
                
                // Force immediate removal from map if still attached
                if (marker._map) {
                    marker._map.removeLayer(marker);
                    console.log('✅ Marker force removed from _map');
                }
            }
            window.markers.delete(markerId);
            console.log('✅ Marker removed from markers Map');
        }
        
        // 2. Remove from drawnItems layer group
        if (window.drawnItems && typeof window.drawnItems.eachLayer === 'function') {
            const layersToRemove = [];
            window.drawnItems.eachLayer(function(layer) {
                if (layer.markerData && layer.markerData.id === markerId) {
                    layersToRemove.push(layer);
                }
            });
            layersToRemove.forEach(layer => {
                window.drawnItems.removeLayer(layer);
            });
            console.log('✅ Marker removed from drawnItems');
        }
        
        // 3. ENHANCED: Aggressive DOM cleanup - multiple approaches
        const cleanupMarkerDOM = () => {
            // Approach 1: Target all potential marker elements
            const allMarkerElements = document.querySelectorAll(`
                .leaflet-marker-icon, 
                .leaflet-marker-shadow,
                .leaflet-marker-pane img,
                .leaflet-marker-pane div,
                [data-marker-id="${markerId}"]
            `);
            
            let elementsRemoved = 0;
            allMarkerElements.forEach(element => {
                let shouldRemove = false;
                
                // Check multiple attributes for marker ID
                if (element.alt && element.alt.includes(markerId)) {
                    shouldRemove = true;
                } else if (element.src && element.src.includes(markerId)) {
                    shouldRemove = true;
                } else if (element.dataset && element.dataset.markerId === markerId) {
                    shouldRemove = true;
                } else if (element.title && element.title.includes(markerId)) {
                    shouldRemove = true;
                }
                
                if (shouldRemove) {
                    const parent = element.parentElement;
                    if (parent) {
                        parent.remove();
                    } else {
                        element.remove();
                    }
                    elementsRemoved++;
                }
            });
            
            // Approach 2: Remove orphaned marker elements (no valid parent or invisible)
            const orphanedElements = document.querySelectorAll('.leaflet-marker-icon, .leaflet-marker-shadow');
            orphanedElements.forEach(element => {
                if (!element.offsetParent || !element.isConnected) {
                    element.remove();
                    elementsRemoved++;
                }
            });
            
            console.log(`✅ DOM cleanup removed ${elementsRemoved} elements`);
        };
        
        // Run cleanup immediately and with delays to catch dynamic elements
        cleanupMarkerDOM();
        setTimeout(cleanupMarkerDOM, 50);
        setTimeout(cleanupMarkerDOM, 150);
        setTimeout(cleanupMarkerDOM, 300);
        
        // 4. Clear coordinate cache entries
        if (window.coordinateCache) {
            const keysToDelete = [];
            window.coordinateCache.forEach((value, key) => {
                if (key.includes(markerId)) {
                    keysToDelete.push(key);
                }
            });
            keysToDelete.forEach(key => window.coordinateCache.delete(key));
            console.log('✅ Coordinate cache cleared');
        }
        
        // 5. Force map redraw to ensure visual synchronization
        if (window.map) {
            setTimeout(() => {
                if (typeof window.map.invalidateSize === 'function') {
                    window.map.invalidateSize();
                }
                if (typeof window.map._resetView === 'function') {
                    window.map._resetView(window.map.getCenter(), window.map.getZoom());
                }
            }, 100);
        }
        
    } catch (error) {
        console.error('❌ Error removing marker from map:', error);
        
        // Fallback: Force removal from markers Map
        if (window.markers && window.markers.has(markerId)) {
            window.markers.delete(markerId);
            console.log('✅ Marker removed from markers Map (fallback)');
        }
    }
}

// 501 Comments Entry (MCEB Pub 7 Compliant)
function addCommentsEntryManual() {
    const container = document.getElementById('comments-entries');
    if (!container) {
        showNotification('Comments container not found', 'error');
        return;
    }

    const entryCount = container.querySelectorAll('.comment-entry').length + 1;
    if (entryCount > 30) {
        showNotification('Maximum 30 comment occurrences allowed per MCEB Pub 7 field 501', 'error');
        return;
    }

    container.appendChild(newEntry);
    addValidationListeners(newEntry);
    console.log(`✅ Added emission characteristics entry #${entryCount} (MCEB Pub 7 compliant)`);
    showNotification(`Emission characteristics #${entryCount} added`, 'success')
};// irac-notes-loader.js
class iracNotesManager {
    constructor() {
        this.notes = {};
        this.loaded = false;
    }
    
    async loadNotes() {
        try {
            const response = await fetch('./data/irac-notes-reference.json');
            this.notes = await response.json();
            this.loaded = true;
            console.log('✅ IRAC notes reference loaded successfully');
            return this.notes;
        } catch (error) {
            console.error('❌ Failed to load IRAC notes reference:', error);
            return this.getFallbackNotes();
        }
    }
    
    getFallbackNotes() {
        // Fallback to hardcoded essential notes if file fails to load
        return {
            coordination: {
                "C010": { code: "C010", title: "Gulf Area Frequency Coordinator" }
            },
            limitation: {
                "L012": { code: "L012", title: "Emergency use only" }
            },
            special: {
                "S142": { code: "S142", title: "Drone Control" },
                "S148": { code: "S148", title: "National emergency communications" }
            }
        };
    }
    
    getAllNotes() {
        const allNotes = [];
        
        // Handle categorized structure from reference file
        if (this.notes.coordination || this.notes.limitation) {
            Object.values(this.notes).forEach(category => {
                if (typeof category === 'object') {
                    Object.values(category).forEach(note => {
                        allNotes.push(note);
                    });
                }
            });
        } else {
            // Handle flat structure fallback
            Object.entries(this.notes).forEach(([code, description]) => {
                allNotes.push({ code, title: description });
            });
        }
        
        return allNotes.sort((a, b) => a.code.localeCompare(b.code));
    }
    
    searchNotes(query) {
        return this.getAllNotes().filter(note =>
            note.code.toLowerCase().includes(query.toLowerCase()) ||
            note.title.toLowerCase().includes(query.toLowerCase()) ||
            (note.description && note.description.toLowerCase().includes(query.toLowerCase()))
        );
    }
    
    getNotesByCategory(categoryKey) {
        // Handle categorized structure
        if (this.notes[categoryKey]) {
            return Object.values(this.notes[categoryKey]);
        }
        
        // Handle flat structure fallback
        const categorizedNotes = [];
        Object.entries(this.notes).forEach(([code, description]) => {
            const prefix = code.charAt(0).toLowerCase();
            
            switch (categoryKey) {
                case 'coordination':
                    if (prefix === 'c') {
                        categorizedNotes.push({ 
                            code, 
                            title: typeof description === 'string' ? description : description.title 
                        });
                    }
                    break;
                case 'emission':
                    if (prefix === 'e') {
                        categorizedNotes.push({ 
                            code, 
                            title: typeof description === 'string' ? description : description.title 
                        });
                    }
                    break;
                case 'limitation':
                    if (prefix === 'l') {
                        categorizedNotes.push({ 
                            code, 
                            title: typeof description === 'string' ? description : description.title 
                        });
                    }
                    break;
                case 'special':
                    if (prefix === 's') {
                        categorizedNotes.push({ 
                            code, 
                            title: typeof description === 'string' ? description : description.title 
                        });
                    }
                    break;
                case 'priority':
                    if (prefix === 'p') {
                        categorizedNotes.push({ 
                            code, 
                            title: typeof description === 'string' ? description : description.title 
                        });
                    }
                    break;
            }
        });
        
        return categorizedNotes;
    }
}

// Global instance
window.iracNotesManager = new iracNotesManager();// 1. Field specifications object - Complete SFAF field specifications with character limits and max occurrences from MCEB Pub 7
const sfafFieldSpecs = {
    // Administrative Data
    'field005': { maxLength: 2, maxOccurrences: 1, title: 'Security Classification', options: ['U', 'UE', 'C', 'S'] },
    'field010': { maxLength: 1, maxOccurrences: 1, title: 'Type of Action', options: ['M', 'N', 'D', 'R'] },
    'field013': { maxLength: 35, maxOccurrences: 1, title: 'Declassification Instruction Comment' },
    'field019': { maxLength: 8, maxOccurrences: 1, title: 'Declassification Date' },
    'field102': { maxLength: 10, maxOccurrences: 1, title: 'Agency Serial Number' },
    'field701': { maxLength: 3, maxOccurrences: 1, title: 'Frequency Action Officer' },
    'field702': { maxLength: 15, maxOccurrences: 1, title: 'Control/Request Number' },

    // Emission Characteristics (Dynamic - up to 20 occurrences each per MCEB Pub 7)
    'field110': { maxLength: 11, maxOccurrences: 20, title: 'Frequency(ies)', dynamic: true },
    'field113': { maxLength: 4, maxOccurrences: 20, title: 'Station Class', dynamic: true },
    'field114': { maxLength: 11, maxOccurrences: 20, title: 'Emission Designator', dynamic: true },
    'field115': { maxLength: 9, maxOccurrences: 20, title: 'Transmitter Power', dynamic: true },
    'field116': { maxLength: 1, maxOccurrences: 20, title: 'Power Type', dynamic: true, options: ['C', 'M', 'P'] },
    'field117': { maxLength: 6, maxOccurrences: 20, title: 'Effective Radiated Power', dynamic: true },
    'field118': { maxLength: 1, maxOccurrences: 20, title: 'Power/ERP Augmentation', dynamic: true },

    // Time/Date Information
    'field130': { maxLength: 4, maxOccurrences: 1, title: 'Time' },
    'field131': { maxLength: 2, maxOccurrences: 1, title: 'Percent Time' },
    'field140': { maxLength: 8, maxOccurrences: 1, title: 'Required Date (YYYYMMDD)' },
    'field141': { maxLength: 8, maxOccurrences: 1, title: 'Expiration Date (YYYYMMDD)' },
    'field142': { maxLength: 8, maxOccurrences: 1, title: 'Review Date (YYYYMMDD)' },
    'field143': { maxLength: 8, maxOccurrences: 1, title: 'Revision Date (YYYYMMDD)' },
    'field144': { maxLength: 1, maxOccurrences: 1, title: 'Approval Authority', options: ['Y', 'N', 'U'] },

    // Organizational Information
    'field200': { maxLength: 6, maxOccurrences: 1, title: 'Agency', options: ['USAF', 'USA', 'USN', 'USMC', 'USCG'] },
    'field201': { maxLength: 8, maxOccurrences: 10, title: 'Unified Command' },
    'field202': { maxLength: 8, maxOccurrences: 10, title: 'Unified Command Service' },
    'field204': { maxLength: 18, maxOccurrences: 1, title: 'Command' },
    'field205': { maxLength: 18, maxOccurrences: 1, title: 'Subcommand' },
    'field206': { maxLength: 18, maxOccurrences: 1, title: 'Installation Frequency Manager' },
    'field207': { maxLength: 18, maxOccurrences: 10, title: 'Operating Unit' },
    'field209': { maxLength: 18, maxOccurrences: 10, title: 'Area AFC/DoD AFC' },

    // Transmitter Location (Geographic codes A-Z per MCEB Pub 7 Annex E)
    'field300': { maxLength: 4, maxOccurrences: 1, title: 'State/Country' },
    'field301': { maxLength: 24, maxOccurrences: 1, title: 'Antenna Location' },
    'field303': { maxLength: 15, maxOccurrences: 1, title: 'Antenna Coordinates' },
    'field306': { maxLength: 5, maxOccurrences: 1, title: 'Authorized Radius' },

    // Transmitter Equipment (Dynamic - up to 10 occurrences each per MCEB Pub 7)
    'field340': { maxLength: 18, maxOccurrences: 10, title: 'Equipment Nomenclature', dynamic: true },
    'field343': { maxLength: 15, maxOccurrences: 10, title: 'Equipment Certification ID', dynamic: true },

    // Transmitter Antenna
    'field357': { maxLength: 4, maxOccurrences: 10, title: 'Antenna Gain' },
    'field362': { maxLength: 3, maxOccurrences: 10, title: 'Antenna Orientation' },
    'field363': { maxLength: 1, maxOccurrences: 10, title: 'Antenna Polarization', options: ['V', 'H', 'C'] },
    'field373': { maxLength: 1, maxOccurrences: 1, title: 'JSC Area Code' },

    // Receiver Location
    'field400': { maxLength: 4, maxOccurrences: 1, title: 'State/Country' },
    'field401': { maxLength: 24, maxOccurrences: 1, title: 'Antenna Location' },
    'field403': { maxLength: 15, maxOccurrences: 1, title: 'Antenna Coordinates' },

    // Receiver Equipment (Dynamic - up to 10 occurrences each per MCEB Pub 7)
    'field440': { maxLength: 18, maxOccurrences: 10, title: 'Equipment Nomenclature', dynamic: true },
    'field443': { maxLength: 15, maxOccurrences: 10, title: 'Equipment Certification ID', dynamic: true },

    // Receiver Antenna
    'field457': { maxLength: 4, maxOccurrences: 10, title: 'Antenna Gain' },
    'field462': { maxLength: 3, maxOccurrences: 10, title: 'Antenna Orientation' },
    'field463': { maxLength: 1, maxOccurrences: 10, title: 'Antenna Polarization', options: ['V', 'H', 'C'] },
    'field473': { maxLength: 1, maxOccurrences: 1, title: 'JSC Area Code', options: ['A', 'B', 'C', 'D'] },

    // Supplementary Details (IRAC Notes and Comments)
    'field500': { maxLength: 4, maxOccurrences: 10, title: 'IRAC Notes', dynamic: true },
    'field501': { maxLength: 35, maxOccurrences: 30, title: 'Notes/Comments', dynamic: true },
    'field502': { maxLength: 1440, maxOccurrences: 1, title: 'Description of Requirement' },
    'field503': { maxLength: 35, maxOccurrences: 30, title: 'Agency Free-text Comments' },
    'field511': { maxLength: 30, maxOccurrences: 1, title: 'Major Function Identifier' },
    'field512': { maxLength: 30, maxOccurrences: 1, title: 'Intermediate Function Identifier' },
    'field513': { maxLength: 30, maxOccurrences: 1, title: 'Minor Function Identifier' },
    'field520': { maxLength: 1080, maxOccurrences: 1, title: 'Supplementary Details' },

    // Other Assignment Identifiers
    'field716': { maxLength: 1, maxOccurrences: 1, title: 'Usage Code' },
    'field801': { maxLength: 60, maxOccurrences: 20, title: 'Coordination Data/Remarks' },
    'field803': { maxLength: 60, maxOccurrences: 1, title: 'Requestor Data POC' },
    'field804': { maxLength: 60, maxOccurrences: 30, title: 'Tuning Range/Tuning Increments' }
};

(function () {
    'use strict';

    // Prevent multiple initializations
    if (window.sfafFieldManager) {
        console.log('⚠️ SFAF Manager already exists');
        return;
    }

    class SFAFFieldManager {
        constructor() {
            this.fieldSpecs = this.initializeFieldSpecs();
            this.geographicCodes = {};
            this.iracNotes = {};
            this.functionIdentifiers = [];
            this.equipmentManufacturers = {};
            this.timeCodeDefinitions = {};
            this.powerTypes = {};

            // Initialize with MCEB compliance
            this.initializeWithMCEBCompliance();
        }

        // Initialize field specifications
        initializeFieldSpecs() {
            return {
                'field005': { title: 'Security Classification', maxLength: 15, required: true },
                'field010': { title: 'Type of Action', maxLength: 3, required: true },
                'field013': { title: 'Priority Indicator', maxLength: 1 },
                'field019': { title: 'Coordination Required', maxLength: 1 },
                'field102': { title: 'Agency Serial Number', maxLength: 20, required: true },
                'field110': { title: 'Frequency', maxLength: 14, dynamic: true, maxOccurrences: 300, required: true },
                'field113': { title: 'Station Class', maxLength: 3, dynamic: true, maxOccurrences: 300, required: true },
                'field114': { title: 'Emission Designator', maxLength: 11, dynamic: true, maxOccurrences: 300, required: true },
                'field115': { title: 'Transmitter Power', maxLength: 11, dynamic: true, maxOccurrences: 300, required: true },
                'field116': { title: 'Power Type', maxLength: 1, dynamic: true, maxOccurrences: 300 },
                'field117': { title: 'Antenna Gain', maxLength: 7, dynamic: true, maxOccurrences: 300 },
                'field118': { title: 'Antenna Pattern', maxLength: 3, dynamic: true, maxOccurrences: 300 },
                'field130': { title: 'Time Code', maxLength: 4 },
                'field131': { title: 'Percent Time', maxLength: 2 },
                'field140': { title: 'Start Date', maxLength: 8 },
                'field141': { title: 'Stop Date', maxLength: 8 },
                'field142': { title: 'Repetitive Start Date', maxLength: 8 },
                'field143': { title: 'Repetitive Stop Date', maxLength: 8 },
                'field144': { title: 'Years of Repetition', maxLength: 2 },
                'field200': { title: 'Agency', maxLength: 4, required: true },
                'field201': { title: 'Station Serial Number', maxLength: 20 },
                'field202': { title: 'Net Identifier', maxLength: 20 },
                'field204': { title: 'Station Call Sign', maxLength: 10 },
                'field205': { title: 'Circuit Identifier', maxLength: 20 },
                'field206': { title: 'Geographic Code', maxLength: 1 },
                'field207': { title: 'Function Identifier', maxLength: 50 },
                'field208': { title: 'Equipment Designation', maxLength: 40, dynamic: true, maxOccurrences: 50 },
                'field209': { title: 'Supplementary Details', maxLength: 200, dynamic: true, maxOccurrences: 50 },
                'field300': { title: 'State/Country (TX)', maxLength: 2, required: true },
                'field301': { title: 'Antenna Location (TX)', maxLength: 30, required: true },
                'field303': { title: 'Antenna Coordinates (TX)', maxLength: 15, required: true },
                'field306': { title: 'Geographic Area (TX)', maxLength: 1 },
                'field340': { title: 'TX Equipment Class', maxLength: 20, dynamic: true, maxOccurrences: 50 },
                'field343': { title: 'TX Equipment Manufacturer', maxLength: 3, dynamic: true, maxOccurrences: 50 },
                'field357': { title: 'TX Antenna Height AGL', maxLength: 6 },
                'field362': { title: 'TX Antenna Azimuth', maxLength: 3 },
                'field363': { title: 'TX Antenna Elevation', maxLength: 4 },
                'field373': { title: 'TX Antenna Polarization', maxLength: 1 },
                'field400': { title: 'State/Country (RX)', maxLength: 2, required: true },
                'field401': { title: 'Antenna Location (RX)', maxLength: 30, required: true },
                'field403': { title: 'Antenna Coordinates (RX)', maxLength: 15, required: true },
                'field407': { title: 'Geographic Area (RX)', maxLength: 1 },
                'field440': { title: 'RX Equipment Class', maxLength: 20, dynamic: true, maxOccurrences: 50 },
                'field443': { title: 'RX Equipment Manufacturer', maxLength: 3, dynamic: true, maxOccurrences: 50 },
                'field457': { title: 'RX Antenna Height AGL', maxLength: 6 },
                'field462': { title: 'RX Antenna Azimuth', maxLength: 3 },
                'field463': { title: 'RX Antenna Elevation', maxLength: 4 },
                'field470': { title: 'RX Antenna Beamwidth H', maxLength: 3 },
                'field471': { title: 'RX Antenna Beamwidth V', maxLength: 3 },
                'field472': { title: 'RX Antenna Front-to-Back', maxLength: 3 },
                'field473': { title: 'RX Antenna Polarization', maxLength: 1 },
                'field500': { title: 'IRAC Coordination Notes', maxLength: 3, dynamic: true, maxOccurrences: 100 },
                'field501': { title: 'Coordination Comments', maxLength: 200, dynamic: true, maxOccurrences: 100 },
                'field502': { title: 'Justification', maxLength: 200 },
                'field503': { title: 'Additional Information', maxLength: 200 },
                'field511': { title: 'Link Budget', maxLength: 200 },
                'field512': { title: 'Bandwidth Justification', maxLength: 200 },
                'field513': { title: 'RF Exposure Analysis', maxLength: 200 },
                'field520': { title: 'Technical Contact', maxLength: 50 },
                'field701': { title: 'Host Nation Frequency', maxLength: 14 },
                'field702': { title: 'NTIA Identifier', maxLength: 9 },
                'field716': { title: 'Previous Assignment ID', maxLength: 20 },
                'field801': { title: 'ITU Region', maxLength: 1 },
                'field803': { title: 'ITU Notification Number', maxLength: 20 },
                'field804': { title: 'ITU Notification Date', maxLength: 8 },
                'field903': { title: 'Coordination Status', maxLength: 20 }
            };
        }

        // Initialize with MCEB Pub 7 compliance
        initializeWithMCEBCompliance() {
            console.log('✅ SFAF Field Manager initialized with MCEB Pub 7 compliance');

            // Load all official MCEB Pub 7 reference data
            this.geographicCodes = this.loadOfficialGeographicCodes();
            this.iracNotes = this.loadOfficialIRACNotes();
            this.functionIdentifiers = this.loadOfficialFunctionIdentifiers();
            this.equipmentManufacturers = this.loadOfficialEquipmentCodes();
            this.timeCodeDefinitions = this.loadOfficialTimeCodes();
            this.powerTypes = this.loadOfficialPowerTypes();

            // Initialize validation and dynamic entry management
            this.initializeValidation();
            this.initializeDynamicEntries();
            this.addFieldCounters();
            this.enableAutoSave();
            this.initializeExistingButtons();

            console.log('📊 Loaded official MCEB Pub 7 reference data:');
            console.log(`  - Geographic codes: ${Object.keys(this.geographicCodes).length} regions`);
            console.log(`  - IRAC coordination notes: ${Object.keys(this.iracNotes).length} notes`);
            console.log(`  - Function identifiers: ${this.functionIdentifiers.length} functions`);
            console.log(`  - Equipment manufacturer codes: ${Object.keys(this.equipmentManufacturers).length} codes`);
        }

        // Load official power type codes from MCEB Pub 7 field 116
        loadOfficialPowerTypes() {
            return {
                'C': {
                    description: 'Carrier Power',
                    usage: 'Use this for "N0N" and for "A3E" sound broadcasting service (Station Class "BC")'
                },
                'M': {
                    description: 'Mean Power',
                    usage: 'For all air to air (A/A) & air/ground/air (A/G/A). Use this for most AM emissions using unkeyed full carrier and all frequency modulated emissions. Typical emissions include A2A, A2B, A3C, A3E, A3F, A7B, AXX, F1B, F1C, F2B, F3E, F3F, F7B, FXX, H2A, H3E, and H7B'
                },
                'P': {
                    description: 'Peak Envelope Power',
                    usage: 'Use this for all pulsed equipment, C3F Television, and the following classes: A1A, A1B, A7B, B7B, B8C, B8E, BXX, C3F, G3E, J2B, J3E, J7B, JXX, K1B, K2B, K3E, K3F, L2B, M2B, M3E, P0N, PXX, R2B and R3C'
                }
            };
        }

        // Load official geographic codes from MCEB Pub 7 Annex E
        loadOfficialGeographicCodes() {
            return {
                'A': {
                    description: 'Northeast US',
                    locations: ['ALABAMA', 'CHESAPEAKE BAY', 'CONNECTICUT', 'DELAWARE', 'DISTRICT OF COLUMBIA',
                        'FIRST NAV DISTRICT', 'LAKE ONTARIO', 'MAINE', 'MARYLAND', 'MASSACHUSETTS',
                        'NAV DIST WASH DC', 'NEW HAMPSHIRE', 'NEW JERSEY', 'NEW YORK', 'PENNSYLVANIA',
                        'RHODE ISLAND', 'THIRD NAV DISTRICT', 'VERMONT', 'VIRGINIA', 'WEST VIRGINIA']
                },
                'B': {
                    description: 'Great Lakes Region',
                    locations: ['GREAT LAKES', 'ILLINOIS', 'INDIANA', 'IOWA', 'KENTUCKY', 'LAKE ERIE',
                        'LAKE SUPERIOR', 'LAKE HURON', 'LAKE MICHIGAN', 'MICHIGAN', 'MINNESOTA',
                        'MISSOURI', 'OHIO', 'WISCONSIN']
                },
                'C': {
                    description: 'Southeast US',
                    locations: ['ALABAMA', 'FLORIDA', 'GEORGIA', 'MISSISSIPPI', 'NORTH CAROLINA',
                        'SIXTH NAV DISTRICT', 'SOUTH CAROLINA', 'TENNESSEE']
                },
                'D': {
                    description: 'Rocky Mountain/Plains',
                    locations: ['COLORADO', 'IDAHO', 'KANSAS', 'MONTANA', 'NEBRASKA', 'NORTH DAKOTA',
                        'RCKY MTN RGN. CAP 7', 'SOUTH DAKOTA', 'UTAH', 'WYOMING']
                },
                'E': {
                    description: 'South Central US',
                    locations: ['ARIZONA', 'ARKANSAS', 'EIGHTH NAV DIST', 'LOUISIANA', 'NEW MEXICO',
                        'OKLAHOMA', 'SW REGION CAP 6', 'TEXAS']
                },
                'F': {
                    description: 'Pacific US',
                    locations: ['CALIFORNIA', 'NEVADA', 'OREGON', 'PAC REGION CAP 8', 'WASHINGTON']
                },
                'G': {
                    description: 'Alaska (mainland)',
                    locations: ['ALASKA', 'PACIFIC OCEAN NE']
                },
                'H': {
                    description: 'Pacific Ocean/Hawaii/Alaska Aleutians',
                    locations: ['ALASKA ALEUTIAN IS', 'BERING SEA', 'FOURTEENTH NAV DIS', 'HAWAII',
                        'JOHNSTON ISLAND', 'MIDWAY ISLAND', 'PACIFIC OCEAN NW']
                },
                'J': {
                    description: 'Canada/Greenland/Iceland',
                    locations: ['ATLANTIC OCEAN NW', 'AZORES', 'CANADA', 'GREENLAND', 'ICELAND', 'JAN MAYEN']
                },
                'K': {
                    description: 'Caribbean/Central America',
                    locations: ['BAHAMAS', 'BERMUDA', 'CARIBBEAN', 'CUBA', 'DOMINICAN REPUBLIC', 'GULF OF MEXICO',
                        'HAITI REPUBLIC', 'JAMAICA', 'PUERTO RICO', 'VIRGIN ISLANDS']
                },
                'L': {
                    description: 'South America/Antarctica',
                    locations: ['ANTARTICA', 'ARGENTINE REPUBLIC', 'BOLIVIA', 'BRAZIL', 'CHILE (EX EASTER I)',
                        'COLUMBIA REPUBLIC', 'MEXICO', 'SOUTH AMERICA', 'VENEZUELA REPUBLIC']
                },
                'M': {
                    description: 'Northern Europe/Scandinavia',
                    locations: ['BALTIC SEA', 'FINLAND', 'NORWAY', 'NORWEGIAN SEA', 'SPITSBERGEN', 'SWEDEN']
                },
                'N': {
                    description: 'Western/Central Europe',
                    locations: ['AUSTRIA', 'BELGIUM', 'DENMARK', 'ENGLAND CHANNEL', 'EUROPE', 'FRANCE',
                        'GERMANY', 'ITALY', 'NETHERLANDS KINGDM', 'SPAIN', 'SWITZERLAND CONFED', 'UK GREAT BRITAIN']
                },
                'O': {
                    description: 'Eastern Europe',
                    locations: ['ALBANIA REPUBLIC', 'BULGARIA PEO REPUB', 'CZECHOSLOVAKIA', 'HUNGARIAN REPUBLIC',
                        'POLAND PEO REPUBLI', 'ROUMANIA SOCLT REP']
                },
                'P': {
                    description: 'Africa/Middle East',
                    locations: ['AFRICA', 'ALGERIA', 'EGYPT ARAB REPUBLI', 'ISRAEL (STATE OF)', 'LEBANON',
                        'LIBYA ARAB REPUBL', 'MOROCCO (KINGDOM OF)', 'NIGERIA (REPUBLIC OF)', 'SO AFRICA REPUBLIC',
                        'SYRIAN ARAB REP.']
                }
            };
        }

        // Load official IRAC coordination notes
        loadOfficialIRACNotes() {
            return {
                'US1': 'Coordinate with NTIA',
                'US2': 'Coordinate with FCC',
                'US3': 'Coordinate with affected agencies',
                'US7': 'Coordinate use of this frequency',
                'US8': 'Coordination required for power above threshold',
                'US15': 'Coordinate before use in these areas',
                'US25': 'Coordinate frequency assignment',
                'US27': 'Use requires coordination',
                'US30': 'Coordinate interference cases',
                'US42': 'Coordinate for emergency use only',
                'US60': 'Federal use requires coordination',
                'US74': 'Coordinate all applications',
                'US84': 'Use limited to coordination',
                'C045': 'Subject to coordination with FAA prior to use.',
                'C065': 'Subject to coordination, prior to use, with the Department of the Interior, Bureau of Land Management, National Interagency Fire Center, Boise, Idaho.',
                'C067': 'Subject to coordination with the Area Frequency Coordinator located at Nellis AFB, Nevada, prior to use in the states of Nevada, Utah west of 111°W and Idaho south of 44°N.'
            };
        }

        // Complete the loadOfficialFunctionIdentifiers method
        loadOfficialFunctionIdentifiers() {
            return [
                // Air Operations
                'AIR OPERATIONS', 'FLIGHT OPERATIONS', 'FLIGHT TEST', 'FORWARD AIR CONTROL POST',
                'GCA', 'PILOT-TO-DISPATCHER', 'PILOT-TO-METRO', 'PILOT-TO-PILOT', 'RAMP CONTROL',
                'REFUELING', 'SHIP/AIR OPERATIONS', 'AIR DEFENSE', 'AIR DEFENSE WARNING',
                'AIR DEFENSE / INTERCEPT', 'AIR FORCE ONE', 'AIR FORCE SPECIAL OPERATIONS',
                'AIR ROUTE SURVEILLANCE RADAR', 'AIR TRAFFIC CONTROL', 'AIR/AIR COMMUNICATIONS',
                'AIR/GROUND/AIR COMMUNICATIONS', 'AIRBORNE COMMAND CENTER', 'AIRCRAFT',
                'AIRPORT SURVEILLANCE RADAR', 'APPROACH CONTROL', 'ARMY AVIATION',

                // Training
                'TRAINING', 'INSTRUCTOR/STUDENT TRAINING', 'EXERCISE', 'EXPERIMENTAL',
                'SIMULATOR', 'AERO CLUB', 'EDUCATION',

                // Tactical Operations
                'TACTICAL OPERATIONS', 'GROUND OPERATIONS', 'SEA OPERATIONS', 'SPECIAL OPERATIONS',
                'PSYCHOLOGICAL OPERATIONS', 'FIRE SUPPORT', 'INFANTRY', 'GROUND INTERDICTION',
                'ARTILLERY', 'MISSILE', 'SPECIAL FORCES', 'RANGER UNITS', 'NAVY SPECIAL OPERATIONS',
                'NAVAL GUNFIRE SUPPORT', 'TARGET ACQUISITION', 'TARGET SCORING', 'TARGET',

                // Administrative
                'ADMINISTRATIVE', 'INSTALLATION PA SYSTEM', 'MOTOR POOL', 'PAGING',
                'BROADCAST', 'TRAVELERS INFORMATION SYSTEM', 'UNLICENSED DEVICE',
                'WIRELESS LOCAL AREA NETWORK', 'WIRELESS MIKE', 'BASE OPERATIONS',
                'COMMAND NET', 'TRUNKING', 'HICOM', 'MOMS',

                // Logistics
                'LOGISTICS', 'MAINTENANCE', 'MUNITIONS', 'POL', 'RESUPPLY',
                'INVENTORY/INVENTORY CONTROLS', 'SUPPLY AND LOGISTICS', 'SHIPYARD',
                'TRANSPORTATION', 'TAXI', 'AMPS', 'CSSCS', 'MTS', 'RF TAGS',

                // Communications
                'COMMUNICATIONS', 'SATELLITE COMMUNICATIONS', 'RADIO RELAY', 'MICROWAVE',
                'MILSTAR', 'FLTSATCOM', 'GLOBAL', 'MARS', 'AFSATCOM', 'DSCS', 'LEASAT',
                'SPITFIRE', 'TROJAN SPIRIT', 'MSE', 'TACTS', 'IONOSPHERIC SOUNDER',
                'ISYSCON', 'GCCS', 'MICROWAVE DATA LINK',

                // Intelligence
                'INTELLIGENCE', 'SURVEILLANCE', 'RECONNAISSANCE', 'SURVEILLANCE/RECONNAISSANCE',
                'ACS', 'AHFEWS', 'ARL', 'TRACKWOLF', 'TRAILBLAZER', 'TEAMMATE',

                // Medical
                'MEDICAL', 'SEARCH AND RESCUE',

                // Security/Law Enforcement
                'LAW ENFORCEMENT', 'SECURITY FORCE', 'MILITARY POLICE', 'SHORE PATROL',
                'FIRE', 'HAZMAT', 'CID', 'DIS', 'NCIS', 'OSI', 'SCOPE SHIELD',
                'SPEED MEASUREMENT SYSTEMS', 'SURVEILLANCE SYSTEMS', 'TETHERED AEROSTAT RADAR',
                'WEAPONS STORAGE PROTECTION', 'ALARM SYSTEMS', 'DISASTER PLANNING', 'EOD',
                'ANTI-TERRORISM', 'CIVIL DISTURBANCES', 'COUNTER DRUG', 'PROJECT COTHEN',
                'SPECIAL SECURITY OPERATIONS',

                // Range Operations
                'RANGE OPERATIONS', 'RANGE CONTROL', 'RDTE SUPPORT', 'TEST AND MEASUREMENT',
                'TEST RANGE TIMING', 'TEST RANGE', 'RDMS', 'OCCS SUPPORT',

                // Sustaining Operations
                'SUSTAINING OPERATIONS', 'FLEET SUPPORT', 'PUBLIC WORKS', 'NATURAL RESOURCES',
                'RESOURCES CONSERVATION', 'SAFETY', 'LOCKS AND DAMS', 'HYDROLOGIC',
                'METEOROLOGICAL', 'SEISMIC', 'NAVAIDS', 'NAVIGATION RADAR', 'CIVIL ENGINEERING',
                'CIVIL WORKS', 'CONSTRUCTION', 'INDUSTRIAL CONTROLS', 'PRIME BEEF', 'RED HORSE',
                'SEABEES', 'UTILITIES', 'WILDLIFE PRESERVATION', 'NAVAIDS CONTROLS',
                'REMOTE BARRIER CONTROL SYSTEMS', 'RUNWAY LIGHTING CONTROL',

                // Space Operations
                'SPACE OPERATIONS', 'SATELLITE COMMUNICATIONS', 'GPS', 'SHUTTLE', 'NASA',
                'SGLS', 'ARTS', 'TELEMETRY', 'TELECOMMAND', 'UAV',

                // Emergency Services
                'EMERGENCY SERVICES', 'WARNING SYSTEM', 'CONSEQUENCE MANAGEMENT', 'CBR',
                'CIVIL SUPPORT TEAM', 'ENVIRONMENTAL CLEANUP', 'FEMA', 'HAZARDOUS MATERIAL RELEASE',
                'TECHNICAL ESCORT UNIT', 'MUTUAL AID',

                // Weather/Environmental
                'WEATHER', 'WEATHER RADAR', 'WIND PROFILER', 'AMSS', 'ASOS', 'AWOS', 'GOES',
                'IMETS', 'NEXRAD', 'SAWDS',

                // Command and Control
                'COMMAND AND CONTROL', 'BASE OPERATIONS', 'COMMAND NET', 'MOMS', 'TRUNKING',
                'HICOM', 'A2C2S', 'NAOC', 'MYSTIC STAR', 'WHCA',

                // Data Links
                'DATA LINK', 'JTIDS/MIDS', 'TADIL-A', 'TADIL-C', 'A-EPLRS', 'AFATDS',
                'TACCS', 'NTDR', 'MITT/DTES', 'SCAMP',

                // Special Systems
                'AEGIS', 'PATRIOT', 'MLRS', 'SENTINEL', 'PAVE PAWS', 'OTHR/ROTHR',
                'THUNDERBIRDS', 'STRIKER II', 'AQF', 'TACJAM', 'NORAD',

                // Global Operations
                'GLOBAL', 'WORLDWIDE', 'CONUS', 'NATO', 'OTHER OPERATIONS', 'SPECIAL PROJECTS',
                'HAARP', 'SURVEY', 'DTSS', 'ETRAC'
            ];
        }

        // Load function identifiers from MCEB Pub 7 Annex I
        loadFunctionIdentifiers() {
            return [
                // Air Operations
                'AIR OPERATIONS', 'FLIGHT OPERATIONS', 'FLIGHT TEST', 'FORWARD AIR CONTROL POST',
                'GCA', 'PILOT-TO-DISPATCHER', 'PILOT-TO-METRO', 'PILOT-TO-PILOT', 'RAMP CONTROL',
                'REFUELING', 'SHIP/AIR OPERATIONS',

                // Training
                'TRAINING', 'INSTRUCTOR/STUDENT TRAINING', 'EXERCISE', 'EXPERIMENTAL',

                // Tactical Operations
                'TACTICAL OPERATIONS', 'GROUND OPERATIONS', 'SEA OPERATIONS', 'SPECIAL OPERATIONS',
                'PSYCHOLOGICAL OPERATIONS', 'FIRE SUPPORT', 'INFANTRY', 'GROUND INTERDICTION',

                // Administrative
                'ADMINISTRATIVE', 'INSTALLATION PA SYSTEM', 'MOTOR POOL', 'PAGING',

                // Logistics
                'LOGISTICS', 'MAINTENANCE', 'MUNITIONS', 'POL', 'RESUPPLY', 'INVENTORY/INVENTORY CONTROLS',

                // Communications
                'COMMUNICATIONS', 'SATELLITE COMMUNICATIONS', 'RADIO RELAY', 'MICROWAVE',
                'MILSTAR', 'FLTSATCOM', 'GLOBAL', 'MARS',

                // Intelligence
                'INTELLIGENCE', 'SURVEILLANCE', 'RECONNAISSANCE',

                // Medical
                'MEDICAL', 'SEARCH AND RESCUE',

                // Security/Law Enforcement
                'LAW ENFORCEMENT', 'SECURITY FORCE', 'MILITARY POLICE', 'SHORE PATROL',
                'FIRE', 'HAZMAT', 'LOOTING PREVENTION',

                // Range Operations
                'RANGE OPERATIONS', 'RANGE CONTROL', 'RDTE SUPPORT',

                // Sustaining Operations
                'SUSTAINING OPERATIONS', 'FLEET SUPPORT', 'PUBLIC WORKS', 'NATURAL RESOURCES',
                'RESOURCES CONSERVATION', 'SAFETY', 'LOCKS AND DAMS', 'HYDROLOGIC',
                'METEOROLOGICAL', 'SEISMIC', 'NAVAIDS', 'NAVIGATION RADAR',

                // Space Operations
                'SPACE OPERATIONS', 'SATELLITE COMMUNICATIONS', 'GPS', 'SHUTTLE',

                // Global Operations
                'GLOBAL', 'WORLDWIDE', 'CONUS', 'NATO'
            ];
        }

        loadOfficialEquipmentCodes() {
            return {
                'AAI': 'AAI Corp.',
                'ABB': 'ABB Power T&D Co.',
                'ACS': 'ACS Defense, Inc.',
                'ADC': 'ADC Telecommunications',
                'AEL': 'American Electronic Labs',
                'AIL': 'AIL Systems',
                'AMP': 'AMP Inc.',
                'ANT': 'Antenna Technology Corp.',
                'ARC': 'ARC Electronics',
                'ATI': 'ATI Inc.',
                'BAE': 'BAE Systems',
                'BOE': 'Boeing Co.',
                'CAM': 'Cameron Corp.',
                'CBN': 'Caribbean Communications',
                'COL': 'Collins Radio Co.',
                'EFJ': 'EF Johnson Co.',
                'GEC': 'GEC Marconi',
                'GEN': 'General Dynamics',
                'HAR': 'Harris Corp.',
                'HP': 'Hewlett Packard',
                'IBM': 'IBM Corp.',
                'ITT': 'ITT Corp.',
                'LOC': 'Lockheed Martin',
                'MOT': 'Motorola',
                'NEC': 'NEC Corp.',
                'RAY': 'Raytheon',
                'ROC': 'Rockwell International',
                'TBL': 'Trimble Navigation',
                'TBN': 'Tayburn',
                'TCC': 'Telcom Communications',
                'TCD': 'Techdyn Systems Corp.',
                'TCE': 'Telecommunications Corp.',
                'TCH': 'Techcomm',
                'TCI': 'Tel Com Industries',
                'TCL': 'Trio Communications, Ltd.',
                'TCM': 'TCOM Industries, Inc.',
                'TCN': 'Technos International Corp.',
                'TEK': 'Tektronix',
                'TRW': 'TRW Inc.',
                'WES': 'Westinghouse Electric'
            };
        }

        // Load official time codes from MCEB Pub 7
        loadOfficialTimeCodes() {
            return {
                '1': {
                    description: 'Regular Service',
                    usage: 'Operates continuously, daily, on a regular basis',
                    subCodes: {
                        '1H24': '24 hours per day',
                        '1HX': 'Hours of operation vary',
                        '1HN': 'Nighttime hours only',
                        '1HJ': 'Daylight hours only',
                        '1HT': 'Hours of twilight only'
                    }
                },
                '2': {
                    description: 'Workweek Service',
                    usage: 'Operates continuously during normal working hours and days',
                    subCodes: {
                        '2H24': '24 hours per day, workweek only',
                        '2HX': 'Variable hours, workweek only',
                        '2HN': 'Nighttime hours, workweek only',
                        '2HJ': 'Daylight hours, workweek only',
                        '2HT': 'Twilight hours, workweek only'
                    }
                },
                '3': {
                    description: 'Occasional Service',
                    usage: 'Operates on an irregular, intermittent, or as-needed basis',
                    subCodes: {
                        '3H24': 'Any time during 24-hour period',
                        '3HX': 'Variable hours, occasional use',
                        '3HN': 'Nighttime hours, occasional use',
                        '3HJ': 'Daylight hours, occasional use',
                        '3HT': 'Twilight hours, occasional use'
                    }
                },
                '4': {
                    description: 'Occasional Workweek Service',
                    usage: 'Operates occasionally during normal working hours and days',
                    subCodes: {
                        '4H24': 'Any time during workweek',
                        '4HX': 'Variable hours, occasional workweek',
                        '4HN': 'Nighttime hours, occasional workweek',
                        '4HJ': 'Daylight hours, occasional workweek',
                        '4HT': 'Twilight hours, occasional workweek'
                    }
                }
            };
        }

        parseImportedSFAF(importText) {
            const lines = importText.split('\n');
            const fieldData = {};

            // Define auto-generated fields to skip during import
            const autoGeneratedFields = [
                '103', '107', '117', '118', '373', '473', '402'
            ];

            lines.forEach(line => {
                // Ignore computer-generated content
                if (this.isComputerGenerated(line)) {
                    return;
                }

                // Parse field data
                const fieldMatch = line.match(/^(\d{3})(?:\/\d{2})?\.?\s*(.+)$/);
                if (fieldMatch) {
                    const fieldNum = fieldMatch[1];
                    const fieldValue = fieldMatch[2].trim();

                    // Skip auto-generated fields
                    if (autoGeneratedFields.includes(fieldNum)) {
                        console.log(`⚠️ Skipping auto-generated field ${fieldNum}: ${fieldValue}`);
                        return;
                    }

                    // Store only manually-entered field data
                    if (!fieldData[`field${fieldNum}`]) {
                        fieldData[`field${fieldNum}`] = [];
                    }
                    fieldData[`field${fieldNum}`].push(fieldValue);
                }
            });

            return fieldData;
        }

        // Helper method for identifying computer-generated content
        isComputerGenerated(line) {
            const computerGeneratedPatterns = [
                /^\*{5}.*\*{5}$/,           // Header/footer asterisk lines
                /^MCEB Publication/,        // Publication reference
                /^Generated:/,              // Generation timestamp
                /^System:/,                 // System identifier
                /^[✅📊💾🔄❌]/,          // Emoji status indicators
                /^\s*$/,                    // Empty lines
                /^Loaded official/,         // Status messages
                /^Auto-save enabled/        // System messages
            ];

            return computerGeneratedPatterns.some(pattern => pattern.test(line));
        }

        // Complete the missing validation methods
        validateEmissionDesignator(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // MCEB Pub 7 emission designator format: up to 11 characters
            if (value.length > 11) {
                this.showFieldErrors(field, ['Maximum 11 characters per MCEB Pub 7 field 114']);
                return false;
            }

            // Basic format validation for emission designators
            const validEmissionPattern = /^[0-9]*[A-Z]*[0-9]*[A-Z]*$/;

            if (!validEmissionPattern.test(value)) {
                this.showFieldErrors(field, [
                    'Invalid emission designator format',
                    'Examples: A3E, F3E, 16K0F3E, 2K70J3E per MCEB Pub 7'
                ]);
                return false;
            }

            return true;
        }

        // Complete the missing utility methods
        clearFieldErrors(field) {
            field.style.borderColor = '';

            // Remove existing error messages
            const existingErrors = field.parentNode.querySelectorAll('.field-errors, .field-warning');
            existingErrors.forEach(error => error.remove());
        }

        getBaseFieldId(fieldId) {
            // Remove occurrence suffix (e.g., "field110_1" -> "field110")
            return fieldId.split('_')[0];
        }

        // Complete the export formatting method
        exportCompleteFormattedSFAF() {
            const formData = this.collectFormData();
            const sfafLines = [];

            // MCEB Pub 7 standard header
            sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
            sfafLines.push('MCEB Publication 7, June 30, 2005');
            sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
            sfafLines.push(`System: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push('');

            // Export all fields in proper MCEB order
            const fieldOrder = [
                '005', '010', '013', '019', '102', '701', '702',
                '110', '113', '114', '115', '116', '117', '118',
                '130', '131', '140', '141', '142', '143', '144',
                '200', '201', '202', '204', '205', '206', '207', '208', '209',
                '300', '301', '303', '306',
                '340', '343', '357', '362', '363', '373',
                '400', '401', '403', '407',
                '440', '443', '457', '462', '463', '470', '471', '472', '473',
                '500', '501', '502', '503', '511', '512', '513', '520',
                '716', '801', '803', '804', '903'
            ];

            fieldOrder.forEach(fieldNum => {
                const fieldId = `field${fieldNum}`;
                const data = formData[fieldId];

                if (data) {
                    if (Array.isArray(data)) {
                        data.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNum}. ${value}`);
                            } else {
                                const occurrence = (index + 1).toString().padStart(2, '0');
                                sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                            }
                        });
                    } else {
                        sfafLines.push(`${fieldNum}. ${data}`);
                    }
                }
            });

            sfafLines.push('');
            sfafLines.push('***** END OF SFAF RECORD *****');

            return sfafLines.join('\n');
        }

        // Complete the missing initialization methods
        enableAutoSave(intervalMinutes = 5) {
            setInterval(() => {
                this.saveFormState();
            }, intervalMinutes * 60000);

            // Save on form changes
            document.addEventListener('input', this.debounce(() => {
                this.saveFormState();
            }, 2000));

            console.log(`💾 Auto-save enabled every ${intervalMinutes} minutes`);
        }

        // Add debounce utility for auto-save
        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Complete the populateFormFromData method
        populateFormFromData(formData) {
            Object.keys(formData).forEach(fieldId => {
                const value = formData[fieldId];

                if (Array.isArray(value)) {
                    // Handle dynamic fields
                    value.forEach((val, index) => {
                        const field = document.getElementById(`${fieldId}_${index + 1}`);
                        if (field) {
                            field.value = val;
                        } else if (index > 0) {
                            // Create additional occurrences if needed
                            this.addFieldOccurrence(fieldId, this.fieldSpecs[fieldId]);
                            const newField = document.getElementById(`${fieldId}_${index + 1}`);
                            if (newField) newField.value = val;
                        }
                    });
                } else {
                    // Handle single fields
                    const field = document.getElementById(fieldId);
                    if (field) field.value = value;
                }
            });
        }

        // Complete the missing initialization methods
        initializeValidation() {
            // Add validation event listeners to all form fields
            document.addEventListener('DOMContentLoaded', () => {
                Object.keys(this.fieldSpecs).forEach(fieldId => {
                    this.attachFieldValidation(fieldId);
                });
            });
        }

        initializeDynamicEntries() {
            // Initialize dynamic field management
            Object.keys(this.fieldSpecs).forEach(fieldId => {
                const spec = this.fieldSpecs[fieldId];
                if (spec.dynamic) {
                    this.setupDynamicField(fieldId, spec);
                }
            });
        }

        addFieldCounters() {
            // Add character counters to all text fields
            Object.keys(this.fieldSpecs).forEach(fieldId => {
                const spec = this.fieldSpecs[fieldId];
                if (spec.maxLength) {
                    this.addCharacterCounter(fieldId, spec.maxLength);
                }
            });
        }

        // Setup dynamic field management
        setupDynamicField(baseFieldId, spec) {
            // Create the first instance
            const firstField = document.getElementById(`${baseFieldId}_1`);
            if (firstField) {
                this.addDynamicFieldControls(firstField, baseFieldId, spec);
            }
        }

        // Add dynamic field controls (add/remove buttons)
        addDynamicFieldControls(field, baseFieldId, spec) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'dynamic-controls';
            controlsDiv.style.cssText = `
        margin-top: 5px;
        display: flex;
        gap: 10px;
    `;

            // Add occurrence button
            const addButton = document.createElement('button');
            addButton.type = 'button';
            addButton.textContent = '+ Add Another';
            addButton.className = 'btn btn-sm btn-outline-primary';
            addButton.onclick = () => this.addFieldOccurrence(baseFieldId, spec);

            // Remove occurrence button
            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.textContent = '- Remove';
            removeButton.className = 'btn btn-sm btn-outline-danger';
            removeButton.onclick = () => this.removeFieldOccurrence(baseFieldId);

            controlsDiv.appendChild(addButton);
            controlsDiv.appendChild(removeButton);

            // Add occurrence counter
            const counter = document.createElement('span');
            counter.className = 'occurrence-counter';
            counter.style.cssText = 'font-size: 0.8em; color: #666; margin-left: auto;';
            counter.textContent = `1 of ${spec.maxOccurrences} max`;
            controlsDiv.appendChild(counter);

            field.parentNode.appendChild(controlsDiv);
        }

        // Add field occurrence
        addFieldOccurrence(baseFieldId, spec) {
            const currentCount = this.getFieldOccurrenceCount(baseFieldId);

            if (currentCount >= spec.maxOccurrences) {
                alert(`Maximum ${spec.maxOccurrences} occurrences allowed for ${spec.title}`);
                return;
            }

            const newFieldId = `${baseFieldId}_${currentCount + 1}`;
            const firstField = document.getElementById(`${baseFieldId}_1`);

            if (firstField) {
                const newFieldContainer = this.createFieldOccurrence(newFieldId, spec, currentCount + 1);
                firstField.closest('.form-group').appendChild(newFieldContainer);
                this.updateOccurrenceCounters(baseFieldId, spec);
            }
        }

        // Remove field occurrence
        removeFieldOccurrence(baseFieldId) {
            const currentCount = this.getFieldOccurrenceCount(baseFieldId);

            if (currentCount <= 1) {
                alert('At least one occurrence is required');
                return;
            }

            const lastFieldId = `${baseFieldId}_${currentCount}`;
            const lastField = document.getElementById(lastFieldId);

            if (lastField) {
                lastField.closest('.field-occurrence').remove();
                this.updateOccurrenceCounters(baseFieldId, this.fieldSpecs[baseFieldId]);
            }
        }

        // Get current field occurrence count
        getFieldOccurrenceCount(baseFieldId) {
            let count = 0;
            for (let i = 1; i <= 300; i++) {
                const field = document.getElementById(`${baseFieldId}_${i}`);
                if (field) count++;
                else break;
            }
            return count;
        }

        // Update occurrence counters
        updateOccurrenceCounters(baseFieldId, spec) {
            const count = this.getFieldOccurrenceCount(baseFieldId);
            const counters = document.querySelectorAll(`[id^="${baseFieldId}"] ~ .dynamic-controls .occurrence-counter`);

            counters.forEach(counter => {
                counter.textContent = `${count} of ${spec.maxOccurrences} max`;
            });
        }

        // Create field occurrence for dynamic fields
        createFieldOccurrence(fieldId, spec, occurrenceNumber) {
            const container = document.createElement('div');
            container.className = 'field-occurrence';
            container.style.cssText = `
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background-color: #f9f9f9;
    `;

            const label = document.createElement('label');
            label.textContent = `${spec.title} #${occurrenceNumber}`;
            label.style.cssText = 'font-weight: bold; margin-bottom: 5px; display: block;';

            const input = document.createElement('input');
            input.type = 'text';
            input.id = fieldId;
            input.className = 'form-control';
            input.maxLength = spec.maxLength;
            input.style.cssText = 'width: 100%; margin-bottom: 5px;';

            // Add validation
            this.attachFieldValidation(fieldId);

            container.appendChild(label);
            container.appendChild(input);

            return container;
        }

        // End of SFAFFieldManager class

        // Attach validation to a field
        attachFieldValidation(fieldId) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            const spec = this.fieldSpecs[fieldId];

            field.addEventListener('blur', () => {
                this.validateField(field, spec);
            });

            field.addEventListener('input', () => {
                this.clearFieldErrors(field);
                if (spec.maxLength) {
                    this.updateCharacterCounter(field, spec.maxLength);
                }
            });
        }

        // Add character counter to field
        addCharacterCounter(fieldId, maxLength) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            field.addEventListener('input', () => {
                this.updateCharacterCounter(field, maxLength);
            });
        }

        // Validate individual field
        validateField(field, spec) {
            if (!field || !spec) return true;

            this.clearFieldErrors(field);

            // Check required fields
            if (spec.required && !field.value.trim()) {
                this.showFieldErrors(field, [`${spec.title} is required per MCEB Pub 7`]);
                return false;
            }

            // Check max length
            if (spec.maxLength && field.value.length > spec.maxLength) {
                this.showFieldErrors(field, [`Maximum ${spec.maxLength} characters allowed`]);
                return false;
            }

            // Field-specific validation
            const fieldId = field.id.split('_')[0]; // Get base field ID

            switch (fieldId) {
                case 'field110':
                    return this.validateFrequency(field);
                case 'field114':
                    return this.validateEmissionDesignator(field);
                case 'field115':
                    return this.validateTransmitterPower(field);
                case 'field116':
                    return this.validatePowerType(field);
                case 'field130':
                    return this.validateTimeField(field);
                case 'field131':
                    return this.validatePercentTime(field);
                case 'field140':
                case 'field141':
                case 'field142':
                case 'field143':
                    return this.validateMCEBDateField(field);
                case 'field303':
                case 'field403':
                    return this.validateCoordinates(field);
                default:
                    return true;
            }
        }

        // Superior time field validation per MCEB Pub 7 field 130
        validateTimeField(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // Valid time codes from MCEB Pub 7
            const validTimeCodes = [
                '1', '2', '3', '4',                          // Basic codes
                '1H24', '1HX', '1HN', '1HJ', '1HT',         // Regular service
                '2H24', '2HX', '2HN', '2HJ', '2HT',         // Workweek service
                '3H24', '3HX', '3HN', '3HJ', '3HT',         // Occasional service
                '4H24', '4HX', '4HN', '4HJ', '4HT'          // Occasional workweek
            ];

            if (!validTimeCodes.includes(value)) {
                this.showFieldErrors(field, [
                    'Invalid time code per MCEB Pub 7',
                    'Use: 1-4 or 1H24, 1HX, 1HN, 1HJ, 1HT, etc.'
                ]);
                return false;
            }

            return true;
        }

        // Superior power type validation with MCEB Pub 7 compliance
        validatePowerType(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            const validPowerTypes = ['C', 'M', 'P'];

            if (!validPowerTypes.includes(value)) {
                this.showFieldErrors(field, [
                    'Invalid power type per MCEB Pub 7 field 116',
                    'Use: C (Carrier), M (Mean), P (Peak Envelope)'
                ]);
                return false;
            }

            return true;
        }

        // Enhanced power validation based on MCEB Pub 7 field 115 specifications
        validatePowerFormat(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // MCEB Pub 7 power format with logical range validation
            const powerPattern = /^[WKMG]\d+(\.\d{1,5})?$/;

            if (!powerPattern.test(value)) {
                this.showFieldErrors(field, [
                    'Invalid power format. Use: W0.5, K1.5, M2.0, G1.0 per MCEB Pub 7'
                ]);
                return false;
            }

            // Validate logical ranges
            const unit = value.charAt(0);
            const powerValue = parseFloat(value.substring(1));

            let isValid = true;
            const errors = [];

            switch (unit) {
                case 'W':
                    if (powerValue >= 1000) {
                        errors.push('Power >= 1000W should use K prefix (e.g., K1.0)');
                        isValid = false;
                    }
                    break;
                case 'K':
                    if (powerValue < 1 || powerValue >= 1000) {
                        errors.push('K prefix for 1-999.99999 kW range');
                        isValid = false;
                    }
                    break;
                // Additional cases...
            }

            if (!isValid) {
                this.showFieldErrors(field, errors);
            }

            return isValid;
        }

        // Enhanced date validation for MCEB Pub 7 date fields (140, 141, 142, 143)
        validateMCEBDateField(field) {
            const value = field.value.trim();
            if (!value) return true;

            // MCEB Pub 7 date format: YYYYMMDD
            if (!/^\d{8}$/.test(value)) {
                this.showFieldErrors(field, ['Date format must be YYYYMMDD per MCEB Pub 7']);
                return false;
            }

            const year = parseInt(value.substring(0, 4));
            const month = parseInt(value.substring(4, 6));
            const day = parseInt(value.substring(6, 8));

            // Validate date components per MCEB Pub 7 requirements
            if (year < 1950 || year > 2099) {
                this.showFieldErrors(field, ['Year must be between 1950-2099']);
                return false;
            }

            // Additional date logic validation with leap year support
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);

            if (month === 2 && isLeapYear) {
                daysInMonth[1] = 29;
            }

            if (day > daysInMonth[month - 1]) {
                this.showFieldErrors(field, [`Invalid day for month ${month.toString().padStart(2, '0')}`]);
                return false;
            }

            return true;
        }

        // Enhanced power validation based on MCEB Pub 7 field 115 specifications
        validatePowerFormat(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // MCEB Pub 7 power format with logical range validation
            const powerPattern = /^[WKMG]\d+(\.\d{1,5})?$/;

            if (!powerPattern.test(value)) {
                this.showFieldErrors(field, [
                    'Invalid power format. Use: W0.5, K1.5, M2.0, G1.0 per MCEB Pub 7'
                ]);
                return false;
            }

            // Validate logical ranges between power units
            const unit = value.charAt(0);
            const powerValue = parseFloat(value.substring(1));

            switch (unit) {
                case 'W':
                    if (powerValue >= 1000) {
                        this.showFieldWarning(field, 'Power >= 1000W should use K prefix (e.g., K1.0)');
                    }
                    break;
                case 'K':
                    if (powerValue < 1 || powerValue >= 1000) {
                        this.showFieldErrors(field, ['K prefix for 1-999.99999 kW range']);
                        return false;
                    }
                    break;
                case 'M':
                    if (powerValue < 1 || powerValue >= 1000) {
                        this.showFieldErrors(field, ['M prefix for 1-999.99999 MW range']);
                        return false;
                    }
                    break;
                case 'G':
                    if (powerValue < 1) {
                        this.showFieldErrors(field, ['G prefix for power >= 1 GW']);
                        return false;
                    }
                    break;
            }

            return true;
        }

        // Enhanced coordinate validation for fields 303/403
        validateCoordinates(field) {
            const value = field.value.trim();
            if (!value) return true;

            // MCEB Pub 7 coordinate formats
            // Format 1: DDDMMSS.SN/E (degrees, minutes, seconds)
            // Format 2: DD.DDDDDN/E (decimal degrees)

            const degMinSecPattern = /^(\d{2,3})(\d{2})(\d{2})(\.\d+)?([NSEW])$/;
            const decimalPattern = /^(\d{1,3})\.(\d{5,})([NSEW])$/;

            let isValid = false;
            const coord = value.toUpperCase();

            if (degMinSecPattern.test(coord)) {
                const match = coord.match(degMinSecPattern);
                const degrees = parseInt(match[1]);
                const minutes = parseInt(match[2]);
                const seconds = parseInt(match[3]);
                const hemisphere = match[5];

                // Validate ranges
                const maxDegrees = (hemisphere === 'N' || hemisphere === 'S') ? 90 : 180;

                if (degrees <= maxDegrees && minutes < 60 && seconds < 60) {
                    isValid = true;
                }
            } else if (decimalPattern.test(coord)) {
                const match = coord.match(decimalPattern);
                const degrees = parseFloat(match[1] + '.' + match[2]);
                const hemisphere = match[3];

                const maxDegrees = (hemisphere === 'N' || hemisphere === 'S') ? 90 : 180;

                if (degrees <= maxDegrees) {
                    isValid = true;
                }
            }

            if (!isValid) {
                this.showFieldErrors(field, [
                    'Invalid coordinate format per MCEB Pub 7',
                    'Use: DDDMMSS.SN/E or DD.DDDDDN/E format',
                    'Examples: 0384512.5N, 38.75347N'
                ]);
                return false;
            }

            return true;
        }

        // Add character counter with visual feedback
        addCharacterCounter(fieldId, maxLength) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            // Create counter element
            const counter = document.createElement('div');
            counter.className = 'char-counter';
            counter.style.cssText = `
        font-size: 0.8em;
        color: #666;
        text-align: right;
        margin-top: 2px;
        font-family: monospace;
        transition: color 0.3s ease;
    `;

            field.parentNode.appendChild(counter);

            // Update counter on input
            field.addEventListener('input', () => {
                this.updateCharacterCounter(field, maxLength);
            });

            // Initial update
            this.updateCharacterCounter(field, maxLength);
        }

        // Enhanced field occurrence creation with validation
        createFieldOccurrence(fieldId, spec, occurrenceNumber) {
            const container = document.createElement('div');
            container.className = 'field-occurrence';
            container.setAttribute('data-occurrence', occurrenceNumber);
            container.style.cssText = `
        margin-top: 10px;
        padding: 15px;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        background-color: #f9f9f9;
        position: relative;
    `;

            // Add occurrence label
            const label = document.createElement('label');
            label.textContent = `${spec.title} #${occurrenceNumber}`;
            label.setAttribute('for', fieldId);
            label.style.cssText = `
        font-weight: bold; 
        margin-bottom: 8px; 
        display: block;
        color: #495057;
    `;

            // Create input field with proper attributes
            const input = document.createElement('input');
            input.type = 'text';
            input.id = fieldId;
            input.className = 'form-control';
            input.maxLength = spec.maxLength;
            input.setAttribute('data-field-spec', JSON.stringify(spec));
            input.style.cssText = 'width: 100%; margin-bottom: 5px;';

            // Add validation and character counter
            this.attachFieldValidation(fieldId);
            if (spec.maxLength) {
                this.addCharacterCounter(fieldId, spec.maxLength);
            }

            // Add remove button for occurrences > 1
            if (occurrenceNumber > 1) {
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-sm btn-outline-danger';
                removeBtn.textContent = '×';
                removeBtn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            padding: 0;
            border-radius: 50%;
        `;
                removeBtn.onclick = () => {
                    container.remove();
                    this.updateOccurrenceCounters(this.getBaseFieldId(fieldId), spec);
                };
                container.appendChild(removeBtn);
            }

            container.appendChild(label);
            container.appendChild(input);

            return container;
        }

        // Validate equipment manufacturer codes against official MCEB Pub 7 list
        validateEquipmentManufacturer(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            const validManufacturers = Object.keys(this.equipmentManufacturers);

            if (!validManufacturers.includes(value)) {
                this.showFieldWarning(field,
                    'Manufacturer code not in official MCEB Pub 7 list. Verify code accuracy.'
                );
            }

            return true;
        }

        // Complete frequency validation with band plan checking
        validateFrequency(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // Basic format validation
            const frequencyPattern = /^(\d+(\.\d{1,9})?)(HZ|KHZ|MHZ|GHZ)$/;

            if (!frequencyPattern.test(value)) {
                this.showFieldErrors(field, [
                    'Invalid frequency format per MCEB Pub 7',
                    'Use: 123.456MHZ, 14.25GHZ, etc.'
                ]);
                return false;
            }

            // Convert to Hz for band plan validation
            const match = value.match(frequencyPattern);
            const numValue = parseFloat(match[1]);
            const unit = match[3];

            let frequencyHz;
            switch (unit) {
                case 'HZ': frequencyHz = numValue; break;
                case 'KHZ': frequencyHz = numValue * 1000; break;
                case 'MHZ': frequencyHz = numValue * 1000000; break;
                case 'GHZ': frequencyHz = numValue * 1000000000; break;
            }

            // Validate against spectrum limits
            if (frequencyHz < 3 || frequencyHz > 300000000000) {
                this.showFieldErrors(field, ['Frequency out of valid range (3 Hz - 300 GHz)']);
                return false;
            }

            // Check common DoD frequency bands
            this.validateFrequencyBand(field, frequencyHz);

            return true;
        }

        // Export SFAF data to CSV format for analysis
        exportToCSV() {
            const formData = this.collectFormData();
            const csvRows = [];

            // CSV header
            csvRows.push(['Field ID', 'Field Name', 'Value', 'Occurrence']);

            // Process all fields
            Object.entries(formData).forEach(([fieldId, value]) => {
                const spec = this.fieldSpecs[fieldId];
                const fieldName = spec ? spec.title : fieldId;

                if (Array.isArray(value)) {
                    value.forEach((val, index) => {
                        csvRows.push([fieldId, fieldName, val, index + 1]);
                    });
                } else {
                    csvRows.push([fieldId, fieldName, value, 1]);
                }
            });

            // Convert to CSV string
            const csvContent = csvRows.map(row =>
                row.map(cell => `"${cell}"`).join(',')
            ).join('\n');

            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sfaf_export.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        exportFinalSFAFRecord() {
            const formData = this.collectFormData();
            const sfafLines = [];

            // MCEB Pub 7 standard header
            sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
            sfafLines.push('MCEB Publication 7, June 30, 2005');
            sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);

            // Export in official MCEB field order
            const fieldOrder = [
                '005', '010', '013', '019', '102', '701', '702',
                '110', '113', '114', '115', '116', '117', '118',
                // ... complete field order
            ];

            // Handle multiple occurrences properly
            fieldOrder.forEach(fieldNum => {
                const data = formData[`field${fieldNum}`];
                if (Array.isArray(data)) {
                    data.forEach((value, index) => {
                        if (index === 0) {
                            sfafLines.push(`${fieldNum}. ${value}`);
                        } else {
                            const occurrence = (index + 1).toString().padStart(2, '0');
                            sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                        }
                    });
                }
            });

            return sfafLines.join('\n');
        }

        // Add contextual help for MCEB Pub 7 fields
        addFieldHelp(fieldId, helpText) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            const helpIcon = document.createElement('span');
            helpIcon.innerHTML = '❓';
            helpIcon.style.cssText = `
        margin-left: 5px;
        cursor: help;
        color: #007bff;
        font-size: 0.9em;
    `;

            helpIcon.title = helpText;
            helpIcon.onclick = () => this.showFieldHelpModal(fieldId, helpText);

            field.parentNode.querySelector('label').appendChild(helpIcon);
        }

        // Show detailed field help modal
        showFieldHelpModal(fieldId, helpText) {
            const modal = document.createElement('div');
            modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

            const content = document.createElement('div');
            content.style.cssText = `
        background: white;
        padding: 20px;
        border-radius: 8px;
        max-width: 500px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;

            const spec = this.fieldSpecs[fieldId];
            content.innerHTML = `
        <h3>${spec.title} (${fieldId})</h3>
        <p><strong>MCEB Pub 7 Requirements:</strong></p>
        <p>${helpText}</p>
        <p><strong>Max Length:</strong> ${spec.maxLength} characters</p>
        ${spec.maxOccurrences ? `<p><strong>Max Occurrences:</strong> ${spec.maxOccurrences}</p>` : ''}
        <button onclick="this.closest('[style*=fixed]').remove()" 
                style="margin-top: 15px; padding: 8px 16px; border: none; background: #007bff; color: white; border-radius: 4px; cursor: pointer;">
            Close
        </button>
    `;

            modal.appendChild(content);
            document.body.appendChild(modal);
        }



        // Validate entire form against MCEB Pub 7 standards
        validateEntireForm() {
            const errors = [];
            let isValid = true;

            // Required fields per MCEB Pub 7
            const requiredFields = [
                'field005', 'field010', 'field102', 'field110_1', 'field113_1',
                'field114_1', 'field115_1', 'field200', 'field300', 'field301',
                'field303', 'field400', 'field401', 'field403'
            ];

            // Check required fields
            requiredFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (!field || !field.value.trim()) {
                    errors.push(`Required field missing: ${fieldId} - ${this.getFieldTitle(fieldId)}`);
                    isValid = false;

                    if (field) {
                        field.style.borderColor = '#ff6b6b';
                    }
                }
            });

            // Validate field occurrence limits
            this.validateOccurrenceLimits(errors);

            // Check for classification consistency
            this.validateClassificationConsistency(errors);

            // Display validation results
            this.displayValidationResults(errors, isValid);

            return isValid;
        }

        // Update character counter with visual feedback
        updateCharacterCounter(field, maxLength) {
            let counter = field.parentNode.querySelector('.char-counter');
            if (!counter) {
                counter = document.createElement('div');
                counter.className = 'char-counter';
                counter.style.cssText = `
            font-size: 0.8em;
            color: #666;
            text-align: right;
            margin-top: 2px;
            font-family: monospace;
        `;
                field.parentNode.appendChild(counter);
            }

            const remaining = maxLength - field.value.length;
            counter.textContent = `${field.value.length}/${maxLength}`;

            // Color coding based on remaining characters
            if (remaining < 5) {
                counter.style.color = '#dc3545';  // Red when near limit
            } else if (remaining < 20) {
                counter.style.color = '#ffc107';  // Yellow when approaching limit
            } else {
                counter.style.color = '#666';     // Gray when safe
            }
        }

        // Complete station class validation per MCEB Pub 7
        validateStationClass(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // Valid station classes from MCEB Pub 7
            const validStationClasses = [
                // Fixed Service
                'FB', 'FB2', 'FB3', 'FB8', 'FX1',
                // Mobile Service
                'ML', 'MA', 'MO', 'MP', 'MR', 'MS', 'MT',
                // Broadcasting
                'BC', 'BT',
                // Aeronautical
                'AC', 'AD', 'AF', 'AG', 'AL', 'AR', 'AS', 'AT',
                // Maritime
                'CG', 'CP', 'CS', 'CT',
                // Amateur
                'HA',
                // Experimental
                'XE', 'XF', 'XM', 'XR', 'XT'
            ];

            if (!validStationClasses.includes(value)) {
                this.showFieldWarning(field,
                    'Station class may not be standard. Verify against MCEB Pub 7 Annex B'
                );
            }

            return true;
        }

        // Display validation results with enhanced UI
        displayValidationResults(errors, isValid) {
            // Remove existing validation summary
            const existingSummary = document.querySelector('.validation-summary');
            if (existingSummary) {
                existingSummary.remove();
            }

            // Create enhanced validation summary
            const summary = document.createElement('div');
            summary.className = 'validation-summary';
            summary.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

            if (isValid) {
                summary.style.backgroundColor = '#d4edda';
                summary.style.borderLeft = '4px solid #28a745';
                summary.style.color = '#155724';
                summary.innerHTML = `
            <h4 style="margin: 0 0 10px 0;">✅ SFAF Validation Passed</h4>
            <p style="margin: 0;">Form complies with MCEB Pub 7 standards</p>
        `;
            } else {
                summary.style.backgroundColor = '#f8d7da';
                summary.style.borderLeft = '4px solid #dc3545';
                summary.style.color = '#721c24';

                const errorList = errors.map(error => `<li>${error}</li>`).join('');
                summary.innerHTML = `
            <h4 style="margin: 0 0 10px 0;">❌ SFAF Validation Failed</h4>
            <p style="margin: 0 0 10px 0;">${errors.length} error(s) found:</p>
            <ul style="margin: 0; padding-left: 20px; max-height: 200px; overflow-y: auto;">
                ${errorList}
            </ul>
        `;
            }

            document.body.appendChild(summary);

            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (summary.parentNode) {
                    summary.remove();
                }
            }, 10000);
        }

        // Show field errors
        showFieldErrors(field, errors) {
            field.style.borderColor = '#dc3545';

            const errorDiv = document.createElement('div');
            errorDiv.className = 'field-errors';
            errorDiv.style.cssText = `
        color: #dc3545;
        font-size: 0.8em;
        margin-top: 5px;
        padding: 5px;
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
    `;

            errorDiv.innerHTML = errors.map(error => `• ${error}`).join('<br>');
            field.parentNode.appendChild(errorDiv);
        }

        // Show field warning
        showFieldWarning(field, warning) {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'field-warning';
            warningDiv.style.cssText = `
        color: #856404;
        font-size: 0.8em;
        margin-top: 5px;
        padding: 5px;
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
    `;

            warningDiv.innerHTML = `⚠️ ${warning}`;
            field.parentNode.appendChild(warningDiv);
        }

        // Collect all form data
        collectFormData() {
            const formData = {};

            Object.keys(this.fieldSpecs).forEach(baseFieldId => {
                const spec = this.fieldSpecs[baseFieldId];

                if (spec.dynamic) {
                    // Collect dynamic field data
                    const values = [];
                    for (let i = 1; i <= spec.maxOccurrences; i++) {
                        const field = document.getElementById(`${baseFieldId}_${i}`);
                        if (field && field.value.trim()) {
                            values.push(field.value.trim());
                        }
                    }
                    if (values.length > 0) {
                        formData[baseFieldId] = values;
                    }
                } else {
                    // Collect single field data
                    const field = document.getElementById(baseFieldId);
                    if (field && field.value.trim()) {
                        formData[baseFieldId] = field.value.trim();
                    }
                }
            });

            return formData;
        }

        // Export complete SFAF record
        exportCompleteFormattedSFAF() {
            const formData = this.collectFormData();
            const sfafLines = [];

            // MCEB Pub 7 standard header
            sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
            sfafLines.push('MCEB Publication 7, June 30, 2005');
            sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
            sfafLines.push(`System: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push('');

            // Export all fields in official MCEB Pub 7 field order
            const fieldOrder = [
                '005', '010', '013', '019', '102', '701', '702',
                '110', '113', '114', '115', '116', '117', '118',
                '130', '131', '140', '141', '142', '143', '144',
                '200', '201', '202', '204', '205', '206', '207', '208', '209',
                '300', '301', '303', '306',
                '340', '343', '357', '362', '363', '373',
                '400', '401', '403', '407',
                '440', '443', '457', '462', '463', '470', '471', '472', '473',
                '500', '501', '502', '503', '511', '512', '513', '520',
                '716', '801', '803', '804', '903'
            ];

            fieldOrder.forEach(fieldNum => {
                const fieldId = `field${fieldNum}`;
                const data = formData[fieldId];

                if (data) {
                    if (Array.isArray(data)) {
                        // Handle multiple occurrences for dynamic fields
                        data.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNum}. ${value}`);
                            } else {
                                const occurrence = (index + 1).toString().padStart(2, '0');
                                sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                            }
                        });
                    } else {
                        // Handle single occurrence fields
                        sfafLines.push(`${fieldNum}. ${data}`);
                    }
                }
            });

            // Add MCEB Pub 7 compliant footer
            sfafLines.push('');
            sfafLines.push('***** END OF SFAF RECORD *****');
            sfafLines.push(`Record Format: MCEB Publication 7 Standard`);
            sfafLines.push(`Generated by: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push(`Timestamp: ${new Date().toISOString()}`);

            return sfafLines.join('\n');
        }

        // Export dynamic fields with proper occurrence numbering
        exportDynamicFields(sfafLines, formData, fieldIds) {
            fieldIds.forEach(baseFieldId => {
                const values = formData[baseFieldId];
                if (values) {
                    const fieldNumber = baseFieldId.replace('field', '');
                    if (Array.isArray(values)) {
                        values.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNumber}. ${value}`);
                            } else {
                                sfafLines.push(`${fieldNumber}/${(index + 1).toString().padStart(2, '0')}. ${value}`);
                            }
                        });
                    } else {
                        sfafLines.push(`${fieldNumber}. ${values}`);
                    }
                }
            });
        }

        // Generate compliance report
        generateComplianceReport() {
            const formData = this.collectFormData();
            const report = [];

            report.push('MCEB Publication 7 Compliance Report');
            report.push('====================================');
            report.push(`Generated: ${new Date().toLocaleString()}`);
            report.push('');

            // Check required fields per MCEB Pub 7
            const requiredFields = {
                'field005': 'Security Classification',
                'field010': 'Type of Action',
                'field102': 'Agency Serial Number',
                'field110': 'Frequency(ies)',
                'field113': 'Station Class',
                'field114': 'Emission Designator',
                'field115': 'Transmitter Power',
                'field200': 'Agency',
                'field300': 'State/Country (TX)',
                'field301': 'Antenna Location (TX)',
                'field303': 'Antenna Coordinates (TX)',
                'field400': 'State/Country (RX)',
                'field401': 'Antenna Location (RX)',
                'field403': 'Antenna Coordinates (RX)'
            };

            let missingRequired = 0;
            let presentRequired = 0;

            Object.entries(requiredFields).forEach(([fieldId, title]) => {
                const value = formData[fieldId] || (Array.isArray(formData[fieldId]) ? formData[fieldId][0] : null);
                if (value) {
                    presentRequired++;
                } else {
                    missingRequired++;
                    report.push(`❌ MISSING REQUIRED: ${fieldId} - ${title}`);
                }
            });

            report.push('');
            report.push(`Required Fields Status: ${presentRequired}/${presentRequired + missingRequired} complete`);
            report.push('');

            // Check field occurrence limits
            let exceedsLimits = 0;
            Object.keys(this.fieldSpecs).forEach(baseFieldId => {
                const spec = this.fieldSpecs[baseFieldId];
                if (spec.dynamic) {
                    const values = formData[baseFieldId];
                    if (Array.isArray(values) && values.length > spec.maxOccurrences) {
                        exceedsLimits++;
                        report.push(`⚠️ EXCEEDS LIMIT: ${baseFieldId} has ${values.length} occurrences (max: ${spec.maxOccurrences})`);
                    }
                }
            });

            if (exceedsLimits === 0) {
                report.push('✅ All field occurrence limits compliant with MCEB Pub 7');
            }

            report.push('');
            report.push(`Overall Compliance: ${missingRequired === 0 && exceedsLimits === 0 ? 'COMPLIANT' : 'NON-COMPLIANT'}`);

            return report.join('\n');
        }

        exportFinalSFAFRecord() {
            const formData = this.collectFormData();
            const sfafLines = [];

            // MCEB Pub 7 standard header
            sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
            sfafLines.push('MCEB Publication 7, June 30, 2005');
            sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
            sfafLines.push(`System: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push('');

            // Export logic from source files...
            const fieldOrder = [
                '005', '010', '013', '019', '102', '701', '702',
                '110', '113', '114', '115', '116', '117', '118',
                '130', '131', '140', '141', '142', '143', '144',
                '200', '201', '202', '204', '205', '206', '207', '208', '209',
                '300', '301', '303', '306',
                '340', '343', '357', '362', '363', '373',
                '400', '401', '403', '407',
                '440', '443', '457', '462', '463', '470', '471', '472', '473',
                '500', '501', '502', '503', '511', '512', '513', '520',
                '716', '801', '803', '804', '903'
            ];

            fieldOrder.forEach(fieldNum => {
                const fieldId = `field${fieldNum}`;
                const data = formData[fieldId];

                if (data) {
                    if (Array.isArray(data)) {
                        data.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNum}. ${value}`);
                            } else {
                                const occurrence = (index + 1).toString().padStart(2, '0');
                                sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                            }
                        });
                    } else {
                        sfafLines.push(`${fieldNum}. ${data}`);
                    }
                }
            });

            sfafLines.push('');
            sfafLines.push('***** END OF SFAF RECORD *****');
            return sfafLines.join('\n');
        }

        // Add all other missing methods from source files...
        saveFormState() {
            const formData = this.collectFormData();
            const stateData = {
                formData: formData,
                timestamp: new Date().toISOString(),
                version: 'MCEB_PUB_7_2005'
            };
            localStorage.setItem('sfafFormState', JSON.stringify(stateData));
            console.log('💾 SFAF form state saved');
        }

        restoreFormState() {
            const savedState = localStorage.getItem('sfafFormState');
            if (savedState) {
                try {
                    const stateData = JSON.parse(savedState);
                    this.populateFormFromData(stateData.formData);
                    console.log('🔄 SFAF form state restored from', stateData.timestamp);
                    return true;
                } catch (error) {
                    console.error('❌ Error restoring form state:', error);
                    return false;
                }
            }
            return false;
        }
        // initializeFieldSpecs() { /* from sources */ }
        // loadOfficialGeographicCodes() { /* from sources */ }
        // loadOfficialIRACNotes() { /* from sources */ }
        // loadOfficialFunctionIdentifiers() { /* from sources */ }
        // loadOfficialEquipmentCodes() { /* from sources */ }
        // loadOfficialTimeCodes() { /* from sources */ }
        // saveFormState() { /* from sources */ }
        // restoreFormState() { /* from sources */ }
        // validateEntireForm() { /* from sources */ }
        // exportFinalSFAFRecord() { /* from sources */ }
        // ... etc.
    }
    // Single initialization
    document.addEventListener('DOMContentLoaded', () => {
        try {
            window.sfafFieldManager = new SFAFFieldManager();
            console.log('🎯 SFAF Field Manager fully operational');
        } catch (error) {
            console.error('❌ Error initializing SFAF Field Manager:', error);
        }
    });

    window.SFAFFieldManager = SFAFFieldManager;

})(); // ← CRITICAL: Proper IIFE closure

// 2. THEN: Utility functions (from newfile.txt)
function setFieldValue(formFieldId, value) {
    // Implementation from newfile.txt
}

function downloadSFAF(sfafData, filename = 'sfaf_record.txt') {
    // Implementation from newfile.txt  
}

function showNotification(message, type = 'info') {
    // Implementation from newfile.txt
}

// // NOW the initialization code goes OUTSIDE the class:
// let sfafFieldManager;
// document.addEventListener('DOMContentLoaded', () => {
//     try {
//         sfafFieldManager = new SFAFFieldManager();

//         // Restore any saved form state
//         sfafFieldManager.restoreFormState();

//         console.log('🎯 SFAF Field Manager fully operational');
//         console.log('📖 Based on MCEB Publication 7, June 30, 2005');
//         console.log('✅ All official MCEB Pub 7 standards implemented');

//     } catch (error) {
//         console.error('❌ Error initializing SFAF Field Manager:', error);
//     }
// });

// Additional utility functions can go here
function setFieldValue(formFieldId, value) {
    if (!formFieldId || !value) return false;

    const field = document.getElementById(formFieldId);
    if (field) {
        console.log(`✅ Setting ${formFieldId} = ${value}`);
        field.value = value;
        field.dispatchEvent(new Event('change'));

        // Trigger MCEB Pub 7 validation if field manager is available
        if (window.sfafFieldManager) {
            window.sfafFieldManager.validateField(field);
        }

        return true;
    }
    return false;
}

// Global utility function for downloading SFAF records
function downloadSFAF(sfafData, filename = 'sfaf_record.txt') {
    const blob = new Blob([sfafData], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);

    showNotification('SFAF record downloaded', 'success');
}

// Global notification system
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    const colors = {
        success: { bg: '#d4edda', border: '#c3e6cb', text: '#155724' },
        error: { bg: '#f8d7da', border: '#f5c6cb', text: '#721c24' },
        info: { bg: '#d1ecf1', border: '#bee5eb', text: '#0c5460' }
    };

    const color = colors[type];
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${color.bg};
        color: ${color.text};
        border: 1px solid ${color.border};
        padding: 10px 15px;
        border-radius: 4px;
        z-index: 10000;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => notification.remove(), 3000);
}

// Setup global keyboard shortcuts for SFAF operations
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // Ctrl+S: Save form state
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            sfafFieldManager.saveFormState();
            showNotification('Form state saved', 'success');
        }

        // Ctrl+E: Export SFAF
        if (e.ctrlKey && e.key === 'e') {
            e.preventDefault();
            const sfafData = sfafFieldManager.exportFinalSFAFRecord();
            downloadSFAF(sfafData);
        }

        // Ctrl+V: Validate form
        if (e.ctrlKey && e.key === 'v') {
            e.preventDefault();
            sfafFieldManager.validateEntireForm();
        }
    });
}

// Show initialization errors
function showInitializationError(error) {
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #f8d7da;
        color: #721c24;
        padding: 15px 20px;
        border-radius: 8px;
        border: 1px solid #f5c6cb;
        z-index: 10000;
        font-family: monospace;
    `;
    errorDiv.innerHTML = `
        <strong>❌ SFAF Manager Initialization Failed</strong><br>
        ${error.message}<br>
        <small>Check console for details</small>
    `;
    document.body.appendChild(errorDiv);
}

// Map imported field IDs to SFAF field IDs
function mapImportedFieldId(importedFieldId) {
    const fieldMappings = {
        'security_classification': 'field005',
        'type_of_action': 'field010',
        'agency_serial': 'field102',
        'frequency': 'field110_1',
        'station_class': 'field113_1',
        'emission': 'field114_1',
        'power': 'field115_1',
        'agency': 'field200',
        'tx_state': 'field300',
        'tx_location': 'field301',
        'tx_coordinates': 'field303',
        'rx_state': 'field400',
        'rx_location': 'field401',
        'rx_coordinates': 'field403'
    };

    return fieldMappings[importedFieldId] || null;
}

// Handle field500 variants and dynamic field processing
function processField500Variants(importedFieldId, value) {
    if (importedFieldId.startsWith('500/')) {
        const occurrence = importedFieldId.split('/')[1];
        const targetFieldId = `field500_${parseInt(occurrence)}`;

        if (setFieldValue(targetFieldId, value)) {
            return { success: true };
        } else {
            // Create dynamic occurrence if needed
            sfafFieldManager.addFieldOccurrence('field500', sfafFieldManager.fieldSpecs['field500']);
            return { success: setFieldValue(targetFieldId, value) };
        }
    }
    return { success: false };
}

// Export for module systems (Node.js, etc.)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        SFAFFieldManager,
        setFieldValue,
        downloadSFAF,
        showNotification,
        setupKeyboardShortcuts,
        mapImportedFieldId
    };
}

// AMD/RequireJS support
if (typeof define === 'function' && define.amd) {
    define([], function () {
        return {
            SFAFFieldManager,
            setFieldValue,
            downloadSFAF,
            showNotification
        };
    });
}

// Initialize map integration if available
if (typeof initializeMap === 'function') {
    initializeMap();
    console.log('🗺️ Map integration initialized');
}

// Auto-populate coordinate fields from marker data
function populateCoordinatesFromMap(data) {
    if (data.coordinates) {
        setFieldValue('field303', data.coordinates.compact);
        setFieldValue('field403', data.coordinates.compact);
        console.log('📍 Coordinates populated from map data');
    }
}

(function () {
    'use strict';

    // Prevent multiple initializations
    if (window.sfafFieldManager) {
        this.log('⚠️ SFAF Manager already exists');
        return;
    }

    class SFAFFieldManager {
        constructor() {
            this.fieldSpecs = this.initializeFieldSpecs();
            this.geographicCodes = {};
            this.iracNotes = {};
            this.functionIdentifiers = [];
            this.equipmentManufacturers = {};
            this.timeCodeDefinitions = {};
            this.powerTypes = {};

            // Initialize with MCEB compliance
            this.initializeWithMCEBCompliance();
        }

        // Initialize field specifications
        initializeFieldSpecs() {
            return {
                'field005': { title: 'Security Classification', maxLength: 15, required: true },
                'field010': { title: 'Type of Action', maxLength: 3, required: true },
                'field013': { title: 'Priority Indicator', maxLength: 1 },
                'field019': { title: 'Coordination Required', maxLength: 1 },
                'field102': { title: 'Agency Serial Number', maxLength: 20, required: true },
                'field110': { title: 'Frequency', maxLength: 14, maxOccurrences: 300, required: true },
                'field113': { title: 'Station Class', maxLength: 3, maxOccurrences: 300, required: true },
                'field114': { title: 'Emission Designator', maxLength: 11, maxOccurrences: 300, required: true },
                'field115': { title: 'Transmitter Power', maxLength: 11, maxOccurrences: 300, required: true },
                'field116': { title: 'Power Type', maxLength: 1, maxOccurrences: 300 },
                'field117': { title: 'Antenna Gain', maxLength: 7, maxOccurrences: 300 },
                'field118': { title: 'Antenna Pattern', maxLength: 3, maxOccurrences: 300 },
                'field130': { title: 'Time Code', maxLength: 4 },
                'field131': { title: 'Percent Time', maxLength: 2 },
                'field140': { title: 'Start Date', maxLength: 8 },
                'field141': { title: 'Stop Date', maxLength: 8 },
                'field142': { title: 'Repetitive Start Date', maxLength: 8 },
                'field143': { title: 'Repetitive Stop Date', maxLength: 8 },
                'field144': { title: 'Years of Repetition', maxLength: 2 },
                'field200': { title: 'Agency', maxLength: 4, required: true },
                'field201': { title: 'Station Serial Number', maxLength: 20 },
                'field202': { title: 'Net Identifier', maxLength: 20 },
                'field204': { title: 'Station Call Sign', maxLength: 10 },
                'field205': { title: 'Circuit Identifier', maxLength: 20 },
                'field206': { title: 'Geographic Code', maxLength: 1 },
                'field207': { title: 'Function Identifier', maxLength: 50 },
                'field208': { title: 'Equipment Designation', maxLength: 40, maxOccurrences: 50 },
                'field209': { title: 'Supplementary Details', maxLength: 200, maxOccurrences: 50 },
                'field300': { title: 'State/Country (TX)', maxLength: 2, required: true },
                'field301': { title: 'Antenna Location (TX)', maxLength: 30, required: true },
                'field303': { title: 'Antenna Coordinates (TX)', maxLength: 15, required: true },
                'field306': { title: 'Geographic Area (TX)', maxLength: 1 },
                'field340': { title: 'TX Equipment Class', maxLength: 20, maxOccurrences: 50 },
                'field343': { title: 'TX Equipment Manufacturer', maxLength: 3, maxOccurrences: 50 },
                'field357': { title: 'TX Antenna Height AGL', maxLength: 6 },
                'field362': { title: 'TX Antenna Azimuth', maxLength: 3 },
                'field363': { title: 'TX Antenna Elevation', maxLength: 4 },
                'field373': { title: 'TX Antenna Polarization', maxLength: 1 },
                'field400': { title: 'State/Country (RX)', maxLength: 2, required: true },
                'field401': { title: 'Antenna Location (RX)', maxLength: 30, required: true },
                'field403': { title: 'Antenna Coordinates (RX)', maxLength: 15, required: true },
                'field407': { title: 'Geographic Area (RX)', maxLength: 1 },
                'field440': { title: 'RX Equipment Class', maxLength: 20, maxOccurrences: 50 },
                'field443': { title: 'RX Equipment Manufacturer', maxLength: 3, maxOccurrences: 50 },
                'field457': { title: 'RX Antenna Height AGL', maxLength: 6 },
                'field462': { title: 'RX Antenna Azimuth', maxLength: 3 },
                'field463': { title: 'RX Antenna Elevation', maxLength: 4 },
                'field470': { title: 'RX Antenna Beamwidth H', maxLength: 3 },
                'field471': { title: 'RX Antenna Beamwidth V', maxLength: 3 },
                'field472': { title: 'RX Antenna Front-to-Back', maxLength: 3 },
                'field473': { title: 'RX Antenna Polarization', maxLength: 1 },
                'field500': { title: 'IRAC Coordination Notes', maxLength: 3, maxOccurrences: 100 },
                'field501': { title: 'Coordination Comments', maxLength: 200, maxOccurrences: 100 },
                'field502': { title: 'Justification', maxLength: 200 },
                'field503': { title: 'Additional Information', maxLength: 200 },
                'field511': { title: 'Link Budget', maxLength: 200 },
                'field512': { title: 'Bandwidth Justification', maxLength: 200 },
                'field513': { title: 'RF Exposure Analysis', maxLength: 200 },
                'field520': { title: 'Technical Contact', maxLength: 50 },
                'field701': { title: 'Host Nation Frequency', maxLength: 14 },
                'field702': { title: 'NTIA Identifier', maxLength: 9 },
                'field716': { title: 'Previous Assignment ID', maxLength: 20 },
                'field801': { title: 'ITU Region', maxLength: 1 },
                'field803': { title: 'ITU Notification Number', maxLength: 20 },
                'field804': { title: 'ITU Notification Date', maxLength: 8 },
                'field903': { title: 'Coordination Status', maxLength: 20 }
            };
        }

        // Initialize with MCEB Pub 7 compliance
        initializeWithMCEBCompliance() {
            console.log('✅ SFAF Field Manager initialized with MCEB Pub 7 compliance');

            // Load all official MCEB Pub 7 reference data
            this.geographicCodes = this.loadOfficialGeographicCodes();
            this.iracNotes = this.loadOfficialIRACNotes();
            this.functionIdentifiers = this.loadOfficialFunctionIdentifiers();
            this.equipmentManufacturers = this.loadOfficialEquipmentCodes();
            this.timeCodeDefinitions = this.loadOfficialTimeCodes();
            this.powerTypes = this.loadOfficialPowerTypes();

            // Initialize validation and dynamic entry management
            this.initializeValidation();
            this.initializeDynamicEntries();
            this.addFieldCounters();
            this.enableAutoSave();
            this.initializeExistingButtons();

            this.log('📊 Loaded official MCEB Pub 7 reference data:');
            this.log(`  - Geographic codes: ${Object.keys(this.geographicCodes).length} regions`);
            this.log(`  - IRAC coordination notes: ${Object.keys(this.iracNotes).length} notes`);
            this.log(`  - Function identifiers: ${this.functionIdentifiers.length} functions`);
            this.log(`  - Equipment manufacturer codes: ${Object.keys(this.equipmentManufacturers).length} codes`)

            // ADD DEBUG CALLS:
            setTimeout(() => {
                this.debugDOMStructure();
                this.testDynamicFieldMethods();
                this.debugButtonEvents();
            }, 1000);;
        }

        // ADD this debug method to SFAFFieldManager class:
        debugDOMStructure() {
            console.log('🔍 DOM STRUCTURE DEBUG:');

            // Check for frequency fields
            const freqFields = document.querySelectorAll('[id*="110"], [id*="frequency"], [name*="frequency"]');
            console.log('Frequency fields found:', freqFields.length, Array.from(freqFields).map(f => f.id));

            // Check for add buttons
            const addButtons = document.querySelectorAll('[id*="add"], [class*="add"], button:contains("Add")');
            console.log('Add buttons found:', addButtons.length, Array.from(addButtons).map(b => ({ id: b.id, class: b.className, text: b.textContent })));

            // Check for Object Sidebar tab content
            const objectTab = document.querySelector('[data-tab="object"], .object-tab, #object-tab');
            console.log('Object tab found:', !!objectTab, objectTab?.innerHTML?.substring(0, 200));

            // Check for form groups
            const formGroups = document.querySelectorAll('.form-group, .field-group, .input-group');
            console.log('Form groups found:', formGroups.length);

            return {
                freqFields: freqFields.length,
                addButtons: addButtons.length,
                objectTab: !!objectTab,
                formGroups: formGroups.length
            };
        }

        // ADD this method to debug button events:
        debugButtonEvents() {
            console.log('🔍 BUTTON EVENT DEBUG:');

            // Find the specific add frequency button
            const addFreqBtn = document.getElementById('addFrequencyEntry');
            console.log('Add frequency button found:', !!addFreqBtn);

            if (addFreqBtn) {
                console.log('Button details:', {
                    id: addFreqBtn.id,
                    className: addFreqBtn.className,
                    onclick: !!addFreqBtn.onclick,
                    listeners: getEventListeners ? getEventListeners(addFreqBtn) : 'Use dev tools'
                });

                // Add temporary test handler
                addFreqBtn.addEventListener('click', (e) => {
                    console.log('🔥 BUTTON CLICKED!', e);
                    e.preventDefault();

                    // Test direct method call
                    try {
                        this.addFieldOccurrence('field110', this.fieldSpecs['field110']);
                        console.log('✅ Direct method call succeeded');
                    } catch (error) {
                        console.error('❌ Direct method call failed:', error);
                    }
                });
            }

            // Check all buttons in Object tab
            const allButtons = document.querySelectorAll('button');
            console.log('All buttons found:', allButtons.length);
            allButtons.forEach((btn, i) => {
                if (btn.textContent.includes('Add') || btn.id.includes('add')) {
                    console.log(`Button ${i}:`, {
                        id: btn.id,
                        text: btn.textContent.trim(),
                        hasClickHandler: !!btn.onclick
                    });
                }
            });
        }

        // ADD this to SFAFFieldManager class:
        testDynamicFieldMethods() {
            console.log('🧪 TESTING DYNAMIC FIELD METHODS:');

            // Test 1: Check field specs
            const field110Spec = this.fieldSpecs['field110'];
            console.log('Field110 spec:', field110Spec);

            // Test 2: Try to find first field
            const firstField = document.getElementById('field110_1');
            console.log('First field found:', !!firstField, firstField?.outerHTML);

            // Test 3: Test method existence
            const methods = ['setupDynamicField', 'addFieldOccurrence', 'createFieldOccurrence'];
            methods.forEach(method => {
                console.log(`Method ${method}:`, typeof this[method]);
            });

            // Test 4: Try manual field creation
            try {
                if (field110Spec) {
                    console.log('Attempting manual field creation...');
                    const newField = this.createFieldOccurrence('field110_test', field110Spec, 2);
                    console.log('Field created successfully:', !!newField);
                }
            } catch (error) {
                console.error('Field creation failed:', error);
            }

            return {
                hasSpec: !!field110Spec,
                hasFirstField: !!firstField,
                methodsExist: methods.every(m => typeof this[m] === 'function')
            };
        }

        // ADD this method to debug button events:
        debugButtonEvents() {
            console.log('🔍 BUTTON EVENT DEBUG:');

            // Find the specific add frequency button
            const addFreqBtn = document.getElementById('addFrequencyEntry');
            console.log('Add frequency button found:', !!addFreqBtn);

            if (addFreqBtn) {
                console.log('Button details:', {
                    id: addFreqBtn.id,
                    className: addFreqBtn.className,
                    onclick: !!addFreqBtn.onclick,
                    listeners: getEventListeners ? getEventListeners(addFreqBtn) : 'Use dev tools'
                });

                // Add temporary test handler
                addFreqBtn.addEventListener('click', (e) => {
                    console.log('🔥 BUTTON CLICKED!', e);
                    e.preventDefault();

                    // Test direct method call
                    try {
                        this.addFieldOccurrence('field110', this.fieldSpecs['field110']);
                        console.log('✅ Direct method call succeeded');
                    } catch (error) {
                        console.error('❌ Direct method call failed:', error);
                    }
                });
            }

            // Check all buttons in Object tab
            const allButtons = document.querySelectorAll('button');
            console.log('All buttons found:', allButtons.length);
            allButtons.forEach((btn, i) => {
                if (btn.textContent.includes('Add') || btn.id.includes('add')) {
                    console.log(`Button ${i}:`, {
                        id: btn.id,
                        text: btn.textContent.trim(),
                        hasClickHandler: !!btn.onclick
                    });
                }
            });
        }

        // Load official power type codes from MCEB Pub 7 field 116
        loadOfficial
            };
        }


            };
        }

        // Load official IRAC coordination notes
        loadOfficial

        


        // Helper method for identifying computer-generated content
        isComputerGenerated(line) {
            const computerGeneratedPatterns = [
                /^\*{5}.*\*{5}$/,           // Header/footer asterisk lines
                /^MCEB Publication/,        // Publication reference
                /^Generated:/,              // Generation timestamp
                /^System:/,                 // System identifier
                /^[✅📊💾🔄❌]/,          // Emoji status indicators
                /^\s*$/,                    // Empty lines
                /^Loaded official/,         // Status messages
                /^Auto-save enabled/        // System messages
            ];

            return computerGeneratedPatterns.some(pattern => pattern.test(line));
        }

        // Complete the missing validation methods
        validateEmissionDesignator(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // MCEB Pub 7 emission designator format: up to 11 characters
            if (value.length > 11) {
                this.showFieldErrors(field, ['Maximum 11 characters per MCEB Pub 7 field 114']);
                return false;
            }

            // Basic format validation for emission designators
            const validEmissionPattern = /^[0-9]*[A-Z]*[0-9]*[A-Z]*$/;

            if (!validEmissionPattern.test(value)) {
                this.showFieldErrors(field, [
                    'Invalid emission designator format',
                    'Examples: A3E, F3E, 16K0F3E, 2K70J3E per MCEB Pub 7'
                ]);
                return false;
            }

            return true;
        }

        // Complete the missing utility methods
        clearFieldErrors(field) {
            field.style.borderColor = '';

            // Remove existing error messages
            const existingErrors = field.parentNode.querySelectorAll('.field-errors, .field-warning');
            existingErrors.forEach(error => error.remove());
        }

        getBaseFieldId(fieldId) {
            // Remove occurrence suffix (e.g., "field110_1" -> "field110")
            return fieldId.split('_')[0];
        }

        // Complete the export formatting method


        // Complete the missing initialization methods
        

        // Add debounce utility for auto-save
        

        // Complete the populateFormFromData method


        // Complete the missing initialization methods
        initializeValidation() {
            // Add validation event listeners to all form fields
            document.addEventListener('DOMContentLoaded', () => {
                Object.keys(this.fieldSpecs).forEach(fieldId => {
                    this.attachFieldValidation(fieldId);
                });
            });
        }

        initializeDynamicEntries() {
            // Initialize dynamic field management
            Object.keys(this.fieldSpecs).forEach(fieldId => {
                const spec = this.fieldSpecs[fieldId];
                if (spec.dynamic) {
                    this.setupDynamicField(fieldId, spec);
                }
            });
        }

        addFieldCounters() {
            // Add character counters to all text fields
            Object.keys(this.fieldSpecs).forEach(fieldId => {
                const spec = this.fieldSpecs[fieldId];
                if (spec.maxLength) {
                    this.addCharacterCounter(fieldId, spec.maxLength);
                }
            });
        }

        // Setup dynamic field management
        setupDynamicField(baseFieldId, spec) {
            // Create the first instance
            const firstField = document.getElementById(`${baseFieldId}_1`);
            if (firstField) {
                this.addDynamicFieldControls(firstField, baseFieldId, spec);
            }
        }

        // Add dynamic field controls (add/remove buttons)
        addDynamicFieldControls(field, baseFieldId, spec) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'dynamic-controls';
            controlsDiv.style.cssText = `
        margin-top: 5px;
        display: flex;
        gap: 10px;
    `;

            // Add occurrence button
            const addButton = document.createElement('button');
            addButton.type = 'button';
            addButton.textContent = '+ Add Another';
            addButton.className = 'btn btn-sm btn-outline-primary';
            addButton.onclick = () => this.addFieldOccurrence(baseFieldId, spec);

            // Remove occurrence button
            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.textContent = '- Remove';
            removeButton.className = 'btn btn-sm btn-outline-danger';
            removeButton.onclick = () => this.removeFieldOccurrence(baseFieldId);

            controlsDiv.appendChild(addButton);
            controlsDiv.appendChild(removeButton);

            // Add occurrence counter
            const counter = document.createElement('span');
            counter.className = 'occurrence-counter';
            counter.style.cssText = 'font-size: 0.8em; color: #666; margin-left: auto;';
            counter.textContent = `1 of ${spec.maxOccurrences} max`;
            controlsDiv.appendChild(counter);

            field.parentNode.appendChild(controlsDiv);
        }

        // Add field occurrence
        // DEBUGGING VERSION - Add this to see what's happening:
        addFieldOccurrence(baseFieldId, spec) {
            const currentCount = this.getFieldOccurrenceCount(baseFieldId);

            if (currentCount >= spec.maxOccurrences) {
                alert(`Maximum ${spec.maxOccurrences} occurrences allowed for ${spec.title}`);
                return;
            }

            const newFieldId = `${baseFieldId}_${currentCount + 1}`;
            const firstField = document.getElementById(`${baseFieldId}_1`);

            if (firstField) {
                const newFieldContainer = this.createFieldOccurrence(newFieldId, spec, currentCount + 1);

                // SAFE PARENT SELECTION WITH FALLBACKS:
                const parentContainer = firstField.closest('.form-group') ||
                    firstField.closest('div') ||
                    firstField.parentElement ||
                    document.body;

                parentContainer.appendChild(newFieldContainer);
                this.updateOccurrenceCounters(baseFieldId, spec);
            }
        }

        if(firstField) {
            const newFieldContainer = this.createFieldOccurrence(newFieldId, spec, currentCount + 1)
            console.log('🔍 firstField found:', firstField);
            console.log('🔍 firstField.parentElement:', firstField.parentElement);
            console.log('🔍 firstField.closest(\'.form-group\'):', firstField.closest('.form-group'));
            console.log('🔍 firstField HTML structure:', firstField.outerHTML);

            // Try multiple parent selection strategies
            let parentContainer = firstField.closest('.form-group');

            if (!parentContainer) {
                this.log('⚠️ No .form-group found, trying alternatives...');
                parentContainer = firstField.closest('div') || firstField.parentElement;
            }

            if (parentContainer) {
                parentContainer.appendChild(newFieldContainer);
                this.updateOccurrenceCounters(baseFieldId, spec);
                this.log('✅ Field added successfully');
            } else {
                this.error(`❌ No suitable parent container found for ${baseFieldId}`);
            }
        }

        // Remove field occurrence
        removeFieldOccurrence(baseFieldId) {
            const currentCount = this.getFieldOccurrenceCount(baseFieldId);

            if (currentCount <= 1) {
                alert('At least one occurrence is required');
                return;
            }

            const lastFieldId = `${baseFieldId}_${currentCount}`;
            const lastField = document.getElementById(lastFieldId);

            if (lastField) {
                lastField.closest('.field-occurrence').remove();
                this.updateOccurrenceCounters(baseFieldId, this.fieldSpecs[baseFieldId]);
            }
        }

        // Get current field occurrence count
        getFieldOccurrenceCount(baseFieldId) {
            let count = 0;
            for (let i = 1; i <= 300; i++) {
                const field = document.getElementById(`${baseFieldId}_${i}`);
                if (field) count++;
                else break;
            }
            return count;
        }

        // Update occurrence counters
        updateOccurrenceCounters(baseFieldId, spec) {
            const count = this.getFieldOccurrenceCount(baseFieldId);
            const counters = document.querySelectorAll(`[id^="${baseFieldId}"] ~ .dynamic-controls .occurrence-counter`);

            counters.forEach(counter => {
                counter.textContent = `${count} of ${spec.maxOccurrences} max`;
            });
        }

        // Create field occurrence for dynamic fields
        createFieldOccurrence(fieldId, spec, occurrenceNumber) {
            const container = document.createElement('div');
            container.className = 'field-occurrence';
            container.style.cssText = `
        margin-top: 10px;
        padding: 10px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background-color: #f9f9f9;
    `;

            const label = document.createElement('label');
            label.textContent = `${spec.title} #${occurrenceNumber}`;
            label.style.cssText = 'font-weight: bold; margin-bottom: 5px; display: block;';

            const input = document.createElement('input');
            input.type = 'text';
            input.id = fieldId;
            input.className = 'form-control';
            input.maxLength = spec.maxLength;
            input.style.cssText = 'width: 100%; margin-bottom: 5px;';

            // Add validation
            this.attachFieldValidation(fieldId);

            container.appendChild(label);
            container.appendChild(input);

            return container;
        }

        // End of SFAFFieldManager class



        // Add character counter to field
        addCharacterCounter(fieldId, maxLength) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            field.addEventListener('input', () => {
                this.updateCharacterCounter(field, maxLength);
            });
        }



        // Add character counter with visual feedback
        addCharacterCounter(fieldId, maxLength) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            // Create counter element
            const counter = document.createElement('div');
            counter.className = 'char-counter';
            counter.style.cssText = `
        font-size: 0.8em;
        color: #666;
        text-align: right;
        margin-top: 2px;
        font-family: monospace;
        transition: color 0.3s ease;
    `;

            field.parentNode.appendChild(counter);

            // Update counter on input
            field.addEventListener('input', () => {
                this.updateCharacterCounter(field, maxLength);
            });

            // Initial update
            this.updateCharacterCounter(field, maxLength);
        }

        // Enhanced field occurrence creation with validation
        createFieldOccurrence(fieldId, spec, occurrenceNumber) {
            const container = document.createElement('div');
            container.className = 'field-occurrence';
            container.setAttribute('data-occurrence', occurrenceNumber);
            container.style.cssText = `
        margin-top: 10px;
        padding: 15px;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        background-color: #f9f9f9;
        position: relative;
    `;

            // Add occurrence label
            const label = document.createElement('label');
            label.textContent = `${spec.title} #${occurrenceNumber}`;
            label.setAttribute('for', fieldId);
            label.style.cssText = `
        font-weight: bold; 
        margin-bottom: 8px; 
        display: block;
        color: #495057;
    `;

            // Create input field with proper attributes
            const input = document.createElement('input');
            input.type = 'text';
            input.id = fieldId;
            input.className = 'form-control';
            input.maxLength = spec.maxLength;
            input.setAttribute('data-field-spec', JSON.stringify(spec));
            input.style.cssText = 'width: 100%; margin-bottom: 5px;';

            // Add validation and character counter
            this.attachFieldValidation(fieldId);
            if (spec.maxLength) {
                this.addCharacterCounter(fieldId, spec.maxLength);
            }

            // Add remove button for occurrences > 1
            if (occurrenceNumber > 1) {
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-sm btn-outline-danger';
                removeBtn.textContent = '×';
                removeBtn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            padding: 0;
            border-radius: 50%;
        `;
                removeBtn.onclick = () => {
                    container.remove();
                    this.updateOccurrenceCounters(this.getBaseFieldId(fieldId), spec);
                };
                container.appendChild(removeBtn);
            }

            container.appendChild(label);
            container.appendChild(input);

            return container;
        }

        // Validate equipment manufacturer codes against official MCEB Pub 7 list
        validateEquipmentManufacturer(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            const validManufacturers = Object.keys(this.equipmentManufacturers);

            if (!validManufacturers.includes(value)) {
                this.showFieldWarning(field,
                    'Manufacturer code not in official MCEB Pub 7 list. Verify code accuracy.'
                );
            }

            return true;
        }

        // Complete frequency validation with band plan checking
        validateFrequency(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // Basic format validation
            const frequencyPattern = /^(\d+(\.\d{1,9})?)(HZ|KHZ|MHZ|GHZ)$/;

            if (!frequencyPattern.test(value)) {
                this.showFieldErrors(field, [
                    'Invalid frequency format per MCEB Pub 7',
                    'Use: 123.456MHZ, 14.25GHZ, etc.'
                ]);
                return false;
            }

            // Convert to Hz for band plan validation
            const match = value.match(frequencyPattern);
            const numValue = parseFloat(match[1]);
            const unit = match[3];

            let frequencyHz;
            switch (unit) {
                case 'HZ': frequencyHz = numValue; break;
                case 'KHZ': frequencyHz = numValue * 1000; break;
                case 'MHZ': frequencyHz = numValue * 1000000; break;
                case 'GHZ': frequencyHz = numValue * 1000000000; break;
            }

            // Validate against spectrum limits
            if (frequencyHz < 3 || frequencyHz > 300000000000) {
                this.showFieldErrors(field, ['Frequency out of valid range (3 Hz - 300 GHz)']);
                return false;
            }

            // Check common DoD frequency bands
            this.validateFrequencyBand(field, frequencyHz);

            return true;
        }

        // Export SFAF data to CSV format for analysis
        exportToCSV() {
            const formData = this.collectFormData();
            const csvRows = [];

            // CSV header
            csvRows.push(['Field ID', 'Field Name', 'Value', 'Occurrence']);

            // Process all fields
            Object.entries(formData).forEach(([fieldId, value]) => {
                const spec = this.fieldSpecs[fieldId];
                const fieldName = spec ? spec.title : fieldId;

                if (Array.isArray(value)) {
                    value.forEach((val, index) => {
                        csvRows.push([fieldId, fieldName, val, index + 1]);
                    });
                } else {
                    csvRows.push([fieldId, fieldName, value, 1]);
                }
            });

            // Convert to CSV string
            const csvContent = csvRows.map(row =>
                row.map(cell => `"${cell}"`).join(',')
            ).join('\n');

            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sfaf_export.csv';
            a.click();
            URL.revokeObjectURL(url);
        }



        // Add contextual help for MCEB Pub 7 fields
        addFieldHelp(fieldId, helpText) {
            const field = document.getElementById(fieldId);
            if (!field) return;

            const helpIcon = document.createElement('span');
            helpIcon.innerHTML = '❓';
            helpIcon.style.cssText = `
        margin-left: 5px;
        cursor: help;
        color: #007bff;
        font-size: 0.9em;
    `;

            helpIcon.title = helpText;
            helpIcon.onclick = () => this.showFieldHelpModal(fieldId, helpText);

            field.parentNode.querySelector('label').appendChild(helpIcon);
        }

        // Show detailed field help modal
        showFieldHelpModal(fieldId, helpText) {
            const modal = document.createElement('div');
            modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

            const content = document.createElement('div');
            content.style.cssText = `
        background: white;
        padding: 20px;
        border-radius: 8px;
        max-width: 500px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;

            const spec = this.fieldSpecs[fieldId];
            content.innerHTML = `
        <h3>${spec.title} (${fieldId})</h3>
        <p><strong>MCEB Pub 7 Requirements:</strong></p>
        <p>${helpText}</p>
        <p><strong>Max Length:</strong> ${spec.maxLength} characters</p>
        ${spec.maxOccurrences ? `<p><strong>Max Occurrences:</strong> ${spec.maxOccurrences}</p>` : ''}
        <button onclick="this.closest('[style*=fixed]').remove()" 
                style="margin-top: 15px; padding: 8px 16px; border: none; background: #007bff; color: white; border-radius: 4px; cursor: pointer;">
            Close
        </button>
    `;

            modal.appendChild(content);
            document.body.appendChild(modal);
        }



        // Validate entire form against MCEB Pub 7 standards
        validateEntireForm() {
            const errors = [];
            let isValid = true;

            // Required fields per MCEB Pub 7
            const requiredFields = [
                'field005', 'field010', 'field102', 'field110_1', 'field113_1',
                'field114_1', 'field115_1', 'field200', 'field300', 'field301',
                'field303', 'field400', 'field401', 'field403'
            ];

            // Check required fields
            requiredFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (!field || !field.value.trim()) {
                    errors.push(`Required field missing: ${fieldId} - ${this.getFieldTitle(fieldId)}`);
                    isValid = false;

                    if (field) {
                        field.style.borderColor = '#ff6b6b';
                    }
                }
            });

            // Validate field occurrence limits
            this.validateOccurrenceLimits(errors);

            // Check for classification consistency
            this.validateClassificationConsistency(errors);

            // Display validation results
            this.displayValidationResults(errors, isValid);

            return isValid;
        }

        // Update character counter with visual feedback
        

        // Complete station class validation per MCEB Pub 7
        validateStationClass(field) {
            const value = field.value.trim().toUpperCase();
            if (!value) return true;

            // Valid station classes from MCEB Pub 7
            const validStationClasses = [
                // Fixed Service
                'FB', 'FB2', 'FB3', 'FB8', 'FX1',
                // Mobile Service
                'ML', 'MA', 'MO', 'MP', 'MR', 'MS', 'MT',
                // Broadcasting
                'BC', 'BT',
                // Aeronautical
                'AC', 'AD', 'AF', 'AG', 'AL', 'AR', 'AS', 'AT',
                // Maritime
                'CG', 'CP', 'CS', 'CT',
                // Amateur
                'HA',
                // Experimental
                'XE', 'XF', 'XM', 'XR', 'XT'
            ];

            if (!validStationClasses.includes(value)) {
                this.showFieldWarning(field,
                    'Station class may not be standard. Verify against MCEB Pub 7 Annex B'
                );
            }

            return true;
        }

        // Display validation results with enhanced UI
        displayValidationResults(errors, isValid) {
            // Remove existing validation summary
            const existingSummary = document.querySelector('.validation-summary');
            if (existingSummary) {
                existingSummary.remove();
            }

            // Create enhanced validation summary
            const summary = document.createElement('div');
            summary.className = 'validation-summary';
            summary.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 400px;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

            if (isValid) {
                summary.style.backgroundColor = '#d4edda';
                summary.style.borderLeft = '4px solid #28a745';
                summary.style.color = '#155724';
                summary.innerHTML = `
            <h4 style="margin: 0 0 10px 0;">✅ SFAF Validation Passed</h4>
            <p style="margin: 0;">Form complies with MCEB Pub 7 standards</p>
        `;
            } else {
                summary.style.backgroundColor = '#f8d7da';
                summary.style.borderLeft = '4px solid #dc3545';
                summary.style.color = '#721c24';

                const errorList = errors.map(error => `<li>${error}</li>`).join('');
                summary.innerHTML = `
            <h4 style="margin: 0 0 10px 0;">❌ SFAF Validation Failed</h4>
            <p style="margin: 0 0 10px 0;">${errors.length} error(s) found:</p>
            <ul style="margin: 0; padding-left: 20px; max-height: 200px; overflow-y: auto;">
                ${errorList}
            </ul>
        `;
            }

            document.body.appendChild(summary);

            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (summary.parentNode) {
                    summary.remove();
                }
            }, 10000);
        }

        // Show field errors
        showFieldErrors(field, errors) {
            field.style.borderColor = '#dc3545';

            const errorDiv = document.createElement('div');
            errorDiv.className = 'field-errors';
            errorDiv.style.cssText = `
        color: #dc3545;
        font-size: 0.8em;
        margin-top: 5px;
        padding: 5px;
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
    `;

            errorDiv.innerHTML = errors.map(error => `• ${error}`).join('<br>');
            field.parentNode.appendChild(errorDiv);
        }

        // Show field warning
        showFieldWarning(field, warning) {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'field-warning';
            warningDiv.style.cssText = `
        color: #856404;
        font-size: 0.8em;
        margin-top: 5px;
        padding: 5px;
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
    `;

            warningDiv.innerHTML = `⚠️ ${warning}`;
            field.parentNode.appendChild(warningDiv);
        }

        // Collect all form data


        // Export complete SFAF record
        exportCompleteFormattedSFAF() {
            const formData = this.collectFormData();
            const sfafLines = [];

            // MCEB Pub 7 standard header
            sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
            sfafLines.push('MCEB Publication 7, June 30, 2005');
            sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
            sfafLines.push(`System: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push('');

            // Export all fields in official MCEB Pub 7 field order
            const fieldOrder = [
                '005', '010', '013', '019', '102', '701', '702',
                '110', '113', '114', '115', '116', '117', '118',
                '130', '131', '140', '141', '142', '143', '144',
                '200', '201', '202', '204', '205', '206', '207', '208', '209',
                '300', '301', '303', '306',
                '340', '343', '357', '362', '363', '373',
                '400', '401', '403', '407',
                '440', '443', '457', '462', '463', '470', '471', '472', '473',
                '500', '501', '502', '503', '511', '512', '513', '520',
                '716', '801', '803', '804', '903'
            ];

            fieldOrder.forEach(fieldNum => {
                const fieldId = `field${fieldNum}`;
                const data = formData[fieldId];

                if (data) {
                    if (Array.isArray(data)) {
                        // Handle multiple occurrences for dynamic fields
                        data.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNum}. ${value}`);
                            } else {
                                const occurrence = (index + 1).toString().padStart(2, '0');
                                sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                            }
                        });
                    } else {
                        // Handle single occurrence fields
                        sfafLines.push(`${fieldNum}. ${data}`);
                    }
                }
            });

            // Add MCEB Pub 7 compliant footer
            sfafLines.push('');
            sfafLines.push('***** END OF SFAF RECORD *****');
            sfafLines.push(`Record Format: MCEB Publication 7 Standard`);
            sfafLines.push(`Generated by: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push(`Timestamp: ${new Date().toISOString()}`);

            return sfafLines.join('\n');
        }

        // Export dynamic fields with proper occurrence numbering
        exportDynamicFields(sfafLines, formData, fieldIds) {
            fieldIds.forEach(baseFieldId => {
                const values = formData[baseFieldId];
                if (values) {
                    const fieldNumber = baseFieldId.replace('field', '');
                    if (Array.isArray(values)) {
                        values.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNumber}. ${value}`);
                            } else {
                                sfafLines.push(`${fieldNumber}/${(index + 1).toString().padStart(2, '0')}. ${value}`);
                            }
                        });
                    } else {
                        sfafLines.push(`${fieldNumber}. ${values}`);
                    }
                }
            });
        }

        // Generate compliance report


        exportFinalSFAFRecord() {
            const formData = this.collectFormData();
            const sfafLines = [];

            // MCEB Pub 7 standard header
            sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
            sfafLines.push('MCEB Publication 7, June 30, 2005');
            sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
            sfafLines.push(`System: SFAF Plotter - Go Edition v1.0`);
            sfafLines.push('');

            // Export logic from source files...
            const fieldOrder = [
                '005', '010', '013', '019', '102', '701', '702',
                '110', '113', '114', '115', '116', '117', '118',
                '130', '131', '140', '141', '142', '143', '144',
                '200', '201', '202', '204', '205', '206', '207', '208', '209',
                '300', '301', '303', '306',
                '340', '343', '357', '362', '363', '373',
                '400', '401', '403', '407',
                '440', '443', '457', '462', '463', '470', '471', '472', '473',
                '500', '501', '502', '503', '511', '512', '513', '520',
                '716', '801', '803', '804', '903'
            ];

            fieldOrder.forEach(fieldNum => {
                const fieldId = `field${fieldNum}`;
                const data = formData[fieldId];

                if (data) {
                    if (Array.isArray(data)) {
                        data.forEach((value, index) => {
                            if (index === 0) {
                                sfafLines.push(`${fieldNum}. ${value}`);
                            } else {
                                const occurrence = (index + 1).toString().padStart(2, '0');
                                sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                            }
                        });
                    } else {
                        sfafLines.push(`${fieldNum}. ${data}`);
                    }
                }
            });

            sfafLines.push('');
            sfafLines.push('***** END OF SFAF RECORD *****');
            return sfafLines.join('\n');
        }

        // Add all other missing methods from source files...
        


        // initializeFieldSpecs() { /* from sources */ }
        // loadOfficialGeographicCodes() { /* from sources */ }
        // loadOfficialIRACNotes() { /* from sources */ }
        // loadOfficialFunctionIdentifiers() { /* from sources */ }
        // loadOfficialEquipmentCodes() { /* from sources */ }
        // loadOfficialTimeCodes() { /* from sources */ }
        // saveFormState() { /* from sources */ }
        // restoreFormState() { /* from sources */ }
        // validateEntireForm() { /* from sources */ }
        // exportFinalSFAFRecord() { /* from sources */ }
        // ... etc.
    }
    // Single initialization
    document.addEventListener('DOMContentLoaded', () => {
        try {
            window.sfafFieldManager = new SFAFFieldManager();

            // DEBUG: Verify class initialization
            console.log('🔍 SFAF Manager Status:', {
                instance: !!window.sfafFieldManager,
                methods: Object.getOwnPropertyNames(Object.getPrototypeOf(window.sfafFieldManager)),
                fieldSpecs: !!window.sfafFieldManager.fieldSpecs,
                powerTypes: !!window.sfafFieldManager.powerTypes
            });

            console.log('🎯 SFAF Field Manager fully operational');
        } catch (error) {
            console.error('❌ Error initializing SFAF Field Manager:', error);
        }
    });

    window.SFAFFieldManager = SFAFFieldManager;

})(); // ← CRITICAL: Proper IIFE closure

// 2. THEN: Utility functions (from newfile.txt)
function setFieldValue(formFieldId, value) {
    // Implementation from newfile.txt
}

function downloadSFAF(sfafData, filename = 'sfaf_record.txt') {
    // Implementation from newfile.txt  
}

function showNotification(message, type = 'info') {
    // Implementation from newfile.txt
}

// // NOW the initialization code goes OUTSIDE the class:
// let sfafFieldManager;
// document.addEventListener('DOMContentLoaded', () => {
//     try {
//         sfafFieldManager = new SFAFFieldManager();

//         // Restore any saved form state
//         sfafFieldManager.restoreFormState();

//         this.log('🎯 SFAF Field Manager fully operational');
//         this.log('📖 Based on MCEB Publication 7, June 30, 2005');
//         this.log('✅ All official MCEB Pub 7 standards implemented');

//     } catch (error) {
//         this.error('❌ Error initializing SFAF Field Manager:', error);
//     }
// });

// Additional utility functions can go here


// Global utility function for downloading SFAF records
function downloadSFAF(sfafData, filename = 'sfaf_record.txt') {
    const blob = new Blob([sfafData], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);

    showNotification('SFAF record downloaded', 'success');
}

// Global notification system
function 

// Map imported field IDs to SFAF field IDs
function 

// Handle field500 variants and dynamic field processing
function 

// Export for module systems (Node.js, etc.)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        SFAFFieldManager,
        setFieldValue,
        downloadSFAF,
        showNotification,
        setupKeyboardShortcuts,
        mapImportedFieldId
    };
}

// AMD/RequireJS support
if (typeof define === 'function' && define.amd) {
    define([], function () {
        return {
            SFAFFieldManager,
            setFieldValue,
            downloadSFAF,
            showNotification
        };
    });
}

// Initialize map integration if available
if (typeof initializeMap === 'function') {
    initializeMap();
    this.log('🗺️ Map integration initialized');
}

// Auto-populate coordinate fields from marker data
function populateCoordinatesFromMap(data) {
    if (data.coordinates) {
        setFieldValue('field303', data.coordinates.compact);
        setFieldValue('field403', data.coordinates.compact);
        this.log('📍 Coordinates populated from map data');
    }
}const baseMaps = {
    'CARTO Light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }),
    'CARTO Dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }),
    'Esri Streets': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri',
        maxZoom: 19
    }),
    'Esri Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri',
        maxZoom: 19
    })
};

// Initialize map (same center as your original)
const map = L.map('map', {
    center: [30.43, -86.695],
    zoom: 13,
    layers: [baseMaps['Esri Satellite']]
});

// Add layer control
L.control.layers(baseMaps).addTo(map);

// Create layer group for drawn features (same as your original)
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

// Storage for markers
const markers = new Map();
let currentSelectedMarker = null;

// Marker icons (same as your original)
const manualIcon = L.icon({
    iconUrl: '/images/marker-green.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28],
});

const importedIcon = L.icon({
    iconUrl: '/images/marker-blue.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28],
});

// Coordinate tooltip using Go API (matches your original structure)
const cursorTooltip = L.tooltip({
    permanent: false,
    direction: 'right',
    offset: L.point(0, -45),
    className: 'cursorTooltip'
});

// Show tooltip on map mousemove (same as your original logic)
map.on('mousemove', async (e) => {
    if (e.originalEvent.target.classList.contains('leaflet-container')) {
        try {
            const lat = e.latlng.lat.toFixed(4);
            const lng = e.latlng.lng.toFixed(4);

            // Use Go API for coordinate conversion
            const response = await fetch(`/api/convert-coords?lat=${lat}&lng=${lng}`);
            const coords = await response.json();

            cursorTooltip
                .setLatLng(e.latlng)
                .setContent(`<b>Cursor</b><br>DecDeg: ${coords.decimal}<br>DMS: ${coords.dms}`);
            if (!cursorTooltip._map) {
                cursorTooltip.addTo(map);
            }
        } catch (error) {
            console.error('Coordinate conversion failed:', error);
            if (cursorTooltip._map) {
                map.removeLayer(cursorTooltip);
            }
        }
    } else {
        if (cursorTooltip._map) {
            map.removeLayer(cursorTooltip);
        }
    }
});

// Hide tooltip when mouse leaves map (same as your original)
map.getContainer().addEventListener('mouseleave', () => {
    if (cursorTooltip._map) {
        map.removeLayer(cursorTooltip);
    }
});

// Load existing markers from Go backend
async function loadExistingMarkers() {
    try {
        const response = await fetch('/api/markers');
        const data = await response.json();

        if (data.markers) {
            data.markers.forEach(markerData => {
                createMarkerOnMap(markerData);
            });
        }
    } catch (error) {
        console.error('Failed to load existing markers:', error);
    }
}

// Create marker on map (matches your original createManualMarker function)
function createMarkerOnMap(markerData) {
    const icon = markerData.type === 'imported' ? importedIcon : manualIcon;
    const marker = L.marker([markerData.lat, markerData.lng], {
        icon: icon,
        draggable: markerData.is_draggable !== false
    });

    // Add to both map and drawnItems for edit controls to work
    map.addLayer(marker);
    drawnItems.addLayer(marker);

    // Store marker data
    marker.markerData = {
        ...markerData,
        lat: parseFloat(markerData.lat).toFixed(4),
        lng: parseFloat(markerData.lng).toFixed(4)
    };

    markers.set(markerData.id, marker);

    // Add tooltip
    updateMarkerTooltip(marker);

    // Drag handler - update coordinates via Go API
    let dragTimeout = null;
    marker.on('drag', async (e) => {
        const pos = e.target.getLatLng();
        marker.markerData.lat = pos.lat.toFixed(4);
        marker.markerData.lng = pos.lng.toFixed(4);

        // Update tooltip immediately
        updateMarkerTooltip(marker);

        // Update sidebar coordinates if this is the selected marker
        if (currentSelectedMarker === marker && typeof updateSidebarCoordinates === 'function') {
            try {
                const response = await fetch(`/api/convert-coords?lat=${pos.lat}&lng=${pos.lng}`);
                const coords = await response.json();
                updateSidebarCoordinates(coords);
            } catch (error) {
                console.error('Failed to convert coordinates:', error);
            }
        }

        // Debounce server update
        if (dragTimeout) {
            clearTimeout(dragTimeout);
        }
        dragTimeout = setTimeout(async () => {
            try {
                const response = await fetch(`/api/markers/${markerData.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lat: parseFloat(pos.lat.toFixed(4)),
                        lng: parseFloat(pos.lng.toFixed(4))
                    })
                });
                if (response.ok) {
                    const updatedMarker = await response.json();
                    marker.markerData = {
                        ...updatedMarker.marker,
                        lat: parseFloat(updatedMarker.marker.lat).toFixed(4),
                        lng: parseFloat(updatedMarker.marker.lng).toFixed(4)
                    };
                    this.log('✅ Marker position saved to server');
                }
            } catch (error) {
                console.error('❌ Failed to update marker coordinates:', error);
            }
        }, 500);
    });

    // Click handler - open sidebar
    marker.on('click', async () => {
        currentSelectedMarker = marker;
        await openSidebar(markerData.id);
    });
}

// More efficient version with coordinate caching
const coordinateCache = new Map();

async function updateMarkerTooltip(marker) {
    const data = marker.markerData;
    const coordKey = `${data.lat},${data.lng}`;
    let dmsText = '';

    // Check cache first
    if (coordinateCache.has(coordKey)) {
        dmsText = coordinateCache.get(coordKey);
    } else {
        try {
            // Get DMS coordinates from Go API
            const response = await fetch(`/api/convert-coords?lat=${data.lat}&lng=${data.lng}`);
            const coords = await response.json();
            dmsText = coords.dms;

            // Cache the result
            coordinateCache.set(coordKey, dmsText);
        } catch (error) {
            console.error('Failed to get DMS coordinates for tooltip:', error);
            dmsText = 'DMS conversion failed';
        }
    }

    marker.unbindTooltip();
    marker.bindTooltip(
        `<b>Manual Marker</b><br>
         DecDeg: ${data.lat}, ${data.lng}<br>
         DMS: ${dmsText}<br>
         Serial: ${data.serial}<br>
         Freq: ${data.frequency || 'N/A'}<br>
         Notes: ${data.notes || '(none)'}`,
        { permanent: true, direction: 'top', offset: L.point(0, -15) }
    ).openTooltip();
}

// Drawing controls (same as your original)
const drawControl = new L.Control.Draw({
    edit: {
        featureGroup: drawnItems,
        remove: true,
        edit: true
    },
    draw: {
        polygon: true,
        rectangle: true,
        circle: true,
        marker: true,
        polyline: false
    }
});
map.addControl(drawControl);

// Drawing event handlers that use Go APIs
map.on(L.Draw.Event.CREATED, async function (event) {
    const { layerType, layer } = event;

    try {
        let response;

        switch (layerType) {
            case 'marker':
                const latLng = layer.getLatLng();
                response = await fetch('/api/markers', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lat: parseFloat(latLng.lat.toFixed(4)),
                        lng: parseFloat(latLng.lng.toFixed(4)),
                        type: 'manual'
                    })
                });
                if (response.ok) {
                    const markerResp = await response.json();
                    // Don't add the drawn layer to drawnItems since we're replacing it
                    map.removeLayer(layer);
                    createMarkerOnMap(markerResp.marker); // This will now add to drawnItems
                }
                break;

            case 'circle':
                const center = layer.getLatLng();
                const radius = layer.getRadius();
                response = await fetch('/api/geometry/circle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lat: center.lat,
                        lng: center.lng,
                        radius: radius / 1000, // Convert to km
                        unit: 'km'
                    })
                });

                if (response.ok) {
                    const geometryResp = await response.json();
                    drawnItems.addLayer(layer);

                    // Add center marker if geometry service returns one
                    if (geometryResp.geometry && geometryResp.geometry.center_marker) {
                        createMarkerOnMap(geometryResp.geometry.center_marker);
                    }
                }
                break;

            case 'polygon':
                const points = layer.getLatLngs()[0].map(point => ({
                    lat: point.lat,
                    lng: point.lng
                }));

                response = await fetch('/api/geometry/polygon', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ points: points })
                });

                if (response.ok) {
                    const geometryResp = await response.json();
                    drawnItems.addLayer(layer);

                    if (geometryResp.geometry && geometryResp.geometry.center_marker) {
                        createMarkerOnMap(geometryResp.geometry.center_marker);
                    }
                }
                break;

            case 'rectangle':
                const bounds = layer.getBounds();
                response = await fetch('/api/geometry/rectangle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        south_west: {
                            lat: bounds.getSouth(),
                            lng: bounds.getWest()
                        },
                        north_east: {
                            lat: bounds.getNorth(),
                            lng: bounds.getEast()
                        }
                    })
                });

                if (response.ok) {
                    const geometryResp = await response.json();
                    drawnItems.addLayer(layer);

                    if (geometryResp.geometry && geometryResp.geometry.center_marker) {
                        createMarkerOnMap(geometryResp.geometry.center_marker);
                    }
                }
                break;
        }
    } catch (error) {
        console.error(`Failed to create ${layerType}:`, error);
        // Still add to map locally if API fails
        drawnItems.addLayer(layer);
    }
});

// Helper functions for sidebar integration
function openPersistentSidebar() {
    const sidebar = document.getElementById('persistentSidebar');
    if (sidebar) {
        sidebar.classList.add('open');
        this.log('✅ Sidebar opened');
    } else {
        console.error('❌ persistentSidebar element not found');
    }
}

function closePersistentSidebar() {
    const sidebar = document.getElementById('persistentSidebar');
    if (sidebar) {
        sidebar.classList.remove('open');
        this.log('✅ Sidebar closed');
    }
}

function switchTab(tabId) {
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    const targetBtn = document.querySelector(`[data-tab="${tabId}"]`);
    if (targetBtn) {
        targetBtn.classList.add('active');
    }

    // Update tab panels
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });
    const targetPanel = document.getElementById(`tab-${tabId}`);
    if (targetPanel) {
        targetPanel.classList.add('active');
    } else {
        console.error(`Tab panel 'tab-${tabId}' not found`);
    }
}

async function openSidebar(markerId) {
    try {
        this.log('🔍 Opening sidebar for marker:', markerId);
        const response = await fetch(`/api/sfaf/object/${markerId}`);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        this.log('📡 Full API Response:', data);

        if (data.success) {
            // Open your existing sidebar
            openPersistentSidebar();

            // Check if element exists before accessing style
            const objectTab = document.getElementById('objectTab');
            if (objectTab) {
                objectTab.style.display = 'block';
            }

            // Switch to object tab
            switchTab('object');

            // THIS IS THE KEY PART - populate the form
            this.log('🔄 About to call populateExistingSFAFForm...');
            populateExistingSFAFForm(data);
            this.log('✅ populateExistingSFAFForm completed');

        } else {
            console.error('API returned success: false', data);
        }
    } catch (error) {
        console.error('Failed to load SFAF data:', error);
    }
}

function populateExistingSFAFForm(data) {
    window.currentSFAFMarker = data.marker;
    this.log('📋 Populating SFAF form with imported data per MCEB Pub 7');

    // Complete official MCEB Pub 7 field mapping based on your HTML form structure
    const sfafFieldMapping = {
        // Administrative Data (Direct mappings)
        'field005': 'field005',    // Security Classification
        'field010': 'field010',    // Type of Action
        'field013': 'field013',    // Declassification Instruction Comment
        'field019': 'field019',    // Declassification Date
        'field102': 'field102',    // Agency Serial Number ✅ (works)
        'field701': 'field701',    // Frequency Action Officer
        'field702': 'field702',    // Control/Request Number (required for CENTCOM)

        // Emission Characteristics (Dynamic entries - map to _1 variants)
        'field110': 'field110_1',  // Frequency(ies) ✅ per MCEB Pub 7
        'field113': 'field113_1',  // Station Class ✅ per MCEB Pub 7
        'field114': 'field114_1',  // Emission Designator ✅ per MCEB Pub 7
        'field115': 'field115_1',  // Transmitter Power ✅ per MCEB Pub 7
        'field116': 'field116_1',  // Power Type (C/M/P) per MCEB Pub 7
        'field117': 'field117_1',  // Effective Radiated Power
        'field118': 'field118_1',  // Power/ERP Augmentation

        // Time/Date Information
        'field130': 'field130',    // Time ✅ (works) per MCEB Pub 7
        'field131': 'field131',    // Percent Time (required for EUCOM Germany)
        'field140': 'field140',    // Required Date (YYYYMMDD)
        'field141': 'field141',    // Expiration Date (required for CENTCOM)
        'field142': 'field142',    // Review Date
        'field143': 'field143',    // Revision Date
        'field144': 'field144',    // Approval Authority

        // Organizational Information
        'field200': 'field200',    // Agency (USAF, USA, USN, USMC, USCG)
        'field201': 'field201',    // Unified Command
        'field202': 'field202',    // Unified Command Service
        'field204': 'field204',    // Command
        'field205': 'field205',    // Subcommand
        'field206': 'field206',    // Installation Frequency Manager
        'field207': 'field207',    // Operating Unit
        'field209': 'field209',    // Area AFC/DoD AFC

        // Transmitter Location (Geographic codes A-Z per MCEB Pub 7 Annex E)
        'field300': 'field300',    // State/Country (A-Z geographic codes)
        'field301': 'field301',    // Antenna Location
        'field303': 'field303',    // Antenna Coordinates ✅ (auto-filled)
        'field306': 'field306',    // Authorized Radius

        // Transmitter Equipment (Dynamic entries per MCEB Pub 7 Annex D)
        'field340': 'field340_1',  // Equipment Nomenclature ✅
        'field343': 'field343_1',  // Equipment Certification ID ✅

        // Transmitter Antenna
        'field357': 'field357',    // Antenna Gain
        'field362': 'field362',    // Antenna Orientation
        'field363': 'field363',    // Antenna Polarization (V/H/C)
        'field373': 'field373',    // JSC Area Code (A-Z)

        // Receiver Location
        'field400': 'field400',    // State/Country (A-Z geographic codes)
        'field401': 'field401',    // Antenna Location
        'field403': 'field403',    // Antenna Coordinates ✅ (auto-filled)

        // Receiver Equipment (Dynamic entries)
        'field440': 'field440_1',  // Equipment Nomenclature ✅
        'field443': 'field443_1',  // Equipment Certification ID ✅

        // Receiver Antenna
        'field457': 'field457',    // Antenna Gain
        'field462': 'field462',    // Antenna Orientation
        'field463': 'field463',    // Antenna Polarization (V/H/C)
        'field473': 'field473',    // JSC Area Code (A/B/C/D)

        // Supplementary Details (Dynamic entries per MCEB Pub 7 Annex F & I)
        'field500': 'field500_1',  // IRAC Notes ✅ (C/E/L/P/S codes)
        'field501': 'field501_1',  // Notes/Comments ✅
        'field502': 'field502',    // Description of Requirement (required for CENTCOM)
        'field503': 'field503',    // Agency Free-text Comments
        'field511': 'field511',    // Major Function Identifier (Annex I)
        'field512': 'field512',    // Intermediate Function Identifier (Annex I)
        'field513': 'field513',    // Minor Function Identifier (new in 2005)
        'field520': 'field520',    // Supplementary Details

        // Other Assignment Identifiers
        'field716': 'field716',    // Usage Code
        'field801': 'field801',    // Coordination Data/Remarks
        'field803': 'field803',    // Requestor Data POC
        'field804': 'field804',    // Additional Assignment Data

        // Deprecated fields (no longer used by DoD per MCEB Pub 7)
        'field208': null,  // No longer required by Air Force
        'field407': null,  // No longer used by DoD
        'field470': null,  // No longer used by DoD
        'field471': null,  // No longer used by DoD
        'field472': null,  // No longer used by DoD
        'field903': null,  // No longer used by DoD

        // Fields that don't exist in SFAF standard
        'field101': null,  // Not in MCEB Pub 7 standard
        'field103': null,  // Additional serial numbers - not in form
        'field107': null,  // Date field - not in form
    };

    function setFieldValue(formFieldId, value) {
        if (!formFieldId || !value) return false;

        const field = document.getElementById(formFieldId);
        if (field) {
            this.log(`✅ Setting ${formFieldId} = ${value} (MCEB Pub 7 compliant)`);
            field.value = value;
            field.dispatchEvent(new Event('change'));

            // // Trigger MCEB Pub 7 validation if field manager is available
            // if (window.sfafFieldManager) {
            //     window.sfafFieldManager.validateField(field);
            // }

            return true;
        }
        return false;
    }

    // Auto-populate coordinate fields from marker (field 303/403 per MCEB Pub 7)
    if (data.coordinates) {
        setFieldValue('field303', data.coordinates.compact);
        setFieldValue('field403', data.coordinates.compact);
        this.log('📍 Coordinates populated per MCEB Pub 7 format');
    }

    // Populate SFAF fields using official MCEB Pub 7 mapping
    if (data.sfaf_fields) {
        let successCount = 0;
        let skippedCount = 0;
        let deprecatedCount = 0;
        let unknownCount = 0;

        Object.entries(data.sfaf_fields).forEach(([importedFieldId, value]) => {
            this.log(`🔍 Processing ${importedFieldId} = ${value}`);

            // Handle field500 variants (500/02, 500/03, etc.) per MCEB Pub 7 Annex F
            if (importedFieldId.startsWith('field500/')) {
                const parts = importedFieldId.split('/');
                if (parts.length === 2) {
                    const number = parseInt(parts[1]);
                    const targetFieldId = `field500_${number}`;

                    if (setFieldValue(targetFieldId, value)) {
                        this.log(`🔧 Mapped IRAC note ${importedFieldId} → ${targetFieldId} (MCEB Pub 7 Annex F)`);
                        successCount++;
                    }
                }
                return;
            }

            // Handle field103 variants (additional serial numbers per MCEB Pub 7)
            if (importedFieldId.startsWith('field103/')) {
                this.log(`⚠️ Skipping ${importedFieldId} - additional serial numbers not supported in form`);
                skippedCount++;
                return;
            }

            // Use official MCEB Pub 7 mapping
            const actualFieldId = sfafFieldMapping[importedFieldId];

            if (actualFieldId === null) {
                // Check if it's a deprecated field
                const deprecatedFields = ['field208', 'field407', 'field470', 'field471', 'field472', 'field903'];
                if (deprecatedFields.includes(importedFieldId)) {
                    this.log(`🔄 Skipping ${importedFieldId} - deprecated in MCEB Pub 7 (June 2005)`);
                    deprecatedCount++;
                } else {
                    this.log(`⚠️ Skipping ${importedFieldId} - field not in MCEB Pub 7 standard`);
                    skippedCount++;
                }
            } else if (actualFieldId) {
                if (setFieldValue(actualFieldId, value)) {
                    this.log(`🔧 Mapped ${importedFieldId} → ${actualFieldId} (MCEB Pub 7)`);
                    successCount++;
                }
            } else {
                // Try the original field ID as fallback
                if (setFieldValue(importedFieldId, value)) {
                    this.log(`✅ Direct match ${importedFieldId} = ${value} (MCEB Pub 7)`);
                    successCount++;
                } else {
                    this.log(`❓ Unknown field ${importedFieldId} - not in MCEB Pub 7 specification`);
                    unknownCount++;
                }
            }
        });

        // Generate MCEB Pub 7 compliance summary
        this.log(`📊 MCEB Publication 7 Import Results:`);
        this.log(`  ✅ Successfully populated: ${successCount} fields`);
        this.log(`  ⚠️ Skipped (not in form): ${skippedCount} fields`);
        this.log(`  🔄 Deprecated (MCEB Pub 7): ${deprecatedCount} fields`);
        this.log(`  ❓ Unknown fields: ${unknownCount} fields`);
        this.log(`  📖 Reference: MCEB Publication 7, June 30, 2005`);

        // Show compliance notification
        if (successCount > 0) {
            showComplianceNotification(successCount, skippedCount + deprecatedCount + unknownCount);
        }
    }

    this.log('✅ SFAF form population complete per MCEB Pub 7 standards');
}

// Show MCEB Pub 7 compliance notification
function showComplianceNotification(successCount, totalSkipped) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #2196F3, #1976D2);
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 500px;
        text-align: center;
    `;

    notification.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 8px;">
            📖 MCEB Publication 7 Compliance
        </div>
        <div style="font-size: 0.9em; opacity: 0.95;">
            ${successCount} fields populated successfully<br>
            ${totalSkipped} fields skipped (deprecated/not applicable)<br>
            <strong>Standard: MCEB Pub 7, June 30, 2005</strong>
        </div>
    `;

    document.body.appendChild(notification);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(-50%) translateY(-20px)';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}



function setupAuthorizationRadius() {
    const field306 = document.getElementById('field306');
    if (!field306) return;

    // Remove existing event listeners to prevent duplicates
    const newField306 = field306.cloneNode(true);
    field306.parentNode.replaceChild(newField306, field306);

    // Add change listener to field 306
    newField306.addEventListener('input', async () => {
        const radiusValue = newField306.value.trim();

        if (radiusValue && window.currentSFAFMarker) {
            try {
                await createAuthorizationCircle(radiusValue);
            } catch (error) {
                console.error('Failed to create authorization circle:', error);
            }
        } else {
            removeAuthorizationCircle();
        }
    });
}

// In your openSidebar function, add this debug:
async function openSidebar(markerId) {
    try {
        this.log('🔍 Opening sidebar for marker:', markerId);
        const response = await fetch(`/api/sfaf/object/${markerId}`);
        const data = await response.json();

        this.log('📋 SFAF Fields:', data.sfaf_fields);

        if (data.success) {
            openPersistentSidebar();
            const objectTab = document.getElementById('objectTab');
            if (objectTab) {
                objectTab.style.display = 'block';
            }
            switchTab('object');
            populateExistingSFAFForm(data);
        }
    } catch (error) {
        console.error('Failed to load SFAF data:', error);
    }
}

// Authorization circle management
let authorizationCircle = null;

async function createAuthorizationCircle(radiusValue) {
    if (!window.currentSFAFMarker) return;

    // Remove existing circle
    removeAuthorizationCircle();

    try {
        // Parse radius (remove B/T suffixes)
        const numericRadius = parseFloat(radiusValue.replace(/[BT]/gi, ''));
        if (isNaN(numericRadius) || numericRadius <= 0) return;

        // Create circle
        authorizationCircle = L.circle(
            [window.currentSFAFMarker.lat, window.currentSFAFMarker.lng],
            {
                radius: numericRadius * 1000, // Convert km to meters
                color: '#ff6b6b',
                fillColor: '#ff6b6b',
                fillOpacity: 0.1,
                opacity: 0.6,
                weight: 2,
                dashArray: '5, 5'
            }
        ).addTo(map);

        authorizationCircle.bindTooltip(
            `<b>Authorization Radius</b><br>
             Radius: ${numericRadius} km<br>
             Field 306: ${radiusValue}`,
            { permanent: false }
        );

    } catch (error) {
        console.error('Failed to create authorization circle:', error);
    }
}

function removeAuthorizationCircle() {
    if (authorizationCircle) {
        map.removeLayer(authorizationCircle);
        authorizationCircle = null;
    }
}

function setupCoordinateSync() {
    // This will be called when markers are dragged to update fields 303 and 403
    window.updateSidebarCoordinates = function (coordinates) {
        const field303 = document.getElementById('field303');
        const field403 = document.getElementById('field403');

        if (field303 && coordinates.compact) {
            field303.value = coordinates.compact;
        }
        if (field403 && coordinates.compact) {
            field403.value = coordinates.compact;
        }
    };
}

function wireUpActionButtons() {
    // Override your existing button handlers to use Go APIs
    const validateBtn = document.getElementById('validateSFAFBtn');
    const saveBtn = document.getElementById('saveSFAFBtn');
    const exportBtn = document.getElementById('exportSFAFBtn');
    const deleteBtn = document.getElementById('deleteSFAFBtn');

    if (validateBtn) {
        validateBtn.onclick = validateSFAFWithGo;
    }

    if (saveBtn) {
        saveBtn.onclick = saveSFAFWithGo;
    }

    if (exportBtn) {
        exportBtn.onclick = exportSFAFWithGo;
    }

    if (deleteBtn) {
        deleteBtn.onclick = deleteSFAFWithGo;
    }
}

// SFAF action functions that work with your existing form
async function validateSFAFWithGo() {
    const formData = collectSFAFFormData();

    try {
        const response = await fetch('/api/sfaf/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fields: formData })
        });

        const result = await response.json();

        if (result.success) {
            applySFAFValidationResults(result.validation);
            showSFAFStatusMessage(
                result.validation.is_valid ? '✅ Form validation passed!' : '❌ Form has validation errors',
                result.validation.is_valid ? 'success' : 'error'
            );
        }
    } catch (error) {
        console.error('Validation failed:', error);
        showSFAFStatusMessage('❌ Validation failed. Please try again.', 'error');
    }
}

async function saveSFAFWithGo() {
    if (!window.currentSFAFMarker) {
        showSFAFStatusMessage('❌ No marker selected', 'error');
        return;
    }

    const formData = collectSFAFFormData();

    try {
        const response = await fetch('/api/sfaf', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                marker_id: window.currentSFAFMarker.id,
                fields: formData
            })
        });

        const result = await response.json();

        if (result.success) {
            showSFAFStatusMessage('✅ SFAF data saved successfully!', 'success');
        } else {
            showSFAFStatusMessage('❌ Failed to save: ' + (result.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        console.error('Save failed:', error);
        showSFAFStatusMessage('❌ Save failed. Please try again.', 'error');
    }
}

async function exportSFAFWithGo() {
    if (!window.currentSFAFMarker) {
        showSFAFStatusMessage('❌ No marker selected', 'error');
        return;
    }

    const formData = collectSFAFFormData();

    const exportData = {
        marker: window.currentSFAFMarker,
        sfaf_fields: formData,
        exported_at: new Date().toISOString(),
        format: 'SFAF_JSON_v1.0'
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });

    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `SFAF_${window.currentSFAFMarker.serial}_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
    showSFAFStatusMessage('📤 SFAF data exported successfully!', 'success');
}

async function deleteSFAFWithGo() {
    if (!window.currentSFAFMarker) {
        showSFAFStatusMessage('❌ No marker selected', 'error');
        return;
    }

    if (confirm(`Delete marker ${window.currentSFAFMarker.serial} and all associated SFAF data?\n\nThis action cannot be undone.`)) {
        try {
            const response = await fetch(`/api/markers/${window.currentSFAFMarker.id}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                // Remove marker from map
                const marker = markers.get(window.currentSFAFMarker.id);
                if (marker) {
                    map.removeLayer(marker);
                    markers.delete(window.currentSFAFMarker.id);
                }

                // Remove authorization circle
                removeAuthorizationCircle();

                // Close sidebar
                closePersistentSidebar();

                showSFAFStatusMessage('✅ Object deleted successfully!', 'success');

                // Clear current marker reference
                window.currentSFAFMarker = null;
            } else {
                showSFAFStatusMessage('❌ Failed to delete object', 'error');
            }
        } catch (error) {
            console.error('Delete failed:', error);
            showSFAFStatusMessage('❌ Delete failed. Please try again.', 'error');
        }
    }
}

function collectSFAFFormData() {
    const formData = {};

    // Get the object tab container
    const objectTab = document.getElementById('tab-object');
    if (!objectTab) {
        console.warn('Object tab not found, collecting from entire document');
        // Fallback to collecting from entire document
        const allFields = document.querySelectorAll('input[id^="field"], select[id^="field"], textarea[id^="field"]');
        allFields.forEach(field => {
            if (field.value && field.value.trim() !== '') {
                formData[field.id] = field.value.trim();
            }
        });
        return formData;
    }

    // Collect from various field patterns in the object tab
    const patterns = [
        'input[id^="field"]',
        'select[id^="field"]',
        'textarea[id^="field"]',
        '[data-field]',
        'input[name^="field"]',
        'select[name^="field"]',
        'textarea[name^="field"]'
    ];

    patterns.forEach(pattern => {
        const fields = objectTab.querySelectorAll(pattern);
        fields.forEach(field => {
            let fieldId = field.id;

            // Handle data-field attributes
            if (field.dataset.field && !fieldId.startsWith('field')) {
                fieldId = 'field' + field.dataset.field;
            }

            // Handle name attributes
            if (!fieldId && field.name) {
                fieldId = field.name;
            }

            if (fieldId && field.value && field.value.trim() !== '') {
                formData[fieldId] = field.value.trim();
            }
        });
    });

    return formData;
}

function applySFAFValidationResults(validation) {
    // Clear previous validation styles
    const objectTab = document.getElementById('tab-object');
    const fieldsToCheck = objectTab ?
        objectTab.querySelectorAll('input, select, textarea') :
        document.querySelectorAll('input[id^="field"], select[id^="field"], textarea[id^="field"]');

    fieldsToCheck.forEach(field => {
        field.style.borderColor = '';
        field.classList.remove('validation-error', 'validation-success');

        // Remove any existing validation messages
        const existingMsg = field.parentNode?.querySelector('.validation-message');
        if (existingMsg) {
            existingMsg.remove();
        }
    });

    // Apply validation results
    if (validation.fields) {
        Object.entries(validation.fields).forEach(([fieldId, fieldData]) => {
            const field = findFieldByAnyMeans(fieldId);

            if (field) {
                const hasError = validation.errors && validation.errors[fieldId];
                const hasValue = fieldData.value && fieldData.value.trim() !== '';

                if (hasError) {
                    field.style.borderColor = '#f44336';
                    field.classList.add('validation-error');

                    // Add error message
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'validation-message';
                    errorMsg.style.cssText = 'color: #f44336; font-size: 12px; margin-top: 2px;';
                    errorMsg.textContent = validation.errors[fieldId];
                    if (field.parentNode) {
                        field.parentNode.appendChild(errorMsg);
                    }

                } else if (hasValue) {
                    field.style.borderColor = '#4CAF50';
                    field.classList.add('validation-success');
                }
            }
        });
    }
}

function findFieldByAnyMeans(fieldId) {
    // Try multiple strategies to find the field
    let field = document.getElementById(fieldId);

    if (!field) {
        const fieldNumber = fieldId.replace('field', '');
        field = document.querySelector(`[data-field="${fieldNumber}"]`);
    }

    if (!field) {
        field = document.querySelector(`[name="${fieldId}"]`);
    }

    if (!field) {
        // Try partial matches
        field = document.querySelector(`[id*="${fieldId}"]`);
    }

    return field;
}

function showSFAFStatusMessage(message, type) {
    // Remove any existing status messages
    const existing = document.querySelectorAll('.sfaf-status-message');
    existing.forEach(msg => msg.remove());

    // Create status message
    const statusDiv = document.createElement('div');
    statusDiv.className = 'sfaf-status-message';
    statusDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 470px;
        background: ${type === 'success' ? '#4CAF50' : '#f44336'};
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        z-index: 2000;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        max-width: 300px;
    `;
    statusDiv.textContent = message;
    document.body.appendChild(statusDiv);

    setTimeout(() => statusDiv.remove(), 4000);
}


// Load existing markers when page loads
document.addEventListener('DOMContentLoaded', function () {
    loadExistingMarkers();
});

// Make functions globally available
window.openSidebar = openSidebar;
window.openPersistentSidebar = openPersistentSidebar;
window.closePersistentSidebar = closePersistentSidebar;
window.switchTab = switchTab;const baseMaps = {
    'CARTO Light': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }),
    'CARTO Dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }),
    'Esri Streets': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri',
        maxZoom: 19
    }),
    'Esri Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri',
        maxZoom: 19
    })
};

// Initialize map (same center as your original)
const map = L.map('map', {
    center: [30.43, -86.695],
    zoom: 13,
    layers: [baseMaps['Esri Satellite']]
});

// Add layer control
L.control.layers(baseMaps).addTo(map);

// Create layer group for drawn features (same as your original)
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

// Storage for markers
const markers = new Map();
let currentSelectedMarker = null;

// Marker icons (same as your original)
const manualIcon = L.icon({
    iconUrl: '/images/marker-green.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28],
});

const importedIcon = L.icon({
    iconUrl: '/images/marker-blue.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28],
});

// Coordinate tooltip using Go API (matches your original structure)
const cursorTooltip = L.tooltip({
    permanent: false,
    direction: 'right',
    offset: L.point(0, -45),
    className: 'cursorTooltip'
});

// Add to map initialization
map.on('click', function (e) {
    // If clicking on empty map (not on a marker)
    if (!e.originalEvent.target.closest('.leaflet-marker-icon')) {
        manageObjectTabVisibility(false);
        window.currentSFAFMarker = null;
    }
});

// Show tooltip on map mousemove (same as your original logic)
map.on('mousemove', async (e) => {
    if (e.originalEvent.target.classList.contains('leaflet-container')) {
        try {
            const lat = e.latlng.lat.toFixed(4);
            const lng = e.latlng.lng.toFixed(4);

            // Use Go API for coordinate conversion
            const response = await fetch(`/api/convert-coords?lat=${lat}&lng=${lng}`);
            const coords = await response.json();

            cursorTooltip
                .setLatLng(e.latlng)
                .setContent(`<b>Cursor</b><br>DecDeg: ${coords.decimal}<br>DMS: ${coords.dms}`);
            if (!cursorTooltip._map) {
                cursorTooltip.addTo(map);
            }
        } catch (error) {
            console.error('Coordinate conversion failed:', error);
            if (cursorTooltip._map) {
                map.removeLayer(cursorTooltip);
            }
        }
    } else {
        if (cursorTooltip._map) {
            map.removeLayer(cursorTooltip);
        }
    }
});

// Hide tooltip when mouse leaves map (same as your original)
map.getContainer().addEventListener('mouseleave', () => {
    if (cursorTooltip._map) {
        map.removeLayer(cursorTooltip);
    }
});

// Load existing markers from Go backend
async function loadExistingMarkers() {
    try {
        const response = await fetch('/api/markers');
        const data = await response.json();

        if (data.markers) {
            data.markers.forEach(markerData => {
                createMarkerOnMap(markerData);
            });
        }
    } catch (error) {
        console.error('Failed to load existing markers:', error);
    }
}

// Create marker on map (matches your original createManualMarker function)
function createMarkerOnMap(markerData) {
    const icon = markerData.type === 'imported' ? importedIcon : manualIcon;
    const marker = L.marker([markerData.lat, markerData.lng], {
        icon: icon,
        draggable: markerData.is_draggable !== false
    });

    // Add to both map and drawnItems for edit controls to work
    map.addLayer(marker);
    drawnItems.addLayer(marker);

    // Store marker data
    marker.markerData = {
        ...markerData,
        lat: parseFloat(markerData.lat).toFixed(4),
        lng: parseFloat(markerData.lng).toFixed(4)
    };

    markers.set(markerData.id, marker);

    // Add tooltip
    updateMarkerTooltip(marker);

    // Drag handler - update coordinates via Go API
    let dragTimeout = null;
    marker.on('drag', async (e) => {
        const pos = e.target.getLatLng();
        marker.markerData.lat = pos.lat.toFixed(4);
        marker.markerData.lng = pos.lng.toFixed(4);

        // Update tooltip immediately
        updateMarkerTooltip(marker);

        // Update sidebar coordinates if this is the selected marker
        if (currentSelectedMarker === marker && typeof updateSidebarCoordinates === 'function') {
            try {
                const response = await fetch(`/api/convert-coords?lat=${pos.lat}&lng=${pos.lng}`);
                const coords = await response.json();
                updateSidebarCoordinates(coords);
            } catch (error) {
                console.error('Failed to convert coordinates:', error);
            }
        }

        // Debounce server update
        if (dragTimeout) {
            clearTimeout(dragTimeout);
        }
        dragTimeout = setTimeout(async () => {
            try {
                const response = await fetch(`/api/markers/${markerData.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lat: parseFloat(pos.lat.toFixed(4)),
                        lng: parseFloat(pos.lng.toFixed(4))
                    })
                });
                if (response.ok) {
                    const updatedMarker = await response.json();
                    marker.markerData = {
                        ...updatedMarker.marker,
                        lat: parseFloat(updatedMarker.marker.lat).toFixed(4),
                        lng: parseFloat(updatedMarker.marker.lng).toFixed(4)
                    };
                    console.error('✅ Marker position saved to server');
                }
            } catch (error) {
                console.error('❌ Failed to update marker coordinates:', error);
            }
        }, 500);
    });

    // Click handler - open sidebar
    marker.on('click', async () => {
        currentSelectedMarker = marker;
        await openSidebar(markerData.id);
    });
}

// More efficient version with coordinate caching
const coordinateCache = new Map();

async function updateMarkerTooltip(marker, coordinateData) {
    const data = marker.markerData;
    const coordKey = `${data.lat},${data.lng}`;
    let dmsText = '';

    // Check cache first
    if (coordinateCache.has(coordKey)) {
        dmsText = coordinateCache.get(coordKey);
    } else {
        try {
            let coords;
            if (coordinateData && coordinateData.coordinates) {
                coords = coordinateData.coordinates;
            } else {
                // Fallback to marker data
                coords = {
                    lat: marker.Latitude || marker.lat,
                    lng: marker.Longitude || marker.lng,
                    decimal: `${marker.Latitude || marker.lat}, ${marker.Longitude || marker.lng}`,
                    dms: 'DMS format not available'
                };
            }

            // Update tooltip with coordinate information
            const tooltip = `
            Lat/Lng: ${coords.decimal}
            DMS: ${coords.dms || 'Not available'}
            Compact: ${coords.compact || 'Not available'}
        `;

            marker.bindTooltip(tooltip);

        } catch (error) {
            console.error('Failed to get DMS coordinates for tooltip:', error);
            // Fallback tooltip
            marker.bindTooltip(`Coordinates: ${marker.Latitude || marker.lat}, ${marker.Longitude || marker.lng}`);
        }
    }

    marker.unbindTooltip();
    marker.bindTooltip(
        `<b>Manual Marker</b><br>
         DecDeg: ${data.lat}, ${data.lng}<br>
         DMS: ${dmsText}<br>
         Serial: ${data.serial}<br>
         Freq: ${data.frequency || 'N/A'}<br>
         Notes: ${data.notes || '(none)'}`,
        { permanent: true, direction: 'top', offset: L.point(0, -15) }
    ).openTooltip();
}

// Drawing controls (same as your original)
const drawControl = new L.Control.Draw({
    edit: {
        featureGroup: drawnItems,
        remove: true,
        edit: true
    },
    draw: {
        polygon: true,
        rectangle: true,
        circle: true,
        marker: true,
        polyline: false
    }
});
map.addControl(drawControl);

// Drawing event handlers that use Go APIs
map.on(L.Draw.Event.CREATED, async function (event) {
    const { layerType, layer } = event;

    try {
        let response;

        switch (layerType) {
            case 'marker':
                const latLng = layer.getLatLng();
                response = await fetch('/api/markers', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lat: parseFloat(latLng.lat.toFixed(4)),
                        lng: parseFloat(latLng.lng.toFixed(4)),
                        type: 'manual'
                    })
                });
                if (response.ok) {
                    const markerResp = await response.json();
                    // Don't add the drawn layer to drawnItems since we're replacing it
                    map.removeLayer(layer);
                    createMarkerOnMap(markerResp.marker); // This will now add to drawnItems
                }
                break;

            case 'circle':
                const center = layer.getLatLng();
                const radius = layer.getRadius();
                response = await fetch('/api/geometry/circle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lat: center.lat,
                        lng: center.lng,
                        radius: radius / 1000, // Convert to km
                        unit: 'km'
                    })
                });

                if (response.ok) {
                    const geometryResp = await response.json();
                    drawnItems.addLayer(layer);

                    // Add center marker if geometry service returns one
                    if (geometryResp.geometry && geometryResp.geometry.center_marker) {
                        createMarkerOnMap(geometryResp.geometry.center_marker);
                    }
                }
                break;

            case 'polygon':
                const points = layer.getLatLngs()[0].map(point => ({
                    lat: point.lat,
                    lng: point.lng
                }));

                response = await fetch('/api/geometry/polygon', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ points: points })
                });

                if (response.ok) {
                    const geometryResp = await response.json();
                    drawnItems.addLayer(layer);

                    if (geometryResp.geometry && geometryResp.geometry.center_marker) {
                        createMarkerOnMap(geometryResp.geometry.center_marker);
                    }
                }
                break;

            case 'rectangle':
                const bounds = layer.getBounds();
                response = await fetch('/api/geometry/rectangle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        south_west: {
                            lat: bounds.getSouth(),
                            lng: bounds.getWest()
                        },
                        north_east: {
                            lat: bounds.getNorth(),
                            lng: bounds.getEast()
                        }
                    })
                });

                if (response.ok) {
                    const geometryResp = await response.json();
                    drawnItems.addLayer(layer);

                    if (geometryResp.geometry && geometryResp.geometry.center_marker) {
                        createMarkerOnMap(geometryResp.geometry.center_marker);
                    }
                }
                break;
        }
    } catch (error) {
        console.error(`Failed to create ${layerType}:`, error);
        // Still add to map locally if API fails
        drawnItems.addLayer(layer);
    }
});

// Helper functions for sidebar integration
function openPersistentSidebar() {
    const sidebar = document.getElementById('persistentSidebar');
    if (sidebar) {
        sidebar.classList.add('open');
    } else {
        console.error('❌ persistentSidebar element not found');
    }
}

function closePersistentSidebar() {
    const sidebar = document.getElementById('persistentSidebar');
    if (sidebar) {
        sidebar.classList.remove('open');

        // Hide Object tab when sidebar is closed
        manageObjectTabVisibility(false);

        // Clear current marker reference
        window.currentSFAFMarker = null;
    }
}

function switchTab(tabId) {
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    const targetBtn = document.querySelector(`[data-tab="${tabId}"]`);
    if (targetBtn) {
        targetBtn.classList.add('active');
    }

    // Update tab panels
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });
    const targetPanel = document.getElementById(`tab-${tabId}`);
    if (targetPanel) {
        targetPanel.classList.add('active');
    }
}

async function openSidebar(markerId) {
    try {
        const response = await fetch(`/api/sfaf/object/${markerId}`);
        const data = await response.json();

        if (data.success) {
            openPersistentSidebar();

            // Show Object tab since we have a selected marker
            manageObjectTabVisibility(true);

            switchTab('object');
            populateExistingSFAFForm(data);
        }
    } catch (error) {
        console.error('Error fetching SFAF data:', error);
        // Hide Object tab on error
        manageObjectTabVisibility(false);
    }
}

function populateExistingSFAFForm(data) {
    window.currentSFAFMarker = data.marker;
    // Complete official MCEB Pub 7 field mapping based on your HTML form structure
    const sfafFieldMapping = {
        // Administrative Data (Direct mappings)
        'field005': 'field005',    // Security Classification
        'field010': 'field010',    // Type of Action
        'field013': 'field013',    // Declassification Instruction Comment
        'field019': 'field019',    // Declassification Date
        'field102': 'field102',    // Agency Serial Number ✅ (works)
        'field701': 'field701',    // Frequency Action Officer
        'field702': 'field702',    // Control/Request Number (required for CENTCOM)

        // Emission Characteristics (Dynamic entries - map to _1 variants)
        'field110': 'field110_1',  // Frequency(ies) ✅ per MCEB Pub 7
        'field113': 'field113_1',  // Station Class ✅ per MCEB Pub 7
        'field114': 'field114_1',  // Emission Designator ✅ per MCEB Pub 7
        'field115': 'field115_1',  // Transmitter Power ✅ per MCEB Pub 7
        'field116': 'field116_1',  // Power Type (C/M/P) per MCEB Pub 7
        'field117': 'field117_1',  // Effective Radiated Power
        'field118': 'field118_1',  // Power/ERP Augmentation

        // Time/Date Information
        'field130': 'field130',    // Time ✅ (works) per MCEB Pub 7
        'field131': 'field131',    // Percent Time (required for EUCOM Germany)
        'field140': 'field140',    // Required Date (YYYYMMDD)
        'field141': 'field141',    // Expiration Date (required for CENTCOM)
        'field142': 'field142',    // Review Date
        'field143': 'field143',    // Revision Date
        'field144': 'field144',    // Approval Authority

        // Organizational Information
        'field200': 'field200',    // Agency (USAF, USA, USN, USMC, USCG)
        'field201': 'field201',    // Unified Command
        'field202': 'field202',    // Unified Command Service
        'field204': 'field204',    // Command
        'field205': 'field205',    // Subcommand
        'field206': 'field206',    // Installation Frequency Manager
        'field207': 'field207',    // Operating Unit
        'field209': 'field209',    // Area AFC/DoD AFC

        // Transmitter Location (Geographic codes A-Z per MCEB Pub 7 Annex E)
        'field300': 'field300',    // State/Country (A-Z geographic codes)
        'field301': 'field301',    // Antenna Location
        'field303': 'field303',    // Antenna Coordinates ✅ (auto-filled)
        'field306': 'field306',    // Authorized Radius

        // Transmitter Equipment (Dynamic entries per MCEB Pub 7 Annex D)
        'field340': 'field340_1',  // Equipment Nomenclature ✅
        'field343': 'field343_1',  // Equipment Certification ID ✅

        // Transmitter Antenna
        'field357': 'field357',    // Antenna Gain
        'field362': 'field362',    // Antenna Orientation
        'field363': 'field363',    // Antenna Polarization (V/H/C)
        'field373': 'field373',    // JSC Area Code (A-Z)

        // Receiver Location
        'field400': 'field400',    // State/Country (A-Z geographic codes)
        'field401': 'field401',    // Antenna Location
        'field403': 'field403',    // Antenna Coordinates ✅ (auto-filled)

        // Receiver Equipment (Dynamic entries)
        'field440': 'field440_1',  // Equipment Nomenclature ✅
        'field443': 'field443_1',  // Equipment Certification ID ✅

        // Receiver Antenna
        'field457': 'field457',    // Antenna Gain
        'field462': 'field462',    // Antenna Orientation
        'field463': 'field463',    // Antenna Polarization (V/H/C)
        'field473': 'field473',    // JSC Area Code (A/B/C/D)

        // Supplementary Details (Dynamic entries per MCEB Pub 7 Annex F & I)
        'field500': 'field500_1',  // IRAC Notes ✅ (C/E/L/P/S codes)
        'field501': 'field501_1',  // Notes/Comments ✅
        'field502': 'field502',    // Description of Requirement (required for CENTCOM)
        'field503': 'field503',    // Agency Free-text Comments
        'field511': 'field511',    // Major Function Identifier (Annex I)
        'field512': 'field512',    // Intermediate Function Identifier (Annex I)
        'field513': 'field513',    // Minor Function Identifier (new in 2005)
        'field520': 'field520',    // Supplementary Details

        // Other Assignment Identifiers
        'field716': 'field716',    // Usage Code
        'field801': 'field801',    // Coordination Data/Remarks
        'field803': 'field803',    // Requestor Data POC
        'field804': 'field804',    // Additional Assignment Data

        // Deprecated fields (no longer used by DoD per MCEB Pub 7)
        'field208': null,  // No longer required by Air Force
        'field407': null,  // No longer used by DoD
        'field470': null,  // No longer used by DoD
        'field471': null,  // No longer used by DoD
        'field472': null,  // No longer used by DoD
        'field903': null,  // No longer used by DoD

        // Fields that don't exist in SFAF standard
        'field101': null,  // Not in MCEB Pub 7 standard
        'field103': null,  // Additional serial numbers - not in form
        'field107': null,  // Date field - not in form
    };

    function setFieldValue(formFieldId, value) {
        if (!formFieldId || !value) return false;

        const field = document.getElementById(formFieldId);
        if (field) {
            field.value = value;
            field.dispatchEvent(new Event('change'));

            // // Trigger MCEB Pub 7 validation if field manager is available
            // if (window.sfafFieldManager) {
            //     window.sfafFieldManager.validateField(field);
            // }

            return true;
        }
        return false;
    }

    // Auto-populate coordinate fields from marker (field 303/403 per MCEB Pub 7)
    if (data.coordinates) {
        setFieldValue('field303', data.coordinates.compact);
        setFieldValue('field403', data.coordinates.compact);
    }

    // Populate SFAF fields using official MCEB Pub 7 mapping
    if (data.sfaf_fields) {
        let successCount = 0;
        let skippedCount = 0;
        let deprecatedCount = 0;
        let unknownCount = 0;

        Object.entries(data.sfaf_fields).forEach(([importedFieldId, value]) => {

            // Handle field500 variants (500/02, 500/03, etc.) per MCEB Pub 7 Annex F
            if (importedFieldId.startsWith('field500/')) {
                const parts = importedFieldId.split('/');
                if (parts.length === 2) {
                    const number = parseInt(parts[1]);
                    const targetFieldId = `field500_${number}`;

                    if (setFieldValue(targetFieldId, value)) {
                        successCount++;
                    }
                }
                return;
            }

            // Handle field103 variants (additional serial numbers per MCEB Pub 7)
            if (importedFieldId.startsWith('field103/')) {
                skippedCount++;
                return;
            }

            // Use official MCEB Pub 7 mapping
            const actualFieldId = sfafFieldMapping[importedFieldId];

            if (actualFieldId === null) {
                // Check if it's a deprecated field
                const deprecatedFields = ['field208', 'field407', 'field470', 'field471', 'field472', 'field903'];
                if (deprecatedFields.includes(importedFieldId)) {
                    deprecatedCount++;
                } else {
                    skippedCount++;
                }
            } else if (actualFieldId) {
                if (setFieldValue(actualFieldId, value)) {
                    successCount++;
                }
            } else {
                // Try the original field ID as fallback
                if (setFieldValue(importedFieldId, value)) {
                    successCount++;
                } else {
                    unknownCount++;
                }
            }
        });

        // Generate MCEB Pub 7 compliance summary
        console.log(`📊 MCEB Publication 7 Import Results:`);
        console.log(`  ✅ Successfully populated: ${successCount} fields`);
        console.log(`  ⚠️ Skipped (not in form): ${skippedCount} fields`);
        console.log(`  🔄 Deprecated (MCEB Pub 7): ${deprecatedCount} fields`);
        console.log(`  ❓ Unknown fields: ${unknownCount} fields`);
        console.log(`  📖 Reference: MCEB Publication 7, June 30, 2005`);

        // Show compliance notification
        if (successCount > 0) {
            showComplianceNotification(successCount, skippedCount + deprecatedCount + unknownCount);
        }
    }
}

// Show MCEB Pub 7 compliance notification
function showComplianceNotification(successCount, totalSkipped) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #2196F3, #1976D2);
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
        z-index: 10000;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 500px;
        text-align: center;
    `;

    notification.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 8px;">
            📖 MCEB Publication 7 Compliance
        </div>
        <div style="font-size: 0.9em; opacity: 0.95;">
            ${successCount} fields populated successfully<br>
            ${totalSkipped} fields skipped (deprecated/not applicable)<br>
            <strong>Standard: MCEB Pub 7, June 30, 2005</strong>
        </div>
    `;

    document.body.appendChild(notification);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(-50%) translateY(-20px)';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}



function setupAuthorizationRadius() {
    const field306 = document.getElementById('field306');
    if (!field306) return;

    // Remove existing event listeners to prevent duplicates
    const newField306 = field306.cloneNode(true);
    field306.parentNode.replaceChild(newField306, field306);

    // Add change listener to field 306
    newField306.addEventListener('input', async () => {
        const radiusValue = newField306.value.trim();

        if (radiusValue && window.currentSFAFMarker) {
            try {
                await createAuthorizationCircle(radiusValue);
            } catch (error) {
                console.error('Failed to create authorization circle:', error);
            }
        } else {
            removeAuthorizationCircle();
        }
    });
}

// if (!window.log) {
//     window.log = function (...args) {
//         console.log(...args);
//     };
// }

async function openSidebar(markerId) {
    try {
        const response = await fetch(`/api/sfaf/object/${markerId}`);
        const data = await response.json();

        if (data.success) {
            openPersistentSidebar();
            const objectTab = document.getElementById('objectTab');
            if (objectTab) {
                objectTab.style.display = 'block';
            }
            switchTab('object');
            populateExistingSFAFForm(data);
        } else {
            console.error('Failed to fetch SFAF data:', data.error);
        }
    } catch (error) {
        console.error('Error fetching SFAF data:', error);
    }
}

// Authorization circle management
let authorizationCircle = null;

async function createAuthorizationCircle(radiusValue) {
    if (!window.currentSFAFMarker) return;

    // Remove existing circle
    removeAuthorizationCircle();

    try {
        // Parse radius (remove B/T suffixes)
        const numericRadius = parseFloat(radiusValue.replace(/[BT]/gi, ''));
        if (isNaN(numericRadius) || numericRadius <= 0) return;

        // Create circle
        authorizationCircle = L.circle(
            [window.currentSFAFMarker.lat, window.currentSFAFMarker.lng],
            {
                radius: numericRadius * 1000, // Convert km to meters
                color: '#ff6b6b',
                fillColor: '#ff6b6b',
                fillOpacity: 0.1,
                opacity: 0.6,
                weight: 2,
                dashArray: '5, 5'
            }
        ).addTo(map);

        authorizationCircle.bindTooltip(
            `<b>Authorization Radius</b><br>
             Radius: ${numericRadius} km<br>
             Field 306: ${radiusValue}`,
            { permanent: false }
        );

    } catch (error) {
        console.error('Failed to create authorization circle:', error);
    }
}

function removeAuthorizationCircle() {
    if (authorizationCircle) {
        map.removeLayer(authorizationCircle);
        authorizationCircle = null;
    }
}

function setupCoordinateSync() {
    // This will be called when markers are dragged to update fields 303 and 403
    window.updateSidebarCoordinates = function (coordinates) {
        const field303 = document.getElementById('field303');
        const field403 = document.getElementById('field403');

        if (field303 && coordinates.compact) {
            field303.value = coordinates.compact;
        }
        if (field403 && coordinates.compact) {
            field403.value = coordinates.compact;
        }
    };
}

function wireUpActionButtons() {
    // Override your existing button handlers to use Go APIs
    const validateBtn = document.getElementById('validateSFAFBtn');
    const saveBtn = document.getElementById('saveSFAFBtn');
    const exportBtn = document.getElementById('exportSFAFBtn');
    const deleteBtn = document.getElementById('deleteSFAFBtn');

    if (validateBtn) {
        validateBtn.onclick = validateSFAFWithGo;
    }

    if (saveBtn) {
        saveBtn.onclick = saveSFAFWithGo;
    }

    if (exportBtn) {
        exportBtn.onclick = exportSFAFWithGo;
    }

    if (deleteBtn) {
        deleteBtn.onclick = deleteSFAFWithGo;
    }
}

// SFAF action functions that work with your existing form
async function validateSFAFWithGo() {
    const formData = collectSFAFFormData();

    try {
        const response = await fetch('/api/sfaf/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fields: formData })
        });

        const result = await response.json();

        if (result.success) {
            applySFAFValidationResults(result.validation);
            showSFAFStatusMessage(
                result.validation.is_valid ? '✅ Form validation passed!' : '❌ Form has validation errors',
                result.validation.is_valid ? 'success' : 'error'
            );
        }
    } catch (error) {
        console.error('Validation failed:', error);
        showSFAFStatusMessage('❌ Validation failed. Please try again.', 'error');
    }
}

async function saveSFAFWithGo() {
    if (!window.currentSFAFMarker) {
        showSFAFStatusMessage('❌ No marker selected', 'error');
        return;
    }

    const formData = collectSFAFFormData();

    try {
        const response = await fetch('/api/sfaf', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                marker_id: window.currentSFAFMarker.id,
                fields: formData
            })
        });

        const result = await response.json();

        if (result.success) {
            showSFAFStatusMessage('✅ SFAF data saved successfully!', 'success');
        } else {
            showSFAFStatusMessage('❌ Failed to save: ' + (result.error || 'Unknown error'), 'error');
        }
    } catch (error) {
        console.error('Save failed:', error);
        showSFAFStatusMessage('❌ Save failed. Please try again.', 'error');
    }
}

async function exportSFAFWithGo() {
    if (!window.currentSFAFMarker) {
        showSFAFStatusMessage('❌ No marker selected', 'error');
        return;
    }

    const formData = collectSFAFFormData();

    const exportData = {
        marker: window.currentSFAFMarker,
        sfaf_fields: formData,
        exported_at: new Date().toISOString(),
        format: 'SFAF_JSON_v1.0'
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });

    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `SFAF_${window.currentSFAFMarker.serial}_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
    showSFAFStatusMessage('📤 SFAF data exported successfully!', 'success');
}

async function deleteSFAFWithGo() {
    if (!window.currentSFAFMarker) {
        showSFAFStatusMessage('❌ No marker selected', 'error');
        return;
    }

    if (confirm(`Delete marker ${window.currentSFAFMarker.serial} and all associated SFAF data?\n\nThis action cannot be undone.`)) {
        try {
            const response = await fetch(`/api/markers/${window.currentSFAFMarker.id}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                // Remove marker from map
                const marker = markers.get(window.currentSFAFMarker.id);
                if (marker) {
                    map.removeLayer(marker);
                    markers.delete(window.currentSFAFMarker.id);
                }

                // Remove authorization circle
                removeAuthorizationCircle();

                // Close sidebar
                closePersistentSidebar();

                showSFAFStatusMessage('✅ Object deleted successfully!', 'success');

                // Clear current marker reference
                window.currentSFAFMarker = null;
            } else {
                showSFAFStatusMessage('❌ Failed to delete object', 'error');
            }
        } catch (error) {
            console.error('Delete failed:', error);
            showSFAFStatusMessage('❌ Delete failed. Please try again.', 'error');
        }
    }
}

function collectSFAFFormData() {
    const formData = {};

    // Get the object tab container
    const objectTab = document.getElementById('tab-object');
    if (!objectTab) {
        console.warn('Object tab not found, collecting from entire document');
        // Fallback to collecting from entire document
        const allFields = document.querySelectorAll('input[id^="field"], select[id^="field"], textarea[id^="field"]');
        allFields.forEach(field => {
            if (field.value && field.value.trim() !== '') {
                formData[field.id] = field.value.trim();
            }
        });
        return formData;
    }

    // Collect from various field patterns in the object tab
    const patterns = [
        'input[id^="field"]',
        'select[id^="field"]',
        'textarea[id^="field"]',
        '[data-field]',
        'input[name^="field"]',
        'select[name^="field"]',
        'textarea[name^="field"]'
    ];

    patterns.forEach(pattern => {
        const fields = objectTab.querySelectorAll(pattern);
        fields.forEach(field => {
            let fieldId = field.id;

            // Handle data-field attributes
            if (field.dataset.field && !fieldId.startsWith('field')) {
                fieldId = 'field' + field.dataset.field;
            }

            // Handle name attributes
            if (!fieldId && field.name) {
                fieldId = field.name;
            }

            if (fieldId && field.value && field.value.trim() !== '') {
                formData[fieldId] = field.value.trim();
            }
        });
    });

    return formData;
}

function applySFAFValidationResults(validation) {
    // Clear previous validation styles
    const objectTab = document.getElementById('tab-object');
    const fieldsToCheck = objectTab ?
        objectTab.querySelectorAll('input, select, textarea') :
        document.querySelectorAll('input[id^="field"], select[id^="field"], textarea[id^="field"]');

    fieldsToCheck.forEach(field => {
        field.style.borderColor = '';
        field.classList.remove('validation-error', 'validation-success');

        // Remove any existing validation messages
        const existingMsg = field.parentNode?.querySelector('.validation-message');
        if (existingMsg) {
            existingMsg.remove();
        }
    });

    // Apply validation results
    if (validation.fields) {
        Object.entries(validation.fields).forEach(([fieldId, fieldData]) => {
            const field = findFieldByAnyMeans(fieldId);

            if (field) {
                const hasError = validation.errors && validation.errors[fieldId];
                const hasValue = fieldData.value && fieldData.value.trim() !== '';

                if (hasError) {
                    field.style.borderColor = '#f44336';
                    field.classList.add('validation-error');

                    // Add error message
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'validation-message';
                    errorMsg.style.cssText = 'color: #f44336; font-size: 12px; margin-top: 2px;';
                    errorMsg.textContent = validation.errors[fieldId];
                    if (field.parentNode) {
                        field.parentNode.appendChild(errorMsg);
                    }

                } else if (hasValue) {
                    field.style.borderColor = '#4CAF50';
                    field.classList.add('validation-success');
                }
            }
        });
    }
}

function manageObjectTabVisibility(hasSelectedMarker = false) {
    const objectTab = document.getElementById('objectTab');
    const objectTabBtn = document.querySelector('[data-tab="object"]');

    if (objectTab && objectTabBtn) {
        if (hasSelectedMarker) {
            // Show Object tab when marker is selected
            objectTab.style.display = 'block';
            objectTabBtn.style.display = 'block';
        } else {
            // Hide Object tab when no marker is selected
            objectTab.style.display = 'none';
            objectTabBtn.style.display = 'none';

            // Switch to a default tab if Object tab was active
            if (objectTabBtn.classList.contains('active')) {
                switchTab('default'); // or whatever your default tab is
            }
        }
    }
}

function findFieldByAnyMeans(fieldId) {
    // Try multiple strategies to find the field
    let field = document.getElementById(fieldId);

    if (!field) {
        const fieldNumber = fieldId.replace('field', '');
        field = document.querySelector(`[data-field="${fieldNumber}"]`);
    }

    if (!field) {
        field = document.querySelector(`[name="${fieldId}"]`);
    }

    if (!field) {
        // Try partial matches
        field = document.querySelector(`[id*="${fieldId}"]`);
    }

    return field;
}

// Add to Overview tab functionality
async function clearAllMarkers() {
    try {
        // Show confirmation dialog
        if (!confirm('Delete all markers and associated SFAF data?\n\nThis action cannot be undone.')) {
            return;
        }

        // Call backend bulk delete API
        const response = await fetch('/api/markers', {
            method: 'DELETE'
        });

        if (response.ok) {
            const result = await response.json();
            console.log('✅ Backend response:', result.message);

            // ===== COMPREHENSIVE FRONTEND STATE CLEANUP =====

            // 1. Clear markers Map (Source: map.txt pattern)
            if (window.markers) {
                window.markers.clear();
                console.log('✅ Markers Map cleared');
            }

            // 2. Clear drawnItems layer group (Source: map.txt pattern)
            if (window.drawnItems) {
                window.drawnItems.clearLayers();
                console.log('✅ DrawnItems layers cleared');
            }

            // 3. Remove ALL marker layers directly from map
            map.eachLayer(function (layer) {
                // Remove all marker instances (manual and imported)
                if (layer instanceof L.Marker) {
                    map.removeLayer(layer);
                }
            });
            console.log('✅ All marker layers removed from map');

            // 4. Clear coordinate cache (Source: map.txt)
            if (window.coordinateCache) {
                window.coordinateCache.clear();
                console.log('✅ Coordinate cache cleared');
            }

            // 5. Clear current marker references
            window.currentSelectedMarker = null;
            if (window.currentSFAFMarker) {
                window.currentSFAFMarker = null;
            }
            console.log('✅ Current marker references cleared');

            // 6. Close sidebar if open (Source: map.txt)
            closePersistentSidebar();

            // 7. Force map redraw
            map.invalidateSize();

            // 8. Show success notification (Source: buttonFunctions.txt pattern)
            showNotification('✅ All markers cleared successfully', 'success');

            return true;

        } else {
            throw new Error(`HTTP ${response.status}`);
        }

    } catch (error) {
        console.error('Failed to clear all markers:', error);
        showNotification('❌ Failed to clear markers', 'error');
        return false;
    }
}

function showSFAFStatusMessage(message, type) {
    // Remove any existing status messages
    const existing = document.querySelectorAll('.sfaf-status-message');
    existing.forEach(msg => msg.remove());

    // Create status message
    const statusDiv = document.createElement('div');
    statusDiv.className = 'sfaf-status-message';
    statusDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 470px;
        background: ${type === 'success' ? '#4CAF50' : '#f44336'};
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        z-index: 2000;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        max-width: 300px;
    `;
    statusDiv.textContent = message;
    document.body.appendChild(statusDiv);

    setTimeout(() => statusDiv.remove(), 4000);
}

function openSidebar() {
    const sidebar = document.getElementById('sidebar');
    if (sidebar) {
        sidebar.classList.add('open');
    }
}


// Load existing markers when page loads
document.addEventListener('DOMContentLoaded', function () {
    loadExistingMarkers();
});

// Make functions globally available
window.openSidebar = openSidebar;
window.openPersistentSidebar = openPersistentSidebar;
window.closePersistentSidebar = closePersistentSidebar;
window.switchTab = switchTab;
window.clearAllMarkers = clearAllMarkers;// sfaf-export-import.js - SFAF Export/Import Functionality
// MCEB Publication 7 compliant export and import operations

class SFAFExportImport {
    constructor(fieldSpecs) {
        this.fieldSpecs = fieldSpecs;
    }

    // Export methods from sources
    exportCompleteFormattedSFAF() {
        const formData = this.collectFormData();
        const sfafLines = [];

        // MCEB Pub 7 standard header
        sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
        sfafLines.push('MCEB Publication 7, June 30, 2005');
        sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);
        sfafLines.push(`System: SFAF Plotter - Go Edition v1.0`);
        sfafLines.push('');

        // Export all fields in proper MCEB order
        const fieldOrder = [
            '005', '010', '013', '019', '102', '701', '702',
            '110', '113', '114', '115', '116', '117', '118',
            '130', '131', '140', '141', '142', '143', '144',
            '200', '201', '202', '204', '205', '206', '207', '208', '209',
            '300', '301', '303', '306',
            '340', '343', '357', '362', '363', '373',
            '400', '401', '403', '407',
            '440', '443', '457', '462', '463', '470', '471', '472', '473',
            '500', '501', '502', '503', '511', '512', '513', '520',
            '716', '801', '803', '804', '903'
        ];

        fieldOrder.forEach(fieldNum => {
            const fieldId = `field${fieldNum}`;
            const data = formData[fieldId];

            if (data) {
                if (Array.isArray(data)) {
                    data.forEach((value, index) => {
                        if (index === 0) {
                            sfafLines.push(`${fieldNum}. ${value}`);
                        } else {
                            const occurrence = (index + 1).toString().padStart(2, '0');
                            sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                        }
                    });
                } else {
                    sfafLines.push(`${fieldNum}. ${data}`);
                }
            }
        });

        sfafLines.push('');
        sfafLines.push('***** END OF SFAF RECORD *****');

        return sfafLines.join('\n');
    }

    exportFinalSFAFRecord() {
        const formData = this.collectFormData();
        const sfafLines = [];

        // MCEB Pub 7 standard header
        sfafLines.push('***** STANDARD FREQUENCY ACTION FORMAT (SFAF) *****');
        sfafLines.push('MCEB Publication 7, June 30, 2005');
        sfafLines.push(`Generated: ${new Date().toISOString().split('T')[0]}`);

        // Export in official MCEB field order
        const fieldOrder = [
            '005', '010', '013', '019', '102', '701', '702',
            '110', '113', '114', '115', '116', '117', '118',
            // ... complete field order
        ];

        // Handle multiple occurrences properly
        fieldOrder.forEach(fieldNum => {
            const data = formData[`field${fieldNum}`];
            if (Array.isArray(data)) {
                data.forEach((value, index) => {
                    if (index === 0) {
                        sfafLines.push(`${fieldNum}. ${value}`);
                    } else {
                        const occurrence = (index + 1).toString().padStart(2, '0');
                        sfafLines.push(`${fieldNum}/${occurrence}. ${value}`);
                    }
                });
            }
        });

        return sfafLines.join('\n');
    }

    generateComplianceReport() {
        const formData = this.collectFormData();
        const report = [];

        report.push('MCEB Publication 7 Compliance Report');
        report.push('====================================');
        report.push(`Generated: ${new Date().toLocaleString()}`);
        report.push('');

        // Check required fields per MCEB Pub 7
        const requiredFields = {
            'field005': 'Security Classification',
            'field010': 'Type of Action',
            'field102': 'Agency Serial Number',
            'field110': 'Frequency(ies)',
            'field113': 'Station Class',
            'field114': 'Emission Designator',
            'field115': 'Transmitter Power',
            'field200': 'Agency',
            'field300': 'State/Country (TX)',
            'field301': 'Antenna Location (TX)',
            'field303': 'Antenna Coordinates (TX)',
            'field400': 'State/Country (RX)',
            'field401': 'Antenna Location (RX)',
            'field403': 'Antenna Coordinates (RX)'
        };

        let missingRequired = 0;
        let presentRequired = 0;

        Object.entries(requiredFields).forEach(([fieldId, title]) => {
            const value = formData[fieldId] || (Array.isArray(formData[fieldId]) ? formData[fieldId][0] : null);
            if (value) {
                presentRequired++;
            } else {
                missingRequired++;
                report.push(`❌ MISSING REQUIRED: ${fieldId} - ${title}`);
            }
        });

        report.push('');
        report.push(`Required Fields Status: ${presentRequired}/${presentRequired + missingRequired} complete`);
        report.push('');

        // Check field occurrence limits
        let exceedsLimits = 0;
        Object.keys(this.fieldSpecs).forEach(baseFieldId => {
            const spec = this.fieldSpecs[baseFieldId];
            if (spec.dynamic) {
                const values = formData[baseFieldId];
                if (Array.isArray(values) && values.length > spec.maxOccurrences) {
                    exceedsLimits++;
                    report.push(`⚠️ EXCEEDS LIMIT: ${baseFieldId} has ${values.length} occurrences (max: ${spec.maxOccurrences})`);
                }
            }
        });

        if (exceedsLimits === 0) {
            report.push('✅ All field occurrence limits compliant with MCEB Pub 7');
        }

        report.push('');
        report.push(`Overall Compliance: ${missingRequired === 0 && exceedsLimits === 0 ? 'COMPLIANT' : 'NON-COMPLIANT'}`);

        return report.join('\n');
    }

    // Import methods
    parseImportedSFAF(importText) {
        const lines = importText.split('\n');
        const fieldData = {};

        // Define auto-generated fields to skip during import
        const autoGeneratedFields = [
            '103', '107', '117', '118', '373', '402', '473', '901', '904', '911', '924', '927', '928', '956'
        ];

        lines.forEach(line => {
            // Ignore computer-generated content
            if (this.isComputerGenerated(line)) {
                return;
            }

            // Parse field data
            const fieldMatch = line.match(/^(\d{3})(?:\/\d{2})?\.?\s*(.+)$/);
            if (fieldMatch) {
                const fieldNum = fieldMatch[1];
                const fieldValue = fieldMatch[2].trim();

                // Skip auto-generated fields
                if (autoGeneratedFields.includes(fieldNum)) {
                    this.log(`⚠️ Skipping auto-generated field ${fieldNum}: ${fieldValue}`);
                    return;
                }

                // Store only manually-entered field data
                if (!fieldData[`field${fieldNum}`]) {
                    fieldData[`field${fieldNum}`] = [];
                }
                fieldData[`field${fieldNum}`].push(fieldValue);
            }
        });

        return fieldData;
    }
    populateFormFromData(formData) {
        Object.keys(formData).forEach(fieldId => {
            const value = formData[fieldId];

            if (Array.isArray(value)) {
                // Handle dynamic fields
                value.forEach((val, index) => {
                    const field = document.getElementById(`${fieldId}_${index + 1}`);
                    if (field) {
                        field.value = val;
                    } else if (index > 0) {
                        // Create additional occurrences if needed
                        this.addFieldOccurrence(fieldId, this.fieldSpecs[fieldId]);
                        const newField = document.getElementById(`${fieldId}_${index + 1}`);
                        if (newField) newField.value = val;
                    }
                });
            } else {
                // Handle single fields
                const field = document.getElementById(fieldId);
                if (field) field.value = value;
            }
        });
    }

    mapImportedFieldId(importedFieldId) {
        const fieldMappings = {
            'security_classification': 'field005',
            'type_of_action': 'field010',
            'agency_serial': 'field102',
            'frequency': 'field110_1',
            'station_class': 'field113_1',
            'emission': 'field114_1',
            'power': 'field115_1',
            'agency': 'field200',
            'tx_state': 'field300',
            'tx_location': 'field301',
            'tx_coordinates': 'field303',
            'rx_state': 'field400',
            'rx_location': 'field401',
            'rx_coordinates': 'field403'
        };

        return fieldMappings[importedFieldId] || null;
    }

    processField500Variants(importedFieldId, value) {
        if (importedFieldId.startsWith('500/')) {
            const occurrence = importedFieldId.split('/')[1];
            const targetFieldId = `field500_${parseInt(occurrence)}`;

            if (setFieldValue(targetFieldId, value)) {
                return { success: true };
            } else {
                // Create dynamic occurrence if needed
                sfafFieldManager.addFieldOccurrence('field500', sfafFieldManager.fieldSpecs['field500']);
                return { success: setFieldValue(targetFieldId, value) };
            }
        }
        return { success: false };
    }
}

// Utility functions from sources
function downloadSFAF(sfafData, filename = 'sfaf_record.txt') {
    // Implementation from sources
}

function populateCoordinatesFromMap(data) {
    // Implementation from sources
}// sfaf-state-manager.js - SFAF Form State Management
// Auto-save, restore, and state management functionality

class SFAFStateManager {
    constructor() {
        this.autoSaveInterval = null;
        this.debounceTimeout = null;
    }

    // State management methods from sources
    saveFormState() {
        const formData = this.collectFormData();
        const stateData = {
            formData: formData,
            timestamp: new Date().toISOString(),
            version: 'MCEB_PUB_7_2005'
        };
        localStorage.setItem('sfafFormState', JSON.stringify(stateData));
        this.log('💾 SFAF form state saved');
    }

    restoreFormState() {
        const savedState = localStorage.getItem('sfafFormState');
        if (savedState) {
            try {
                const stateData = JSON.parse(savedState);
                this.populateFormFromData(stateData.formData);
                this.log('🔄 SFAF form state restored from', stateData.timestamp);
                return true;
            } catch (error) {
                this.error('❌ Error restoring form state:', error);
                return false;
            }
        }
        return false;
    }

    enableAutoSave(intervalMinutes = 5) {
        setInterval(() => {
            this.saveFormState();
        }, intervalMinutes * 60000);

        // Save on form changes
        document.addEventListener('input', this.debounce(() => {
            this.saveFormState();
        }, 2000));

        this.log(`💾 Auto-save enabled every ${intervalMinutes} minutes`); // Fixed line
    }

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    collectFormData() {
        const formData = {};

        Object.keys(this.fieldSpecs).forEach(baseFieldId => {
            const spec = this.fieldSpecs[baseFieldId];

            if (spec.dynamic) {
                // Collect dynamic field data
                const values = [];
                for (let i = 1; i <= spec.maxOccurrences; i++) {
                    const field = document.getElementById(`${baseFieldId}_${i}`);
                    if (field && field.value.trim()) {
                        values.push(field.value.trim());
                    }
                }
                if (values.length > 0) {
                    formData[baseFieldId] = values;
                }
            } else {
                // Collect single field data
                const field = document.getElementById(baseFieldId);
                if (field && field.value.trim()) {
                    formData[baseFieldId] = field.value.trim();
                }
            }
        });

        return formData;
    }
}// sfaf-utilities.js - SFAF Utility Functions
// Helper functions and utilities for SFAF Field Manager

// Notification system from sources
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    const colors = {
        success: { bg: '#d4edda', border: '#c3e6cb', text: '#155724' },
        error: { bg: '#f8d7da', border: '#f5c6cb', text: '#721c24' },
        info: { bg: '#d1ecf1', border: '#bee5eb', text: '#0c5460' }
    };

    const color = colors[type];
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${color.bg};
        color: ${color.text};
        border: 1px solid ${color.border};
        padding: 10px 15px;
        border-radius: 4px;
        z-index: 10000;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => notification.remove(), 3000);
}

function setFieldValue(formFieldId, value) {
    if (!formFieldId || !value) return false;

    const field = document.getElementById(formFieldId);
    if (field) {
        this.log(`✅ Setting ${formFieldId} = ${value}`);
        field.value = value;
        field.dispatchEvent(new Event('change'));

        // Trigger MCEB Pub 7 validation if field manager is available
        if (window.sfafFieldManager) {
            window.sfafFieldManager.validateField(field);
        }

        return true;
    }
    return false;
}

// Setup global keyboard shortcuts for SFAF operations
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // Ctrl+S: Save form state
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            sfafFieldManager.saveFormState();
            showNotification('Form state saved', 'success');
        }

        // Ctrl+E: Export SFAF
        if (e.ctrlKey && e.key === 'e') {
            e.preventDefault();
            const sfafData = sfafFieldManager.exportFinalSFAFRecord();
            downloadSFAF(sfafData);
        }

        // Ctrl+V: Validate form
        if (e.ctrlKey && e.key === 'v') {
            e.preventDefault();
            sfafFieldManager.validateEntireForm();
        }
    });

    // Show initialization errors
    function showInitializationError(error) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #f8d7da;
        color: #721c24;
        padding: 15px 20px;
        border-radius: 8px;
        border: 1px solid #f5c6cb;
        z-index: 10000;
        font-family: monospace;
    `;
        errorDiv.innerHTML = `
        <strong>❌ SFAF Manager Initialization Failed</strong><br>
        ${error.message}<br>
        <small>Check console for details</small>
    `;
        document.body.appendChild(errorDiv);
    }

    function updateCharacterCounter(field, maxLength) {
        let counter = field.parentNode.querySelector('.char-counter');
        if (!counter) {
            counter = document.createElement('div');
            counter.className = 'char-counter';
            counter.style.cssText = `
            font-size: 0.8em;
            color: #666;
            text-align: right;
            margin-top: 2px;
            font-family: monospace;
        `;
            field.parentNode.appendChild(counter);
        }

        const remaining = maxLength - field.value.length;
        counter.textContent = `${field.value.length}/${maxLength}`;

        // Color coding based on remaining characters
        if (remaining < 5) {
            counter.style.color = '#dc3545';  // Red when near limit
        } else if (remaining < 20) {
            counter.style.color = '#ffc107';  // Yellow when approaching limit
        } else {
            counter.style.color = '#666';     // Gray when safe
        }
    }

    // clearAllFields function (missing from sources - needs to be implemented)
    function clearAllFields() {
        // Clear all SFAF fields based on fieldSpecs
        Object.keys(this.fieldSpecs).forEach(baseFieldId => {
            const spec = this.fieldSpecs[baseFieldId];

            if (spec.dynamic) {
                // Clear dynamic fields (multiple occurrences)
                for (let i = 1; i <= spec.maxOccurrences; i++) {
                    const field = document.getElementById(`${baseFieldId}_${i}`);
                    if (field) {
                        field.value = '';
                        this.clearFieldErrors(field);
                    }
                }
            } else {
                // Clear single occurrence fields
                const field = document.getElementById(baseFieldId);
                if (field) {
                    field.value = '';
                    this.clearFieldErrors(field);
                }
            }
        });

        // Clear any validation summaries
        const validationSummaries = document.querySelectorAll('.validation-summary');
        validationSummaries.forEach(summary => summary.remove());

        console.log('✅ All SFAF fields cleared');
    }
}// sfaf-compliance.js - MCEB Publication 7 Compliance Functions
// Compliance checking and validation per official standards

class SFAFCompliance {
    constructor(fieldSpecs, referenceData) {
        this.fieldSpecs = fieldSpecs;
        this.referenceData = referenceData;
    }

    /**
    // Validate occurrence limits for dynamic fields
     */
    validateOccurrenceLimits(baseFieldId) {
        const spec = this.fieldSpecs[baseFieldId];
        if (!spec || !spec.dynamic) return true;

        // Count existing occurrences
        const occurrences = document.querySelectorAll(`[id^="${baseFieldId}_"]`);
        const currentCount = occurrences.length;

        if (currentCount > spec.maxOccurrences) {
            const errorMsg = `Maximum ${spec.maxOccurrences} occurrences allowed for ${spec.title} per MCEB Pub 7`;
            console.error(errorMsg);
            return false;
        }

        return true;
    }

    /**
     * Validate required fields per MCEB Publication 7 standards
     * @returns {Object} Validation results with missing fields and status
     */
    validateRequiredFields() {
        const missingFields = [];
        const presentFields = [];

        // Required fields per MCEB Pub 7 (Source: MCEB Publication 7 (1 November 2018).pdf)
        const requiredFields = {
            // Administrative Data - Mandatory per MCEB Pub 7
            'field005': {
                title: 'Security Classification',
                description: 'Overall security classification of the frequency proposal',
                required: true,
                source: 'MCEB Pub 7 Data Item 005'
            },
            'field010': {
                title: 'Type of Action',
                description: 'Type of action required to process the frequency assignment',
                required: true,
                source: 'MCEB Pub 7 Data Item 010'
            },
            'field102': {
                title: 'Agency Serial Number',
                description: 'Primary FRRS record identifier',
                required: true,
                source: 'MCEB Pub 7 Data Item 102'
            },

            // Emission Characteristics - Required per MCEB Pub 7
            'field110': {
                title: 'Frequency(ies)',
                description: 'Frequency band or discrete frequency assigned',
                required: true,
                source: 'MCEB Pub 7 Data Item 110'
            },
            'field113': {
                title: 'Station Class',
                description: 'Station class designation per MCEB Pub 7 Annex A',
                required: true,
                source: 'MCEB Pub 7 Data Item 113'
            },
            'field114': {
                title: 'Emission Designator',
                description: 'ITU emission designator per MCEB Pub 7 Annex B',
                required: true,
                source: 'MCEB Pub 7 Data Item 114'
            },
            'field115': {
                title: 'Transmitter Power',
                description: 'Transmitter power in appropriate units',
                required: true,
                source: 'MCEB Pub 7 Data Item 115'
            },

            // Organizational Information - Required per MCEB Pub 7
            'field200': {
                title: 'Agency',
                description: 'Department of Defense agency identifier',
                required: true,
                source: 'MCEB Pub 7 Data Item 200'
            },

            // Transmitter Location - Required per MCEB Pub 7
            'field300': {
                title: 'State/Country (TX)',
                description: 'Transmitter state/country location',
                required: true,
                source: 'MCEB Pub 7 Data Item 300'
            },
            'field301': {
                title: 'Antenna Location (TX)',
                description: 'Transmitter antenna location name',
                required: true,
                source: 'MCEB Pub 7 Data Item 301'
            },
            'field303': {
                title: 'Antenna Coordinates (TX)',
                description: 'Transmitter antenna coordinates in MCEB format',
                required: true,
                source: 'MCEB Pub 7 Data Item 303'
            },

            // Receiver Location - Required per MCEB Pub 7
            'field400': {
                title: 'State/Country (RX)',
                description: 'Receiver state/country location',
                required: true,
                source: 'MCEB Pub 7 Data Item 400'
            },
            'field401': {
                title: 'Antenna Location (RX)',
                description: 'Receiver antenna location name',
                required: true,
                source: 'MCEB Pub 7 Data Item 401'
            },
            'field403': {
                title: 'Antenna Coordinates (RX)',
                description: 'Receiver antenna coordinates in MCEB format',
                required: true,
                source: 'MCEB Pub 7 Data Item 403'
            }
        };

        // Additional required fields for specific circumstances
        const conditionalRequiredFields = {
            // Required for Air Force assignments per MCEB Pub 7
            'field701': {
                title: 'Frequency Action Officer',
                description: 'MILDEP code identifying responsible person/group',
                condition: () => {
                    const agency = document.getElementById('field200')?.value;
                    return agency === 'USAF';
                },
                source: 'MCEB Pub 7 Data Item 701'
            },

            // Required for all DoD assignments per MCEB Pub 7
            'field716': {
                title: 'Usage Code',
                description: 'Coded entry denoting usage and category of circuits',
                condition: () => true, // Always required for DoD
                source: 'MCEB Pub 7 Data Item 716'
            },

            // Required field per MCEB Pub 7
            'field803': {
                title: 'Point of Contact',
                description: 'Person validating assignment data correctness',
                condition: () => true, // Always required
                source: 'MCEB Pub 7 Data Item 803'
            },

            // Required field per MCEB Pub 7
            'field144': {
                title: 'Approval Authority Indicator',
                description: 'Indicates whether assignment processed for IRAC approval',
                condition: () => true, // Required on all DoD transactions
                source: 'MCEB Pub 7 Data Item 144'
            }
        };

        // Check primary required fields
        Object.entries(requiredFields).forEach(([fieldId, fieldInfo]) => {
            // Handle dynamic fields (e.g., field110_1, field113_1)
            let field = document.getElementById(fieldId);
            if (!field && this.fieldSpecs[fieldId]?.dynamic) {
                field = document.getElementById(`${fieldId}_1`);
            }

            const value = field?.value?.trim();

            if (!value) {
                missingFields.push({
                    fieldId: fieldId,
                    title: fieldInfo.title,
                    description: fieldInfo.description,
                    source: fieldInfo.source,
                    severity: 'critical'
                });

                // Visual indication of missing required field
                if (field) {
                    field.style.borderColor = '#dc3545';
                    field.style.borderWidth = '2px';
                }
            } else {
                presentFields.push({
                    fieldId: fieldId,
                    title: fieldInfo.title,
                    value: value
                });

                // Clear error styling if field is now filled
                if (field) {
                    field.style.borderColor = '';
                    field.style.borderWidth = '';
                }
            }
        });

        // Check conditional required fields
        Object.entries(conditionalRequiredFields).forEach(([fieldId, fieldInfo]) => {
            if (fieldInfo.condition()) {
                const field = document.getElementById(fieldId);
                const value = field?.value?.trim();

                if (!value) {
                    missingFields.push({
                        fieldId: fieldId,
                        title: fieldInfo.title,
                        description: fieldInfo.description,
                        source: fieldInfo.source,
                        severity: 'required'
                    });

                    if (field) {
                        field.style.borderColor = '#ffc107';
                        field.style.borderWidth = '2px';
                    }
                } else {
                    presentFields.push({
                        fieldId: fieldId,
                        title: fieldInfo.title,
                        value: value
                    });
                }
            }
        });

        // Generate validation summary
        const validationResult = {
            isValid: missingFields.length === 0,
            totalRequired: Object.keys(requiredFields).length +
                Object.keys(conditionalRequiredFields).filter(id => conditionalRequiredFields[id].condition()).length,
            presentCount: presentFields.length,
            missingCount: missingFields.length,
            missingFields: missingFields,
            presentFields: presentFields,
            compliance: {
                mcebPub7: missingFields.length === 0 ? 'COMPLIANT' : 'NON-COMPLIANT',
                timestamp: new Date().toISOString(),
                version: 'MCEB Publication 7 (1 November 2018)'
            }
        };

        console.log(`📋 Required Fields Validation: ${presentFields.length}/${validationResult.totalRequired} complete`);

        return validationResult;
    }
    /**
     * Generate detailed MCEB Publication 7 compliance report
     * @returns {string} Formatted compliance report text
     */
    /**
     * Generate detailed MCEB Publication 7 compliance report
     * @returns {string} Formatted compliance report text
     */
    generateComplianceReport() {
        const formData = this.collectFormData();
        const report = [];
        const timestamp = new Date();

        // Report Header
        report.push('═══════════════════════════════════════════════════════════════');
        report.push('              MCEB PUBLICATION 7 COMPLIANCE REPORT');
        report.push('           Standard Frequency Action Format (SFAF)');
        report.push('═══════════════════════════════════════════════════════════════');
        report.push(`Generated: ${timestamp.toLocaleString()}`);
        report.push(`Authority: MCEB Publication 7 (1 November 2018)`);
        report.push(`System: SFAF Field Manager - MCEB Pub 7 Compliant Edition`);
        report.push('');

        // Executive Summary
        const requiredValidation = this.validateRequiredFields();
        const formatValidation = this.checkFieldFormats();

        report.push('EXECUTIVE SUMMARY');
        report.push('═════════════════');
        report.push(`Overall Compliance Status: ${requiredValidation.isValid && formatValidation.isValid ? 'COMPLIANT' : 'NON-COMPLIANT'}`);
        report.push(`Required Fields Status: ${requiredValidation.presentCount}/${requiredValidation.totalRequired} complete`);
        report.push(`Format Validation Status: ${formatValidation.validFields}/${formatValidation.totalFields} compliant`);
        report.push('');

        // Required Fields Analysis
        report.push('REQUIRED FIELDS ANALYSIS (MCEB Pub 7)');
        report.push('═════════════════════════════════════');

        if (requiredValidation.missingFields.length > 0) {
            report.push('❌ MISSING REQUIRED FIELDS:');
            requiredValidation.missingFields.forEach(field => {
                report.push(`   • ${field.fieldId} - ${field.title}`);
                report.push(`     Source: ${field.source}`);
                report.push(`     Severity: ${field.severity.toUpperCase()}`);
            });
            report.push('');
        }

        if (requiredValidation.presentFields.length > 0) {
            report.push('✅ PRESENT REQUIRED FIELDS:');
            requiredValidation.presentFields.forEach(field => {
                const truncatedValue = field.value.length > 30 ?
                    field.value.substring(0, 30) + '...' : field.value;
                report.push(`   • ${field.fieldId} - ${field.title}: "${truncatedValue}"`);
            });
            report.push('');
        }

        // Field Occurrence Limits Analysis (Corrected per MCEB Pub 7)
        report.push('FIELD OCCURRENCE LIMITS ANALYSIS');
        report.push('═════════════════════════════════');

        let occurrenceViolations = 0;
        const occurrenceLimits = {
            // Corrected per MCEB Pub 7 (1 November 2018)
            'field110': { max: 1, title: 'Frequency(ies)' }, // Single occurrence per MCEB Pub 7
            'field113': { max: 20, title: 'Station Class' },
            'field114': { max: 20, title: 'Emission Designator' },
            'field115': { max: 20, title: 'Transmitter Power' },
            'field116': { max: 20, title: 'Power Type' },
            'field340': { max: 10, title: 'TX Equipment Nomenclature' },
            'field343': { max: 10, title: 'TX Equipment Certification' },
            'field440': { max: 10, title: 'RX Equipment Nomenclature' },
            'field443': { max: 10, title: 'RX Equipment Certification' },
            'field500': { max: 10, title: 'IRAC Notes' },
            'field501': { max: 30, title: 'Notes/Comments' }
        };

        Object.entries(occurrenceLimits).forEach(([fieldId, limits]) => {
            // Check field110 specifically (single occurrence)
            if (fieldId === 'field110') {
                const field110 = document.getElementById('field110') || document.getElementById('field110_1');
                if (field110 && field110.value.trim()) {
                    report.push(`✅ ${fieldId} - ${limits.title}: 1/1 occurrences (MCEB Pub 7 compliant)`);
                }
            } else {
                // Check dynamic fields
                const occurrences = document.querySelectorAll(`[id^="${fieldId}_"]`);
                const actualCount = occurrences.length;

                if (actualCount > limits.max) {
                    occurrenceViolations++;
                    report.push(`❌ OCCURRENCE LIMIT EXCEEDED: ${fieldId}`);
                    report.push(`   Field: ${limits.title}`);
                    report.push(`   Actual: ${actualCount} occurrences`);
                    report.push(`   Maximum: ${limits.max} per MCEB Pub 7`);
                } else if (actualCount > 0) {
                    report.push(`✅ ${fieldId} - ${limits.title}: ${actualCount}/${limits.max} occurrences`);
                }
            }
        });

        if (occurrenceViolations === 0) {
            report.push('✅ All field occurrence limits compliant with MCEB Pub 7');
        }
        report.push('');

        // Format Validation Analysis
        report.push('FORMAT VALIDATION ANALYSIS');
        report.push('══════════════════════════');

        if (formatValidation.errors.length > 0) {
            report.push('❌ FORMAT VALIDATION ERRORS:');
            formatValidation.errors.forEach(error => {
                report.push(`   • ${error.fieldId} - ${error.title}`);
                report.push(`     Error: ${error.message}`);
                report.push(`     Expected: ${error.expectedFormat}`);
            });
            report.push('');
        }

        if (formatValidation.warnings.length > 0) {
            report.push('⚠️ FORMAT VALIDATION WARNINGS:');
            formatValidation.warnings.forEach(warning => {
                report.push(`   • ${warning.fieldId} - ${warning.title}`);
                report.push(`     Warning: ${warning.message}`);
            });
            report.push('');
        }

        // Agency-Specific Requirements
        const agency = formData['field200'];
        if (agency) {
            report.push(`AGENCY-SPECIFIC REQUIREMENTS (${agency})`);
            report.push('═══════════════════════════════════');

            switch (agency) {
                case 'USAF':
                    const fao = formData['field701'];
                    if (fao) {
                        report.push(`✅ Field 701 (Frequency Action Officer): ${fao}`);
                    } else {
                        report.push('❌ Field 701 (Frequency Action Officer) REQUIRED for Air Force assignments');
                    }
                    break;
                case 'USA':
                case 'USN':
                case 'USMC':
                case 'USCG':
                    report.push(`✅ Agency identification compliant: ${agency}`);
                    break;
                default:
                    report.push(`⚠️ Unknown agency code: ${agency}`);
            }
            report.push('');
        }

        // IRAC Submission Requirements
        report.push('IRAC SUBMISSION REQUIREMENTS');
        report.push('════════════════════════════');

        const approvalAuthority = formData['field144'];
        if (approvalAuthority) {
            if (approvalAuthority === 'Y') {
                report.push('✅ Field 144: Assignment processed for IRAC approval');
            } else if (approvalAuthority === 'N') {
                report.push('✅ Field 144: Assignment not requiring IRAC approval');
            } else {
                report.push(`⚠️ Field 144: Unknown approval authority indicator: ${approvalAuthority}`);
            }
        } else {
            report.push('❌ Field 144 (Approval Authority Indicator) REQUIRED per MCEB Pub 7');
        }

        // Security Classification Analysis
        const securityClass = formData['field005'];
        if (securityClass) {
            report.push(`✅ Security Classification: ${securityClass}`);

            // Check for classified data handling requirements
            if (['C', 'S', 'T'].includes(securityClass)) {
                const unclassifiedFields = formData['field015'];
                if (unclassifiedFields) {
                    report.push('✅ Unclassified data field indicator present for classified record');
                } else {
                    report.push('❌ Field 015 (Unclassified Data Fields) REQUIRED for classified records');
                }
            }
        }
        report.push('');

        // Emission Characteristics Coordination Analysis
        report.push('EMISSION CHARACTERISTICS COORDINATION');
        report.push('═══════════════════════════════════');

        // Check for coordinated emission groups (Fields 113-116 must be coordinated)
        const stationClasses = formData['field113'] || [];
        const emissionDesignators = formData['field114'] || [];
        const transmitterPowers = formData['field115'] || [];
        const powerTypes = formData['field116'] || [];

        const emissionCount = Math.max(
            Array.isArray(stationClasses) ? stationClasses.length : (stationClasses ? 1 : 0),
            Array.isArray(emissionDesignators) ? emissionDesignators.length : (emissionDesignators ? 1 : 0),
            Array.isArray(transmitterPowers) ? transmitterPowers.length : (transmitterPowers ? 1 : 0)
        );

        if (emissionCount > 0) {
            report.push(`✅ Emission characteristics groups: ${emissionCount} coordinated sets`);

            // Validate each emission group is complete
            for (let i = 0; i < emissionCount; i++) {
                const groupNum = i + 1;
                const hasStationClass = (Array.isArray(stationClasses) ? stationClasses[i] : stationClasses);
                const hasEmission = (Array.isArray(emissionDesignators) ? emissionDesignators[i] : emissionDesignators);
                const hasPower = (Array.isArray(transmitterPowers) ? transmitterPowers[i] : transmitterPowers);

                if (hasStationClass && hasEmission && hasPower) {
                    report.push(`   • Group ${groupNum}: Complete (113/114/115)`);
                } else {
                    report.push(`   • Group ${groupNum}: Incomplete - missing required emission data`);
                }
            }
        } else {
            report.push('❌ No emission characteristics defined - Field 113/114/115 required');
        }
        report.push('');

        // Geographic Coordination Analysis
        report.push('GEOGRAPHIC COORDINATION ANALYSIS');
        report.push('═══════════════════════════════');

        const txState = formData['field300'];
        const rxState = formData['field400'];
        const txCoords = formData['field303'];
        const rxCoords = formData['field403'];

        if (txState && rxState && txCoords && rxCoords) {
            report.push('✅ Complete geographic data for transmitter and receiver');
            report.push(`   TX Location: ${txState} - ${txCoords}`);
            report.push(`   RX Location: ${rxState} - ${rxCoords}`);

            // Check if outside US&P requires unified command data
            const outsideUSP = !['US', 'USA', 'USP'].includes(txState) || !['US', 'USA', 'USP'].includes(rxState);
            if (outsideUSP) {
                const unifiedCommand = formData['field201'];
                if (unifiedCommand) {
                    report.push(`✅ Unified Command specified for OUS&P assignment: ${unifiedCommand}`);
                } else {
                    report.push('❌ Field 201 (Unified Command) REQUIRED for assignments outside US&P');
                }
            }
        } else {
            report.push('❌ Incomplete geographic data - Fields 300/301/303 and 400/401/403 required');
        }
        report.push('');

        // Function Identifier Analysis
        report.push('FUNCTION IDENTIFIER ANALYSIS');
        report.push('════════════════════════════');

        const majorFunction = formData['field511'];
        const intermediateFunction = formData['field512'];

        if (majorFunction) {
            report.push(`✅ Major Function Identifier: ${majorFunction}`);

            if (intermediateFunction) {
                report.push(`✅ Intermediate Function Identifier: ${intermediateFunction}`);
            } else {
                report.push('⚠️ Field 512 (Intermediate Function Identifier) recommended for complete functional description');
            }
        } else {
            report.push('❌ Field 511 (Major Function Identifier) REQUIRED for all DoD assignments');
        }
        report.push('');

        // Final Compliance Summary
        report.push('FINAL COMPLIANCE ASSESSMENT');
        report.push('═══════════════════════════');

        const overallCompliant = requiredValidation.isValid &&
            formatValidation.isValid &&
            occurrenceViolations === 0;

        if (overallCompliant) {
            report.push('🎯 OVERALL STATUS: FULLY COMPLIANT WITH MCEB PUBLICATION 7');
            report.push('   ✅ All required fields present');
            report.push('   ✅ All field formats valid');
            report.push('   ✅ All occurrence limits respected');
            report.push('   ✅ Ready for IRAC submission');
        } else {
            report.push('❌ OVERALL STATUS: NON-COMPLIANT WITH MCEB PUBLICATION 7');
            report.push('   ⚠️ Corrections required before IRAC submission');

            if (!requiredValidation.isValid) {
                report.push(`   ❌ Missing ${requiredValidation.missingCount} required fields`);
            }
            if (!formatValidation.isValid) {
                report.push(`   ❌ ${formatValidation.errors.length} format validation errors`);
            }
            if (occurrenceViolations > 0) {
                report.push(`   ❌ ${occurrenceViolations} occurrence limit violations`);
            }
        }

        report.push('');
        report.push('═══════════════════════════════════════════════════════════════');
        report.push(`Report Generated: ${timestamp.toISOString()}`);
        report.push('Authority: MCEB Publication 7 (1 November 2018)');
        report.push('Classification: Report inherits classification of highest classified field');
        report.push('Distribution: For Official Use Only - Frequency Coordination Personnel');
        report.push('═══════════════════════════════════════════════════════════════');

        return report.join('\n');
    }

    /**
 * Check field formats against MCEB Publication 7 standards
 * @returns {Object} Format validation results with errors, warnings, and compliance status
 */
    checkFieldFormats() {
        const formatResults = {
            isValid: true,
            totalFields: 0,
            validFields: 0,
            invalidFields: 0,
            errors: [],
            warnings: [],
            compliance: {
                mcebPub7: 'COMPLIANT',
                timestamp: new Date().toISOString(),
                version: 'MCEB Publication 7 (1 November 2018)'
            }
        };

        // Get all form fields for validation
        const formFields = document.querySelectorAll('input, select, textarea');

        formFields.forEach(field => {
            const fieldType = this.getFieldType(field);
            if (!fieldType) return;

            formatResults.totalFields++;
            const fieldValue = field.value.trim();

            // Skip empty fields for format validation
            if (!fieldValue) return;

            let isFieldValid = true;
            const fieldSpec = this.fieldSpecs[`field${fieldType}`];
            const fieldTitle = fieldSpec?.title || `Field ${fieldType}`;

            // Validate based on specific field types
            switch (fieldType) {
                case '005': // Security Classification
                    isFieldValid = this.validateSecurityClassificationFormat(field, fieldValue, formatResults);
                    break;

                case '010': // Type of Action
                    isFieldValid = this.validateTypeOfActionFormat(field, fieldValue, formatResults);
                    break;

                case '102': // Agency Serial Number
                    isFieldValid = this.validateAgencySerialNumberFormat(field, fieldValue, formatResults);
                    break;

                case '110': // Frequency(ies) - Single occurrence per MCEB Pub 7
                    isFieldValid = this.validateFrequencyFormat(field, fieldValue, formatResults);
                    break;

                case '113': // Station Class
                    isFieldValid = this.validateStationClassFormat(field, fieldValue, formatResults);
                    break;

                case '114': // Emission Designator
                    isFieldValid = this.validateEmissionDesignatorFormat(field, fieldValue, formatResults);
                    break;

                case '115': // Transmitter Power
                    isFieldValid = this.validateTransmitterPowerFormat(field, fieldValue, formatResults);
                    break;

                case '116': // Power Type
                    isFieldValid = this.validatePowerTypeFormat(field, fieldValue, formatResults);
                    break;

                case '130': // Time Code
                    isFieldValid = this.validateTimeCodeFormat(field, fieldValue, formatResults);
                    break;

                case '131': // Percent Time
                    isFieldValid = this.validatePercentTimeFormat(field, fieldValue, formatResults);
                    break;

                case '140': case '141': case '142': case '143': // Date fields
                    isFieldValid = this.validateDateFieldFormat(field, fieldValue, formatResults);
                    break;

                case '144': // Approval Authority Indicator
                    isFieldValid = this.validateApprovalAuthorityFormat(field, fieldValue, formatResults);
                    break;

                case '200': // Agency
                    isFieldValid = this.validateAgencyFormat(field, fieldValue, formatResults);
                    break;

                case '300': case '400': // State/Country
                    isFieldValid = this.validateStateCountryFormat(field, fieldValue, formatResults);
                    break;

                case '301': case '401': // Antenna Location
                    isFieldValid = this.validateAntennaLocationFormat(field, fieldValue, formatResults);
                    break;

                case '303': case '403': // Antenna Coordinates
                    isFieldValid = this.validateCoordinateFormat(field, fieldValue, formatResults);
                    break;

                case '340': case '440': // Equipment Nomenclature
                    isFieldValid = this.validateEquipmentNomenclatureFormat(field, fieldValue, formatResults);
                    break;

                case '343': case '443': // Equipment Certification
                    isFieldValid = this.validateEquipmentCertificationFormat(field, fieldValue, formatResults);
                    break;

                case '357': case '457': // Antenna Gain
                    isFieldValid = this.validateAntennaGainFormat(field, fieldValue, formatResults);
                    break;

                case '362': case '462': // Antenna Orientation
                    isFieldValid = this.validateAntennaOrientationFormat(field, fieldValue, formatResults);
                    break;

                case '363': case '463': // Antenna Polarization
                    isFieldValid = this.validateAntennaPolarizationFormat(field, fieldValue, formatResults);
                    break;

                case '500': // IRAC Notes
                    isFieldValid = this.validateIRACNotesFormat(field, fieldValue, formatResults);
                    break;

                case '501': // Notes/Comments
                    isFieldValid = this.validateCommentsFormat(field, fieldValue, formatResults);
                    break;

                case '502': // Description of Requirement
                    isFieldValid = this.validateDescriptionFormat(field, fieldValue, formatResults);
                    break;

                case '511': case '512': case '513': // Function Identifiers
                    isFieldValid = this.validateFunctionIdentifierFormat(field, fieldValue, formatResults);
                    break;

                case '520': // Supplementary Details
                    isFieldValid = this.validateSupplementaryDetailsFormat(field, fieldValue, formatResults);
                    break;

                case '701': // Frequency Action Officer
                    isFieldValid = this.validateFrequencyActionOfficerFormat(field, fieldValue, formatResults);
                    break;

                case '702': // Control/Request Number
                    isFieldValid = this.validateControlRequestNumberFormat(field, fieldValue, formatResults);
                    break;

                case '716': // Usage Code
                    isFieldValid = this.validateUsageCodeFormat(field, fieldValue, formatResults);
                    break;

                case '801': case '803': // Coordination Data/POC
                    isFieldValid = this.validateCoordinationDataFormat(field, fieldValue, formatResults);
                    break;

                default:
                    // Generic format validation for other fields
                    isFieldValid = this.validateGenericFieldFormat(field, fieldValue, formatResults);
            }

            // Update counters
            if (isFieldValid) {
                formatResults.validFields++;
            } else {
                formatResults.invalidFields++;
                formatResults.isValid = false;
            }
        });

        // Update overall compliance status
        if (!formatResults.isValid) {
            formatResults.compliance.mcebPub7 = 'NON-COMPLIANT';
        }

        return formatResults;
    }

    // ===== FORMAT VALIDATION HELPER METHODS =====

    /**
     * Validate Security Classification format (Field 005)
     */
    validateSecurityClassificationFormat(field, value, results) {
        const upperValue = value.toUpperCase();
        const validClassifications = ['U', 'UE', 'C', 'S', 'T'];

        if (!validClassifications.includes(upperValue)) {
            results.errors.push({
                fieldId: 'field005',
                title: 'Security Classification',
                message: `Invalid security classification: ${value}`,
                expectedFormat: 'U, UE, C, S, or T per MCEB Pub 7'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Type of Action format (Field 010)
     */
    validateTypeOfActionFormat(field, value, results) {
        const upperValue = value.toUpperCase();
        const validActions = ['A', 'D', 'E', 'F', 'M', 'N', 'R'];

        if (!validActions.includes(upperValue)) {
            results.errors.push({
                fieldId: 'field010',
                title: 'Type of Action',
                message: `Invalid type of action: ${value}`,
                expectedFormat: 'A, D, E, F, M, N, or R per MCEB Pub 7'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Agency Serial Number format (Field 102)
     */
    validateAgencySerialNumberFormat(field, value, results) {
        // MCEB Pub 7 format: AAAAYYNNNN (Agency + Year + Number)
        const serialPattern = /^[A-Z\s]{1,4}\d{6}$/;

        if (value.length > 10) {
            results.errors.push({
                fieldId: 'field102',
                title: 'Agency Serial Number',
                message: 'Exceeds maximum 10 characters',
                expectedFormat: 'AAAAYYNNNN format per MCEB Pub 7'
            });
            return false;
        }

        if (!serialPattern.test(value.replace(/\s+/g, ''))) {
            results.warnings.push({
                fieldId: 'field102',
                title: 'Agency Serial Number',
                message: 'Format should follow AAAAYYNNNN pattern (Agency + Year + Sequential)'
            });
        }

        return true;
    }

    /**
     * Validate Frequency format (Field 110) - Single occurrence per MCEB Pub 7
     */
    validateFrequencyFormat(field, value, results) {
        const upperValue = value.toUpperCase();

        // MCEB Pub 7 frequency formats: K4551.5(4550), M225.8, etc.
        const frequencyPatterns = [
            /^[KMG]\d{1,7}(\.\d{1,3})?(\(\d{1,7}(\.\d{1,3})?\))?$/, // K4726.5(4725) format
            /^\d{1,7}(\.\d{1,6})?$/, // Simple numeric format
            /^[HV]\d{1,7}(\.\d{1,3})?$/ // HF/VHF format
        ];

        const isValidFormat = frequencyPatterns.some(pattern => pattern.test(upperValue));

        if (!isValidFormat) {
            results.errors.push({
                fieldId: 'field110',
                title: 'Frequency',
                message: `Invalid frequency format: ${value}`,
                expectedFormat: 'K4726.5, M225.8, K4726.5(4725) per MCEB Pub 7'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Emission Designator format (Field 114)
     */
    validateEmissionDesignatorFormat(field, value, results) {
        const upperValue = value.toUpperCase();

        // ITU emission designator pattern per MCEB Pub 7 Annex B
        const emissionPattern = /^(\d{1,4}[KMGHZ]?\d{0,2})?[NAHGRJFCPKLQVMWX][0-9X][NABCDEFWX]([ABCDEFGHJKLMNWX]([NCFTWX])?)?$/;

        if (!emissionPattern.test(upperValue)) {
            results.errors.push({
                fieldId: 'field114',
                title: 'Emission Designator',
                message: `Invalid emission designator format: ${value}`,
                expectedFormat: 'ITU format: bandwidth + emission class + info type (e.g., 16K0F3E, A3E)'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Transmitter Power format (Field 115)
     */
    validateTransmitterPowerFormat(field, value, results) {
        const upperValue = value.toUpperCase();

        // MCEB Pub 7 power format: W10, K5, M2.5, etc.
        const powerPattern = /^[WKMGV]\d{1,7}(\.\d{1,5})?$/;

        if (!powerPattern.test(upperValue)) {
            results.errors.push({
                fieldId: 'field115',
                title: 'Transmitter Power',
                message: `Invalid power format: ${value}`,
                expectedFormat: 'Unit + value: W10, K5, M2.5 (W=watts, K=kW, M=MW, V=μV)'
            });
            return false;
        }

        // Validate logical power ranges
        const unit = upperValue.charAt(0);
        const powerValue = parseFloat(upperValue.substring(1));

        switch (unit) {
            case 'W':
                if (powerValue >= 1000) {
                    results.warnings.push({
                        fieldId: 'field115',
                        title: 'Transmitter Power',
                        message: 'Power ≥1000W should use K prefix (e.g., K1.0)'
                    });
                }
                break;
            case 'K':
                if (powerValue < 1 || powerValue >= 1000) {
                    results.errors.push({
                        fieldId: 'field115',
                        title: 'Transmitter Power',
                        message: 'K prefix valid for 1-999.99999 kW range only',
                        expectedFormat: 'Use W for <1kW, M for ≥1000kW'
                    });
                    return false;
                }
                break;
            case 'M':
                if (powerValue < 1 || powerValue >= 1000) {
                    results.errors.push({
                        fieldId: 'field115',
                        title: 'Transmitter Power',
                        message: 'M prefix valid for 1-999.99999 MW range only',
                        expectedFormat: 'Use K for <1MW, G for ≥1000MW'
                    });
                    return false;
                }
                break;
        }

        return true;
    }

    /**
    * Validate Coordinate format (Fields 303/403) - Continued from previous
    */
    validateCoordinateFormat(field, value, results) {
        const upperValue = value.toUpperCase().replace(/\s/g, '');

        // MCEB Pub 7 coordinate formats
        const degMinSecPattern = /^(\d{2,3})(\d{2})(\d{2})(\.\d+)?([NSEW])(\d{3})(\d{2})(\d{2})(\.\d+)?([NSEW])$/;
        const decimalPattern = /^(\d{1,3})\.(\d{5,})([NSEW])(\d{1,3})\.(\d{5,})([NSEW])$/;

        let isValid = false;

        if (degMinSecPattern.test(upperValue)) {
            const match = upperValue.match(degMinSecPattern);
            const degrees1 = parseInt(match[1]);
            const minutes1 = parseInt(match[2]);
            const seconds1 = parseInt(match[3]);
            const hemisphere1 = match[5];
            const degrees2 = parseInt(match[6]);
            const minutes2 = parseInt(match[7]);
            const seconds2 = parseInt(match[8]);
            const hemisphere2 = match[10];

            // Validate coordinate ranges per MCEB Pub 7
            const maxDegrees1 = (hemisphere1 === 'N' || hemisphere1 === 'S') ? 90 : 180;
            const maxDegrees2 = (hemisphere2 === 'N' || hemisphere2 === 'S') ? 90 : 180;

            if (degrees1 <= maxDegrees1 && minutes1 < 60 && seconds1 < 60 &&
                degrees2 <= maxDegrees2 && minutes2 < 60 && seconds2 < 60) {
                isValid = true;
            } else {
                results.errors.push({
                    fieldId: field.id,
                    title: 'Antenna Coordinates',
                    message: 'Coordinate values exceed valid ranges',
                    expectedFormat: 'Latitude: 0-90°, Longitude: 0-180°, Minutes/Seconds: 0-59'
                });
                return false;
            }
        } else if (decimalPattern.test(upperValue)) {
            const match = upperValue.match(decimalPattern);
            const degrees1 = parseFloat(match[1] + '.' + match[2]);
            const hemisphere1 = match[3];
            const degrees2 = parseFloat(match[4] + '.' + match[5]);
            const hemisphere2 = match[6];

            const maxDegrees1 = (hemisphere1 === 'N' || hemisphere1 === 'S') ? 90 : 180;
            const maxDegrees2 = (hemisphere2 === 'N' || hemisphere2 === 'S') ? 90 : 180;

            if (degrees1 <= maxDegrees1 && degrees2 <= maxDegrees2) {
                isValid = true;
            } else {
                results.errors.push({
                    fieldId: field.id,
                    title: 'Antenna Coordinates',
                    message: 'Decimal coordinate values exceed valid ranges',
                    expectedFormat: 'Latitude: ±90.0, Longitude: ±180.0'
                });
                return false;
            }
        }

        if (!isValid) {
            results.errors.push({
                fieldId: field.id,
                title: 'Antenna Coordinates',
                message: `Invalid coordinate format: ${value}`,
                expectedFormat: 'DDMMSSNDDDMMSSW or DD.DDDDNDD.DDDDW per MCEB Pub 7'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Equipment Nomenclature format (Fields 340/440)
     */
    validateEquipmentNomenclatureFormat(field, value, results) {
        // Maximum 18 characters per MCEB Pub 7
        if (value.length > 18) {
            results.errors.push({
                fieldId: field.id,
                title: 'Equipment Nomenclature',
                message: 'Exceeds maximum 18 characters',
                expectedFormat: 'Military equipment format per MCEB Pub 7'
            });
            return false;
        }

        // Military equipment nomenclature pattern: G,AN/PRC-160(V)
        const equipmentPattern = /^[A-Z],AN\/[A-Z]{3}-\d+(\([A-Z]+\))?$/;

        if (!equipmentPattern.test(value)) {
            results.warnings.push({
                fieldId: field.id,
                title: 'Equipment Nomenclature',
                message: 'Should follow military format: Type,AN/XXX-NNN(Variant)'
            });
        }

        return true;
    }

    /**
     * Validate Equipment Certification format (Fields 343/443)
     */
    validateEquipmentCertificationFormat(field, value, results) {
        // Maximum 15 characters per MCEB Pub 7
        if (value.length > 15) {
            results.errors.push({
                fieldId: field.id,
                title: 'Equipment Certification',
                message: 'Exceeds maximum 15 characters',
                expectedFormat: 'Military certification format per MCEB Pub 7'
            });
            return false;
        }

        // Military certification pattern: J/F 12/11171
        const certPattern = /^[A-Z]\/[A-Z]\s\d{2}\/\d{5}$/;

        if (!certPattern.test(value)) {
            results.warnings.push({
                fieldId: field.id,
                title: 'Equipment Certification',
                message: 'Should follow military format: X/Y NN/NNNNN'
            });
        }

        return true;
    }

    /**
     * Validate Antenna Gain format (Fields 357/457)
     */
    validateAntennaGainFormat(field, value, results) {
        // Maximum 4 characters per MCEB Pub 7
        if (value.length > 4) {
            results.errors.push({
                fieldId: field.id,
                title: 'Antenna Gain',
                message: 'Exceeds maximum 4 characters',
                expectedFormat: 'Numeric value in dB per MCEB Pub 7'
            });
            return false;
        }

        // Antenna gain pattern: numeric value (can be negative)
        const gainPattern = /^-?\d{1,3}(\.\d)?$/;

        if (!gainPattern.test(value)) {
            results.errors.push({
                fieldId: field.id,
                title: 'Antenna Gain',
                message: `Invalid antenna gain format: ${value}`,
                expectedFormat: 'Numeric value in dB (e.g., 0, 3.5, -10)'
            });
            return false;
        }

        // Validate logical gain ranges
        const gainValue = parseFloat(value);
        if (gainValue < -50 || gainValue > 100) {
            results.warnings.push({
                fieldId: field.id,
                title: 'Antenna Gain',
                message: 'Antenna gain outside typical range (-50 to +100 dB)'
            });
        }

        return true;
    }

    /**
     * Validate Antenna Orientation format (Fields 362/462)
     */
    validateAntennaOrientationFormat(field, value, results) {
        const upperValue = value.toUpperCase();

        // Maximum 3 characters per MCEB Pub 7
        if (upperValue.length > 3) {
            results.errors.push({
                fieldId: field.id,
                title: 'Antenna Orientation',
                message: 'Exceeds maximum 3 characters',
                expectedFormat: 'NNN degrees or ND per MCEB Pub 7'
            });
            return false;
        }

        // Antenna orientation patterns
        const orientationPatterns = [
            /^ND$/,          // Non-directional
            /^\d{1,3}$/,     // Degrees (0-360)
            /^[NSEW]$/       // Cardinal directions
        ];

        const isValidFormat = orientationPatterns.some(pattern => pattern.test(upperValue));

        if (!isValidFormat) {
            results.errors.push({
                fieldId: field.id,
                title: 'Antenna Orientation',
                message: `Invalid orientation format: ${value}`,
                expectedFormat: 'ND (non-directional), NNN (degrees), or N/S/E/W'
            });
            return false;
        }

        // Validate degree range if numeric
        if (/^\d{1,3}$/.test(upperValue)) {
            const degrees = parseInt(upperValue);
            if (degrees > 360) {
                results.errors.push({
                    fieldId: field.id,
                    title: 'Antenna Orientation',
                    message: 'Degrees must be 0-360',
                    expectedFormat: '0-360 degrees from true north'
                });
                return false;
            }
        }

        return true;
    }

    /**
     * Validate Antenna Polarization format (Fields 363/463)
     */
    validateAntennaPolarizationFormat(field, value, results) {
        const upperValue = value.toUpperCase();
        const validPolarizations = ['V', 'H', 'C', 'L', 'R'];

        if (!validPolarizations.includes(upperValue)) {
            results.errors.push({
                fieldId: field.id,
                title: 'Antenna Polarization',
                message: `Invalid polarization: ${value}`,
                expectedFormat: 'V (Vertical), H (Horizontal), C (Circular), L (Left), R (Right)'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Time Code format (Field 130)
     */
    validateTimeCodeFormat(field, value, results) {
        const upperValue = value.toUpperCase();

        // Maximum 4 characters per MCEB Pub 7
        if (upperValue.length > 4) {
            results.errors.push({
                fieldId: field.id,
                title: 'Time Code',
                message: 'Exceeds maximum 4 characters',
                expectedFormat: 'MCEB Pub 7 time code format'
            });
            return false;
        }

        // Time code patterns from MCEB Pub 7 (Source: manager.txt)
        const timeCodePatterns = [
            /^[1-4]H(24|X|N|J|T)$/,  // Standard time codes: 1H24, 2HX, 3HN, etc.
            /^[1-4]$/,               // Basic codes: 1, 2, 3, 4
            /^[0-9]{3,4}$/          // Numeric time codes
        ];

        const isValidFormat = timeCodePatterns.some(pattern => pattern.test(upperValue));

        if (!isValidFormat) {
            results.errors.push({
                fieldId: field.id,
                title: 'Time Code',
                message: `Invalid time code format: ${value}`,
                expectedFormat: 'NHX format (e.g., 1H24, 2HX, 3HN) per MCEB Pub 7'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Percent Time format (Field 131)
     */
    validatePercentTimeFormat(field, value, results) {
        // Maximum 2 characters per MCEB Pub 7
        if (value.length > 2) {
            results.errors.push({
                fieldId: field.id,
                title: 'Percent Time',
                message: 'Exceeds maximum 2 characters',
                expectedFormat: 'Percentage value 1-99'
            });
            return false;
        }

        const percentValue = parseInt(value);

        if (isNaN(percentValue) || percentValue < 1 || percentValue > 99) {
            results.errors.push({
                fieldId: field.id,
                title: 'Percent Time',
                message: `Invalid percent time: ${value}`,
                expectedFormat: 'Numeric percentage 1-99'
            });
            return false;
        }

        return true;
    }

    /**
     * Validate Date Field format (Fields 140-143)
     */
    validateDateFieldFormat(field, value, results) {
        // MCEB Pub 7 date format: YYYYMMDD
        const datePattern = /^\d{8}$/;

        if (!datePattern.test(value)) {
            results.errors.push({
                fieldId: field.id,
                title: 'Date Field',
                message: `Invalid date format: ${value}`,
                expectedFormat: 'YYYYMMDD format per MCEB Pub 7'
            });
            return false;
        }

        // Validate actual date
        const year = parseInt(value.substring(0, 4));
        const month = parseInt(value.substring(4, 6));
        const day = parseInt(value.substring(6, 8));

        const date = new Date(year, month - 1, day);

        if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
            results.errors.push({
                fieldId: field.id,
                title: 'Date Field',
                message: `Invalid date: ${value}`,
                expectedFormat: 'Valid date in YYYYMMDD format'
            });
            return false;
        }

        // Validate reasonable date ranges
        const currentYear = new Date().getFullYear();
        if (year < 1990 || year > currentYear + 50) {
            results.warnings.push({
                fieldId: field.id,
                title: 'Date Field',
                message: `Date outside typical range: ${year}`
            });
        }

        return true;
    }

    /**
     * Validate Function Identifier format (Fields 511/512/513)
     */
    validateFunctionIdentifierFormat(field, value, results) {
        const upperValue = value.toUpperCase();
        const fieldType = this.getFieldType(field);
        const maxLength = fieldType === '511' || fieldType === '512' ? 30 : 50;

        if (upperValue.length > maxLength) {
            results.errors.push({
                fieldId: field.id,
                title: 'Function Identifier',
                message: `Exceeds maximum ${maxLength} characters`,
                expectedFormat: `MCEB Pub 7 function identifier (max ${maxLength} chars)`
            });
            return false;
        }

        // Maximum 30 characters per MCEB Pub 7
        if (value.length > 30) {
            this.showFieldErrors(field, ['Maximum 30 characters per MCEB Pub 7 field 511']);
            return false;
        }

        // Official major function identifiers from MCEB Pub 7 Annex G
        const majorFunctionIdentifiers = [
            'AIR OPERATIONS', 'TACTICAL OPERATIONS', 'TRAINING', 'COMMUNICATIONS',
            'INTELLIGENCE', 'MEDICAL', 'LAW ENFORCEMENT', 'RANGE OPERATIONS',
            'SUSTAINING OPERATIONS', 'SPACE OPERATIONS', 'EMERGENCY SERVICES',
            'COMMAND AND CONTROL', 'DATA LINK', 'SPECIAL OPERATIONS',
            'DOMESTIC SUPPORT OPERATIONS', 'OTHER OPERATIONS'
        ];

        if (!majorFunctionIdentifiers.includes(value)) {
            this.showFieldWarning(field,
                'Function identifier not in official MCEB Pub 7 Annex G list. Verify identifier is correct.'
            );
        }

        return true;
    }

    /**
    // Validate Intermediate Function Identifier (Field 512) per MCEB Pub 7
     */
    validateIntermediateFunctionIdentifier(field) {
        const value = field.value.trim().toUpperCase();
        if (!value) return true;

        // Maximum 30 characters per MCEB Pub 7
        if (value.length > 30) {
            this.showFieldErrors(field, ['Maximum 30 characters per MCEB Pub 7 field 512']);
            return false;
        }

        // Extensive list from MCEB Pub 7 Annex G
        const intermediateFunctionIdentifiers = [
            // Air Operations
            'FLIGHT OPERATIONS', 'FLIGHT TEST', 'FORWARD AIR CONTROL POST',
            'GCA', 'PILOT-TO-DISPATCHER', 'PILOT-TO-METRO', 'PILOT-TO-PILOT',
            'RAMP CONTROL', 'REFUELING', 'SHIP/AIR OPERATIONS', 'AIR DEFENSE',
            'AIR DEFENSE WARNING', 'AIR DEFENSE / INTERCEPT', 'AIR FORCE ONE',
            'AIR FORCE SPECIAL OPERATIONS', 'AIR ROUTE SURVEILLANCE RADAR',
            'AIR TRAFFIC CONTROL', 'AIR/AIR COMMUNICATIONS', 'AIR/GROUND/AIR COMMUNICATIONS',
            'AIRBORNE COMMAND CENTER', 'AIRCRAFT', 'AIRPORT SURVEILLANCE RADAR',
            'APPROACH CONTROL', 'ARMY AVIATION',

            // Training
            'TRAINING', 'INSTRUCTOR/STUDENT TRAINING', 'EXERCISE', 'EXPERIMENTAL',
            'SIMULATOR', 'AERO CLUB', 'EDUCATION',

            // Tactical Operations
            'TACTICAL OPERATIONS', 'GROUND OPERATIONS', 'SEA OPERATIONS',
            'SPECIAL OPERATIONS', 'PSYCHOLOGICAL OPERATIONS', 'FIRE SUPPORT',
            'INFANTRY', 'GROUND INTERDICTION', 'ARTILLERY', 'MISSILE',
            'SPECIAL FORCES', 'RANGER UNITS', 'NAVY SPECIAL OPERATIONS',
            'NAVAL GUNFIRE SUPPORT', 'TARGET ACQUISITION', 'TARGET SCORING', 'TARGET',

            // Communications
            'COMMUNICATIONS', 'SATELLITE COMMUNICATIONS', 'RADIO RELAY', 'MICROWAVE',
            'MILSTAR', 'FLTSATCOM', 'GLOBAL', 'MARS', 'AFSATCOM', 'DSCS',
            'LEASAT', 'SPITFIRE', 'TROJAN SPIRIT', 'MSE', 'TACTS',
            'IONOSPHERIC SOUNDER', 'ISYSCON', 'GCCS', 'MICROWAVE DATA LINK',

            // Intelligence
            'INTELLIGENCE', 'SURVEILLANCE', 'RECONNAISSANCE', 'SURVEILLANCE/RECONNAISSANCE',
            'ACS', 'AHFEWS', 'ARL', 'TRACKWOLF', 'TRAILBLAZER', 'TEAMMATE',

            // Security/Law Enforcement
            'LAW ENFORCEMENT', 'SECURITY FORCE', 'MILITARY POLICE', 'SHORE PATROL',
            'FIRE', 'HAZMAT', 'CID', 'DIS', 'NCIS', 'OSI', 'SCOPE SHIELD',
            'SPEED MEASUREMENT SYSTEMS', 'SURVEILLANCE SYSTEMS', 'TETHERED AEROSTAT RADAR',
            'WEAPONS STORAGE PROTECTION', 'ALARM SYSTEMS', 'DISASTER PLANNING', 'EOD',
            'ANTI-TERRORISM', 'CIVIL DISTURBANCES', 'COUNTER DRUG', 'PROJECT COTHEN',
            'SPECIAL SECURITY OPERATIONS',

            // Emergency Services
            'EMERGENCY SERVICES', 'WARNING SYSTEM', 'CONSEQUENCE MANAGEMENT', 'CBR',
            'CIVIL SUPPORT TEAM', 'ENVIRONMENTAL CLEANUP', 'FEMA',
            'HAZARDOUS MATERIAL RELEASE', 'TECHNICAL ESCORT UNIT', 'MUTUAL AID',

            // Weather/Environmental
            'WEATHER', 'WEATHER RADAR', 'WIND PROFILER', 'AMSS', 'ASOS', 'AWOS',
            'GOES', 'IMETS', 'NEXRAD', 'RADIOSONDE', 'SAWDS',

            // Range Operations
            'RANGE OPERATIONS', 'RANGE CONTROL', 'RDTE SUPPORT', 'TEST AND MEASUREMENT',
            'TEST RANGE TIMING', 'TEST RANGE', 'RDMS', 'OCCS SUPPORT',

            // Sustaining Operations
            'SUSTAINING OPERATIONS', 'FLEET SUPPORT', 'PUBLIC WORKS', 'NATURAL RESOURCES',
            'RESOURCES CONSERVATION', 'SAFETY', 'LOCKS AND DAMS', 'HYDROLOGIC',
            'METEOROLOGICAL', 'SEISMIC', 'NAVAIDS', 'NAVIGATION RADAR', 'CIVIL ENGINEERING',
            'CIVIL WORKS', 'CONSTRUCTION', 'INDUSTRIAL CONTROLS', 'PRIME BEEF',
            'RED HORSE', 'SEABEES', 'UTILITIES', 'WILDLIFE PRESERVATION',
            'NAVAIDS CONTROLS', 'REMOTE BARRIER CONTROL SYSTEMS', 'RUNWAY LIGHTING CONTROL',

            // Space Operations
            'SPACE OPERATIONS', 'SATELLITE COMMUNICATIONS', 'GPS', 'SHUTTLE', 'NASA',
            'SGLS', 'ARTS', 'TELEMETRY', 'TELECOMMAND', 'UAV',

            // Logistics
            'LOGISTICS', 'MAINTENANCE', 'MUNITIONS', 'POL', 'RESUPPLY',
            'INVENTORY/INVENTORY CONTROLS', 'SUPPLY AND LOGISTICS', 'SHIPYARD',
            'TRANSPORTATION', 'TAXI', 'AMPS', 'CSSCS', 'MTS', 'RF TAGS',

            // Global Operations
            'GLOBAL', 'WORLDWIDE', 'CONUS', 'NATO', 'OTHER OPERATIONS', 'SPECIAL PROJECTS',
            'HAARP', 'SURVEY', 'DTSS', 'ETRAC'
        ];

        if (!intermediateFunctionIdentifiers.includes(value)) {
            this.showFieldWarning(field,
                'Function identifier not in official MCEB Pub 7 list. Verify identifier is correct.'
            );
        }

        return true;
    }

    /**
    // Validate Equipment Certification ID (Fields 343/443) per MCEB Pub 7
     */
    validateEquipmentCertification(field) {
        const value = field.value.trim();
        if (!value) return true;

        // Maximum 15 characters per MCEB Pub 7
        if (value.length > 15) {
            this.showFieldErrors(field, ['Maximum 15 characters per MCEB Pub 7 equipment certification field']);
            return false;
        }

        // Military equipment certification pattern validation
        const certificationPattern = /^[A-Z]\/[A-Z]\s\d{2}\/\d{5}$/;

        if (!certificationPattern.test(value)) {
            this.showFieldWarning(field,
                'Equipment certification should follow military format (e.g., J/F 12/11171)'
            );
        }

        return true;
    }

    /**
    // Validate Agency (Field 200) per MCEB Pub 7
     */
    validateAgency(field) {
        const value = field.value.trim().toUpperCase();
        if (!value) return true;

        const validAgencies = ['USAF', 'USA', 'USN', 'USMC', 'USCG'];

        if (!validAgencies.includes(value)) {
            this.showFieldErrors(field, [
                'Invalid agency per MCEB Pub 7',
                'Valid values: USAF (Air Force), USA (Army), USN (Navy), USMC (Marines), USCG (Coast Guard)'
            ]);
            return false;
        }

        return true;
    }

    /**
    // Validate State/Country (Fields 300/400) per MCEB Pub 7
     */
    validateStateCountry(field) {
        const value = field.value.trim().toUpperCase();
        if (!value) return true;

        // Maximum 4 characters per MCEB Pub 7
        if (value.length > 4) {
            this.showFieldErrors(field, ['Maximum 4 characters per MCEB Pub 7 geographic field']);
            return false;
        }

        // US States and territories from MCEB Pub 7 Annex C
        const validGeographicCodes = [
            // 50 US States
            'AK', 'AL', 'AR', 'AZ', 'CA', 'CO', 'CT', 'DC', 'DE', 'FL',
            'GA', 'HI', 'IA', 'ID', 'IL', 'IN', 'KS', 'KY', 'LA', 'MA',
            'MD', 'ME', 'MI', 'MN', 'MO', 'MS', 'MT', 'NC', 'ND', 'NE',
            'NH', 'NJ', 'NM', 'NV', 'NY', 'OH', 'OK', 'OR', 'PA', 'RI',
            'SC', 'SD', 'TN', 'TX', 'UT', 'VA', 'VT', 'WA', 'WI', 'WV', 'WY',

            // US Territories
            'PR', 'VI', 'GUM', 'SMA', 'MRA', 'MDW', 'PLM', 'WAK', 'JON',

            // Common international codes
            'CAN', 'MEX', 'USA', 'GBR', 'FRA', 'DEU', 'JPN', 'AUS'
        ];

        if (!validGeographicCodes.includes(value)) {
            this.showFieldWarning(field,
                'Geographic code not in common MCEB Pub 7 Annex C list. Verify code is correct.'
            );
        }

        return true;
    }

    /**
    // Validate antenna location (Fields 301/401) per MCEB Pub 7
     */
    validateAntennaLocation(field) {
        const value = field.value.trim();
        if (!value) return true;

        // Maximum 24 characters per MCEB Pub 7
        if (value.length > 24) {
            this.showFieldErrors(field, ['Maximum 24 characters per MCEB Pub 7 antenna location field']);
            return false;
        }

        // Basic format validation for location names
        const locationPattern = /^[A-Za-z0-9\s\-\.]+$/;

        if (!locationPattern.test(value)) {
            this.showFieldErrors(field, [
                'Invalid characters in antenna location',
                'Use alphanumeric characters, spaces, hyphens, and periods only'
            ]);
            return false;
        }

        return true;
    }

    /**
     * Generic field validation for character limits and required fields
     */
    validateGenericField(field, fieldSpec) {
        const value = field.value.trim();

        // Check required fields
        if (fieldSpec.required && !value) {
            this.showFieldErrors(field, [`${fieldSpec.title} is required per MCEB Pub 7`]);
            return false;
        }

        // Check character limits
        if (fieldSpec.maxLength && value.length > fieldSpec.maxLength) {
            this.showFieldErrors(field, [
                `Maximum ${fieldSpec.maxLength} characters per MCEB Pub 7 ${fieldSpec.title}`
            ]);
            return false;
        }

        return true;
    }

    // ===== UTILITY METHODS =====

    /**
     * Get field type from ID or data attribute
     */
    getFieldType(field) {
        // Extract field number from ID (e.g., "field110_1" -> "110")
        const idMatch = field.id.match(/field(\d{3})/);
        if (idMatch) {
            return idMatch[1];
        }

        // Check data-field attribute
        return field.dataset.field || null;
    }

    /**
     * Get field specification from fieldSpecs
     */
    getFieldSpec(field) {
        const fieldType = this.getFieldType(field);
        if (!fieldType) return null;

        const baseFieldId = `field${fieldType}`;
        return this.fieldSpecs[baseFieldId] || null;
    }

    /**
     * Show field errors with MCEB Pub 7 styling
     */
    showFieldErrors(field, errors) {
        // Clear existing errors
        this.clearFieldErrors(field);

        // Set field border to error state
        field.style.borderColor = '#dc3545';
        field.style.borderWidth = '2px';

        // Create error container
        const errorContainer = document.createElement('div');
        errorContainer.className = 'field-errors';
        errorContainer.style.cssText = `
            color: #dc3545;
            font-size: 0.875em;
            margin-top: 4px;
            padding: 6px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
        `;

        // Add error messages
        errors.forEach(error => {
            const errorMsg = document.createElement('div');
            errorMsg.textContent = error;
            errorContainer.appendChild(errorMsg);
        });

        // Insert after field
        field.parentNode.insertBefore(errorContainer, field.nextSibling);
    }

    /**
     * Show field warning (non-critical validation issues)
     */
    showFieldWarning(field, warning) {
        // Clear existing errors
        this.clearFieldErrors(field);

        // Set field border to warning state
        field.style.borderColor = '#ffc107';
        field.style.borderWidth = '2px';

        // Create warning container
        const warningContainer = document.createElement('div');
        warningContainer.className = 'field-warning';
        warningContainer.style.cssText = `
            color: #856404;
            font-size: 0.875em;
            margin-top: 4px;
            padding: 6px;
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
        `;

        warningContainer.textContent = warning;

        // Insert after field
        field.parentNode.insertBefore(warningContainer, field.nextSibling);
    }

    /**
     * Clear field errors and warnings
     */
    clearFieldErrors(field) {
        // Reset field styling
        field.style.borderColor = '';
        field.style.borderWidth = '';

        // Remove error and warning elements
        const errorElements = field.parentNode.querySelectorAll('.field-errors, .field-warning');
        errorElements.forEach(element => element.remove());
    }

    /**
    // Validate all fields in the form
     */
    validateAllFields() {
        let isAllValid = true;
        const fields = document.querySelectorAll('input, select, textarea');

        fields.forEach(field => {
            const fieldType = this.getFieldType(field);
            if (fieldType) {
                const spec = this.getFieldSpec(field);
                const isValid = this.validateField(field, spec);
                if (!isValid) {
                    isAllValid = false;
                }
            }
        });

        return isAllValid;
    }

    /**
     * Character counter update for MCEB Pub 7 compliance
     */
    updateCharacterCounter(field) {
        const spec = this.getFieldSpec(field);
        if (!spec || !spec.maxLength) return;

        let counter = field.parentNode.querySelector('.char-counter');
        if (!counter) {
            counter = document.createElement('div');
            counter.className = 'char-counter';
            counter.style.cssText = `
                font-size: 0.75em;
                color: #666;
                text-align: right;
                margin-top: 2px;
            `;
            field.parentNode.appendChild(counter);
        }

        const current = field.value.length;
        const max = spec.maxLength;
        const remaining = max - current;

        counter.textContent = `${current}/${max} characters`;

        // Color coding based on remaining characters
        if (remaining < 0) {
            counter.style.color = '#dc3545'; // Over limit - red
            field.style.borderColor = '#dc3545';
        } else if (remaining < 5) {
            counter.style.color = '#ffc107'; // Near limit - yellow
            field.style.borderColor = '#ffc107';
        } else if (remaining < 10) {
            counter.style.color = '#fd7e14'; // Getting close - orange
        } else {
            counter.style.color = '#666'; // Normal - gray
            field.style.borderColor = '';
        }
    }

    /**
     * Get summary of validation results
     */
    getValidationSummary() {
        const fields = document.querySelectorAll('input, select, textarea');
        const summary = {
            totalFields: 0,
            validFields: 0,
            invalidFields: 0,
            errors: [],
            warnings: []
        };

        fields.forEach(field => {
            const fieldType = this.getFieldType(field);
            if (fieldType) {
                summary.totalFields++;

                const spec = this.getFieldSpec(field);
                const isValid = this.validateField(field, spec);

                if (isValid) {
                    summary.validFields++;
                } else {
                    summary.invalidFields++;
                    summary.errors.push(`Field ${fieldType} (${spec?.title || 'Unknown'}): Validation failed`);
                }
            }
        });

        return summary;
    }
}

// ===== UTILITY FUNCTIONS FOR STANDALONE USE =====

/**
 * Initialize SFAF validation system
 * @param {Object} fieldSpecs - Field specifications from SFAF Field Manager
 * @param {Object} referenceData - Reference data (power types, equipment codes, etc.)
 * @returns {SFAFCompliance} - Validator instance
 */
function initializeSFAFValidation(fieldSpecs, referenceData) {
    return new SFAFCompliance(fieldSpecs, referenceData);
}

/**
 * Quick validation function for single field
 * @param {HTMLElement} field - Form field to validate
 * @param {Object} fieldSpecs - Field specifications
 * @returns {boolean} - Validation result
 */
function validateSFAFField(field, fieldSpecs) {
    const validator = new SFAFCompliance(fieldSpecs);
    return validator.validateField(field);
}

/**
 * Bulk validation function for all SFAF fields
 * @param {Object} fieldSpecs - Field specifications
 * @param {Object} referenceData - Reference data
 * @returns {Object} - Validation summary
 */
function validateAllSFAFFields(fieldSpecs, referenceData) {
    const validator = new SFAFCompliance(fieldSpecs, referenceData);
    const isValid = validator.validateAllFields();
    const summary = validator.getValidationSummary();

    return {
        isValid,
        summary
    };
}

// ===== EXPORT FOR MODULE SYSTEMS =====

// For ES6 modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        SFAFCompliance,
        initializeSFAFValidation,
        validateSFAFField,
        validateAllSFAFFields
    };
}

// For AMD/RequireJS
if (typeof define === 'function' && define.amd) {
    define([], function () {
        return {
            SFAFCompliance,
            initializeSFAFValidation,
            validateSFAFField,
            validateAllSFAFFields
        };
    });
}

// For global/browser use
if (typeof window !== 'undefined') {
    window.SFAFCompliance = SFAFCompliance;
    window.initializeSFAFValidation = initializeSFAFValidation;
    window.validateSFAFField = validateSFAFField;
    window.validateAllSFAFFields = validateAllSFAFFields;
}

// ===== INTEGRATION WITH EXISTING SFAF FIELD MANAGER =====

/**
 * Connect validation system to existing SFAF Field Manager
 */
document.addEventListener('DOMContentLoaded', () => {
    // Wait for SFAF Field Manager initialization
    setTimeout(() => {
        if (window.sfafFieldManager) {
            // Initialize validator with SFAF Field Manager data
            const validator = new SFAFCompliance(
                window.sfafFieldManager.fieldSpecs,
                {
                    powerTypes: window.sfafFieldManager.powerTypes,
                    equipmentManufacturers: window.sfafFieldManager.equipmentManufacturers,
                    geographicCodes: window.sfafFieldManager.geographicCodes,
                    iracNotes: window.sfafFieldManager.iracNotes,
                    functionIdentifiers: window.sfafFieldManager.functionIdentifiers
                }
            );

            // Attach validation to all form fields
            const fields = document.querySelectorAll('input, select, textarea');
            fields.forEach(field => {
                const fieldType = validator.getFieldType(field);
                if (fieldType) {
                    // Validation on blur
                    field.addEventListener('blur', () => {
                        validator.validateField(field);
                    });

                    // Character counter on input
                    field.addEventListener('input', () => {
                        validator.clearFieldErrors(field);
                        validator.updateCharacterCounter(field);
                    });
                }
            });

            // Make validator globally available
            window.SFAFCompliance = validator;

            console.log('✅ SFAF Validation system initialized with MCEB Pub 7 compliance');
        }
    }, 1500);
});// 1. Field specifications object - Complete SFAF field specifications with character limits and max occurrences from MCEB Pub 7
const sfafFieldSpecs = {
    // Administrative Data
    'field005': { maxLength: 2, maxOccurrences: 1, title: 'Security Classification', options: ['U', 'UE', 'C', 'S'] },
    'field010': { maxLength: 1, maxOccurrences: 1, title: 'Type of Action', options: ['M', 'N', 'D', 'R'] },
    'field013': { maxLength: 35, maxOccurrences: 1, title: 'Declassification Instruction Comment' },
    'field019': { maxLength: 8, maxOccurrences: 1, title: 'Declassification Date' },
    'field102': { maxLength: 10, maxOccurrences: 1, title: 'Agency Serial Number' },
    'field701': { maxLength: 3, maxOccurrences: 1, title: 'Frequency Action Officer' },
    'field702': { maxLength: 15, maxOccurrences: 1, title: 'Control/Request Number' },

    // Emission Characteristics (Dynamic - up to 20 occurrences each per MCEB Pub 7)
    'field110': { maxLength: 11, maxOccurrences: 1, title: 'Frequency(ies)' },
    'field113': { maxLength: 4, maxOccurrences: 20, title: 'Station Class' },
    'field114': { maxLength: 11, maxOccurrences: 20, title: 'Emission Designator' },
    'field115': { maxLength: 9, maxOccurrences: 20, title: 'Transmitter Power' },
    'field116': { maxLength: 1, maxOccurrences: 20, title: 'Power Type', options: ['C', 'M', 'P'] },
    'field117': { maxLength: 6, maxOccurrences: 20, title: 'Effective Radiated Power' },
    'field118': { maxLength: 1, maxOccurrences: 20, title: 'Power/ERP Augmentation' },

    // Time/Date Information
    'field130': { maxLength: 4, maxOccurrences: 1, title: 'Time' },
    'field131': { maxLength: 2, maxOccurrences: 1, title: 'Percent Time' },
    'field140': { maxLength: 8, maxOccurrences: 1, title: 'Required Date (YYYYMMDD)' },
    'field141': { maxLength: 8, maxOccurrences: 1, title: 'Expiration Date (YYYYMMDD)' },
    'field142': { maxLength: 8, maxOccurrences: 1, title: 'Review Date (YYYYMMDD)' },
    'field143': { maxLength: 8, maxOccurrences: 1, title: 'Revision Date (YYYYMMDD)' },
    'field144': { maxLength: 1, maxOccurrences: 1, title: 'Approval Authority', options: ['Y', 'N', 'U'] },

    // Organizational Information
    'field200': { maxLength: 6, maxOccurrences: 1, title: 'Agency', options: ['USAF', 'USA', 'USN', 'USMC', 'USCG'] },
    'field201': { maxLength: 8, maxOccurrences: 10, title: 'Unified Command' },
    'field202': { maxLength: 8, maxOccurrences: 10, title: 'Unified Command Service' },
    'field204': { maxLength: 18, maxOccurrences: 1, title: 'Command' },
    'field205': { maxLength: 18, maxOccurrences: 1, title: 'Subcommand' },
    'field206': { maxLength: 18, maxOccurrences: 1, title: 'Installation Frequency Manager' },
    'field207': { maxLength: 18, maxOccurrences: 10, title: 'Operating Unit' },
    'field209': { maxLength: 18, maxOccurrences: 10, title: 'Area AFC/DoD AFC' },

    // Transmitter Location (Geographic codes A-Z per MCEB Pub 7 Annex E)
    'field300': { maxLength: 4, maxOccurrences: 1, title: 'State/Country' },
    'field301': { maxLength: 24, maxOccurrences: 1, title: 'Antenna Location' },
    'field303': { maxLength: 15, maxOccurrences: 1, title: 'Antenna Coordinates' },
    'field306': { maxLength: 5, maxOccurrences: 1, title: 'Authorized Radius' },

    // Transmitter Equipment (Dynamic - up to 10 occurrences each per MCEB Pub 7)
    'field340': { maxLength: 18, maxOccurrences: 10, title: 'Equipment Nomenclature' },
    'field343': { maxLength: 15, maxOccurrences: 10, title: 'Equipment Certification ID' },

    // Transmitter Antenna
    'field357': { maxLength: 4, maxOccurrences: 10, title: 'Antenna Gain' },
    'field362': { maxLength: 3, maxOccurrences: 10, title: 'Antenna Orientation' },
    'field363': { maxLength: 1, maxOccurrences: 10, title: 'Antenna Polarization', options: ['V', 'H', 'C'] },
    'field373': { maxLength: 1, maxOccurrences: 1, title: 'JSC Area Code' },

    // Receiver Location
    'field400': { maxLength: 4, maxOccurrences: 1, title: 'State/Country' },
    'field401': { maxLength: 24, maxOccurrences: 1, title: 'Antenna Location' },
    'field403': { maxLength: 15, maxOccurrences: 1, title: 'Antenna Coordinates' },

    // Receiver Equipment (Dynamic - up to 10 occurrences each per MCEB Pub 7)
    'field440': { maxLength: 18, maxOccurrences: 10, title: 'Equipment Nomenclature' },
    'field443': { maxLength: 15, maxOccurrences: 10, title: 'Equipment Certification ID' },

    // Receiver Antenna
    'field457': { maxLength: 4, maxOccurrences: 10, title: 'Antenna Gain' },
    'field462': { maxLength: 3, maxOccurrences: 10, title: 'Antenna Orientation' },
    'field463': { maxLength: 1, maxOccurrences: 10, title: 'Antenna Polarization', options: ['V', 'H', 'C'] },
    'field473': { maxLength: 1, maxOccurrences: 1, title: 'JSC Area Code', options: ['A', 'B', 'C', 'D'] },

    // Supplementary Details (IRAC Notes and Comments)
    'field500': { maxLength: 4, maxOccurrences: 10, title: 'IRAC Notes' },
    'field501': { maxLength: 35, maxOccurrences: 30, title: 'Notes/Comments' },
    'field502': { maxLength: 1440, maxOccurrences: 1, title: 'Description of Requirement' },
    'field503': { maxLength: 35, maxOccurrences: 30, title: 'Agency Free-text Comments' },
    'field511': { maxLength: 30, maxOccurrences: 1, title: 'Major Function Identifier' },
    'field512': { maxLength: 30, maxOccurrences: 1, title: 'Intermediate Function Identifier' },
    'field513': { maxLength: 30, maxOccurrences: 1, title: 'Minor Function Identifier' },
    'field520': { maxLength: 1080, maxOccurrences: 1, title: 'Supplementary Details' },

    // Other Assignment Identifiers
    'field716': { maxLength: 1, maxOccurrences: 1, title: 'Usage Code' },
    'field801': { maxLength: 60, maxOccurrences: 20, title: 'Coordination Data/Remarks' },
    'field803': { maxLength: 60, maxOccurrences: 1, title: 'Requestor Data POC' },
    'field804': { maxLength: 60, maxOccurrences: 30, title: 'Tuning Range/Tuning Increments' }
};

// Export field specifications
if (typeof module !== 'undefined' && module.exports) {
    module.exports = sfafFieldSpecs;
}
if (typeof window !== 'undefined') {
    window.sfafFieldSpecs = sfafFieldSpecs;
}// sfaf-reference-data.js - MCEB Pub 7 Official Reference Data
// All official reference data from MCEB Publication 7 (1 November 2018)

const SFAF_REFERENCE_DATA = {
    // Function Identifiers (234+ items from MCEB Pub 7 Annex G)
    functionIdentifiers: [
        // Air Operations
        'AIR OPERATIONS', 'FLIGHT OPERATIONS', 'FLIGHT TEST', 'FORWARD AIR CONTROL POST',
        'GCA', 'PILOT-TO-DISPATCHER', 'PILOT-TO-METRO', 'PILOT-TO-PILOT', 'RAMP CONTROL',
        'REFUELING', 'SHIP/AIR OPERATIONS', 'AIR DEFENSE', 'AIR DEFENSE WARNING',
        'AIR DEFENSE / INTERCEPT', 'AIR FORCE ONE', 'AIR FORCE SPECIAL OPERATIONS',
        'AIR ROUTE SURVEILLANCE RADAR', 'AIR TRAFFIC CONTROL', 'AIR/AIR COMMUNICATIONS',
        'AIR/GROUND/AIR COMMUNICATIONS', 'AIRBORNE COMMAND CENTER', 'AIRCRAFT',
        'AIRPORT SURVEILLANCE RADAR', 'APPROACH CONTROL', 'ARMY AVIATION',

        // Training
        'TRAINING', 'INSTRUCTOR/STUDENT TRAINING', 'EXERCISE', 'EXPERIMENTAL',
        'SIMULATOR', 'AERO CLUB', 'EDUCATION',

        // Tactical Operations
        'TACTICAL OPERATIONS', 'GROUND OPERATIONS', 'SEA OPERATIONS', 'SPECIAL OPERATIONS',
        'PSYCHOLOGICAL OPERATIONS', 'FIRE SUPPORT', 'INFANTRY', 'GROUND INTERDICTION',
        'ARTILLERY', 'MISSILE', 'SPECIAL FORCES', 'RANGER UNITS', 'NAVY SPECIAL OPERATIONS',
        'NAVAL GUNFIRE SUPPORT', 'TARGET ACQUISITION', 'TARGET SCORING', 'TARGET',

        // Administrative
        'ADMINISTRATIVE', 'INSTALLATION PA SYSTEM', 'MOTOR POOL', 'PAGING',
        'BROADCAST', 'TRAVELERS INFORMATION SYSTEM', 'UNLICENSED DEVICE',
        'WIRELESS LOCAL AREA NETWORK', 'WIRELESS MIKE', 'BASE OPERATIONS',
        'COMMAND NET', 'TRUNKING', 'HICOM', 'MOMS',

        // Logistics
        'LOGISTICS', 'MAINTENANCE', 'MUNITIONS', 'POL', 'RESUPPLY',
        'INVENTORY/INVENTORY CONTROLS', 'SUPPLY AND LOGISTICS', 'SHIPYARD',
        'TRANSPORTATION', 'TAXI', 'AMPS', 'CSSCS', 'MTS', 'RF TAGS',

        // Communications
        'COMMUNICATIONS', 'SATELLITE COMMUNICATIONS', 'RADIO RELAY', 'MICROWAVE',
        'MILSTAR', 'FLTSATCOM', 'GLOBAL', 'MARS', 'AFSATCOM', 'DSCS', 'LEASAT',
        'SPITFIRE', 'TROJAN SPIRIT', 'MSE', 'TACTS', 'IONOSPHERIC SOUNDER',
        'ISYSCON', 'GCCS', 'MICROWAVE DATA LINK',

        // Intelligence
        'INTELLIGENCE', 'SURVEILLANCE', 'RECONNAISSANCE', 'SURVEILLANCE/RECONNAISSANCE',
        'ACS', 'AHFEWS', 'ARL', 'TRACKWOLF', 'TRAILBLAZER', 'TEAMMATE',

        // Medical
        'MEDICAL', 'SEARCH AND RESCUE',

        // Security/Law Enforcement
        'LAW ENFORCEMENT', 'SECURITY FORCE', 'MILITARY POLICE', 'SHORE PATROL',
        'FIRE', 'HAZMAT', 'CID', 'DIS', 'NCIS', 'OSI', 'SCOPE SHIELD',
        'SPEED MEASUREMENT SYSTEMS', 'SURVEILLANCE SYSTEMS', 'TETHERED AEROSTAT RADAR',
        'WEAPONS STORAGE PROTECTION', 'ALARM SYSTEMS', 'DISASTER PLANNING', 'EOD',
        'ANTI-TERRORISM', 'CIVIL DISTURBANCES', 'COUNTER DRUG', 'PROJECT COTHEN',
        'SPECIAL SECURITY OPERATIONS',

        // Range Operations
        'RANGE OPERATIONS', 'RANGE CONTROL', 'RDTE SUPPORT', 'TEST AND MEASUREMENT',
        'TEST RANGE TIMING', 'TEST RANGE', 'RDMS', 'OCCS SUPPORT',

        // Sustaining Operations
        'SUSTAINING OPERATIONS', 'FLEET SUPPORT', 'PUBLIC WORKS', 'NATURAL RESOURCES',
        'RESOURCES CONSERVATION', 'SAFETY', 'LOCKS AND DAMS', 'HYDROLOGIC',
        'METEOROLOGICAL', 'SEISMIC', 'NAVAIDS', 'NAVIGATION RADAR', 'CIVIL ENGINEERING',
        'CIVIL WORKS', 'CONSTRUCTION', 'INDUSTRIAL CONTROLS', 'PRIME BEEF', 'RED HORSE',
        'SEABEES', 'UTILITIES', 'WILDLIFE PRESERVATION', 'NAVAIDS CONTROLS',
        'REMOTE BARRIER CONTROL SYSTEMS', 'RUNWAY LIGHTING CONTROL',

        // Space Operations
        'SPACE OPERATIONS', 'SATELLITE COMMUNICATIONS', 'GPS', 'SHUTTLE', 'NASA',
        'SGLS', 'ARTS', 'TELEMETRY', 'TELECOMMAND', 'UAV',

        // Emergency Services
        'EMERGENCY SERVICES', 'WARNING SYSTEM', 'CONSEQUENCE MANAGEMENT', 'CBR',
        'CIVIL SUPPORT TEAM', 'ENVIRONMENTAL CLEANUP', 'FEMA', 'HAZARDOUS MATERIAL RELEASE',
        'TECHNICAL ESCORT UNIT', 'MUTUAL AID',

        // Weather/Environmental
        'WEATHER', 'WEATHER RADAR', 'WIND PROFILER', 'AMSS', 'ASOS', 'AWOS', 'GOES',
        'IMETS', 'NEXRAD', 'SAWDS',

        // Command and Control
        'COMMAND AND CONTROL', 'BASE OPERATIONS', 'COMMAND NET', 'MOMS', 'TRUNKING',
        'HICOM', 'A2C2S', 'NAOC', 'MYSTIC STAR', 'WHCA',

        // Data Links
        'DATA LINK', 'JTIDS/MIDS', 'TADIL-A', 'TADIL-C', 'A-EPLRS', 'AFATDS',
        'TACCS', 'NTDR', 'MITT/DTES', 'SCAMP',

        // Special Systems
        'AEGIS', 'PATRIOT', 'MLRS', 'SENTINEL', 'PAVE PAWS', 'OTHR/ROTHR',
        'THUNDERBIRDS', 'STRIKER II', 'AQF', 'TACJAM', 'NORAD',

        // Global Operations
        'GLOBAL', 'WORLDWIDE', 'CONUS', 'NATO', 'OTHER OPERATIONS', 'SPECIAL PROJECTS',
        'HAARP', 'SURVEY', 'DTSS', 'ETRAC'
    ],
    // Equipment Manufacturer Codes (40+ codes from MCEB Pub 7 Annex D)
    equipmentCodes: {
        'AAI': 'AAI Corp.',
        'ABB': 'ABB Power T&D Co.',
        'ACS': 'ACS Defense, Inc.',
        'ADC': 'ADC Telecommunications',
        'AEL': 'American Electronic Labs',
        'AIL': 'AIL Systems',
        'AMP': 'AMP Inc.',
        'ANT': 'Antenna Technology Corp.',
        'ARC': 'ARC Electronics',
        'ATI': 'ATI Inc.',
        'BAE': 'BAE Systems',
        'BOE': 'Boeing Co.',
        'CAM': 'Cameron Corp.',
        'CBN': 'Caribbean Communications',
        'COL': 'Collins Radio Co.',
        'EFJ': 'EF Johnson Co.',
        'GEC': 'GEC Marconi',
        'GEN': 'General Dynamics',
        'HAR': 'Harris Corp.',
        'HP': 'Hewlett Packard',
        'IBM': 'IBM Corp.',
        'ITT': 'ITT Corp.',
        'LOC': 'Lockheed Martin',
        'MOT': 'Motorola',
        'NEC': 'NEC Corp.',
        'RAY': 'Raytheon',
        'ROC': 'Rockwell International',
        'TBL': 'Trimble Navigation',
        'TBN': 'Tayburn',
        'TCC': 'Telcom Communications',
        'TCD': 'Techdyn Systems Corp.',
        'TCE': 'Telecommunications Corp.',
        'TCH': 'Techcomm',
        'TCI': 'Tel Com Industries',
        'TCL': 'Trio Communications, Ltd.',
        'TCM': 'TCOM Industries, Inc.',
        'TCN': 'Technos International Corp.',
        'TEK': 'Tektronix',
        'TRW': 'TRW Inc.',
        'WES': 'Westinghouse Electric'
    },

    // Geographic Codes (200+ codes from MCEB Pub 7 Annex C)
    loadOfficialGeographicCodes: {
        'A': {
            description: 'Northeast US',
            locations: ['ALABAMA', 'CHESAPEAKE BAY', 'CONNECTICUT', 'DELAWARE', 'DISTRICT OF COLUMBIA',
                'FIRST NAV DISTRICT', 'LAKE ONTARIO', 'MAINE', 'MARYLAND', 'MASSACHUSETTS',
                'NAV DIST WASH DC', 'NEW HAMPSHIRE', 'NEW JERSEY', 'NEW YORK', 'PENNSYLVANIA',
                'RHODE ISLAND', 'THIRD NAV DISTRICT', 'VERMONT', 'VIRGINIA', 'WEST VIRGINIA']
        },
        'B': {
            description: 'Great Lakes Region',
            locations: ['GREAT LAKES', 'ILLINOIS', 'INDIANA', 'IOWA', 'KENTUCKY', 'LAKE ERIE',
                'LAKE SUPERIOR', 'LAKE HURON', 'LAKE MICHIGAN', 'MICHIGAN', 'MINNESOTA',
                'MISSOURI', 'OHIO', 'WISCONSIN']
        },
        'C': {
            description: 'Southeast US',
            locations: ['ALABAMA', 'FLORIDA', 'GEORGIA', 'MISSISSIPPI', 'NORTH CAROLINA',
                'SIXTH NAV DISTRICT', 'SOUTH CAROLINA', 'TENNESSEE']
        },
        'D': {
            description: 'Rocky Mountain/Plains',
            locations: ['COLORADO', 'IDAHO', 'KANSAS', 'MONTANA', 'NEBRASKA', 'NORTH DAKOTA',
                'RCKY MTN RGN. CAP 7', 'SOUTH DAKOTA', 'UTAH', 'WYOMING']
        },
        'E': {
            description: 'South Central US',
            locations: ['ARIZONA', 'ARKANSAS', 'EIGHTH NAV DIST', 'LOUISIANA', 'NEW MEXICO',
                'OKLAHOMA', 'SW REGION CAP 6', 'TEXAS']
        },
        'F': {
            description: 'Pacific US',
            locations: ['CALIFORNIA', 'NEVADA', 'OREGON', 'PAC REGION CAP 8', 'WASHINGTON']
        },
        'G': {
            description: 'Alaska (mainland)',
            locations: ['ALASKA', 'PACIFIC OCEAN NE']
        },
        'H': {
            description: 'Pacific Ocean/Hawaii/Alaska Aleutians',
            locations: ['ALASKA ALEUTIAN IS', 'BERING SEA', 'FOURTEENTH NAV DIS', 'HAWAII',
                'JOHNSTON ISLAND', 'MIDWAY ISLAND', 'PACIFIC OCEAN NW']
        },
        'J': {
            description: 'Canada/Greenland/Iceland',
            locations: ['ATLANTIC OCEAN NW', 'AZORES', 'CANADA', 'GREENLAND', 'ICELAND', 'JAN MAYEN']
        },
        'K': {
            description: 'Caribbean/Central America',
            locations: ['BAHAMAS', 'BERMUDA', 'CARIBBEAN', 'CUBA', 'DOMINICAN REPUBLIC', 'GULF OF MEXICO',
                'HAITI REPUBLIC', 'JAMAICA', 'PUERTO RICO', 'VIRGIN ISLANDS']
        },
        'L': {
            description: 'South America/Antarctica',
            locations: ['ANTARTICA', 'ARGENTINE REPUBLIC', 'BOLIVIA', 'BRAZIL', 'CHILE (EX EASTER I)',
                'COLUMBIA REPUBLIC', 'MEXICO', 'SOUTH AMERICA', 'VENEZUELA REPUBLIC']
        },
        'M': {
            description: 'Northern Europe/Scandinavia',
            locations: ['BALTIC SEA', 'FINLAND', 'NORWAY', 'NORWEGIAN SEA', 'SPITSBERGEN', 'SWEDEN']
        },
        'N': {
            description: 'Western/Central Europe',
            locations: ['AUSTRIA', 'BELGIUM', 'DENMARK', 'ENGLAND CHANNEL', 'EUROPE', 'FRANCE',
                'GERMANY', 'ITALY', 'NETHERLANDS KINGDM', 'SPAIN', 'SWITZERLAND CONFED', 'UK GREAT BRITAIN']
        },
        'O': {
            description: 'Eastern Europe',
            locations: ['ALBANIA REPUBLIC', 'BULGARIA PEO REPUB', 'CZECHOSLOVAKIA', 'HUNGARIAN REPUBLIC',
                'POLAND PEO REPUBLI', 'ROUMANIA SOCLT REP']
        },
        'P': {
            description: 'Africa/Middle East',
            locations: ['AFRICA', 'ALGERIA', 'EGYPT ARAB REPUBLI', 'ISRAEL (STATE OF)', 'LEBANON',
                'LIBYA ARAB REPUBL', 'MOROCCO (KINGDOM OF)', 'NIGERIA (REPUBLIC OF)', 'SO AFRICA REPUBLIC',
                'SYRIAN ARAB REP.']
        },

        IRACNotes: {
            'US1': 'Coordinate with NTIA',
            'US2': 'Coordinate with FCC',
            'US3': 'Coordinate with affected agencies',
            'US7': 'Coordinate use of this frequency',
            'US8': 'Coordination required for power above threshold',
            'US15': 'Coordinate before use in these areas',
            'US25': 'Coordinate frequency assignment',
            'US27': 'Use requires coordination',
            'US30': 'Coordinate interference cases',
            'US42': 'Coordinate for emergency use only',
            'US60': 'Federal use requires coordination',
            'US74': 'Coordinate all applications',
            'US84': 'Use limited to coordination',
            'C045': 'Subject to coordination with FAA prior to use.',
            'C065': 'Subject to coordination, prior to use, with the Department of the Interior, Bureau of Land Management, National Interagency Fire Center, Boise, Idaho.',
            'C067': 'Subject to coordination with the Area Frequency Coordinator located at Nellis AFB, Nevada, prior to use in the states of Nevada, Utah west of 111°W and Idaho south of 44°N.'
        },

        timeCodes: {
            '1': {
                description: 'Regular Service',
                usage: 'Operates continuously, daily, on a regular basis',
                subCodes: {
                    '1H24': '24 hours per day',
                    '1HX': 'Hours of operation vary',
                    '1HN': 'Nighttime hours only',
                    '1HJ': 'Daylight hours only',
                    '1HT': 'Hours of twilight only'
                }
            },
            '2': {
                description: 'Workweek Service',
                usage: 'Operates continuously during normal working hours and days',
                subCodes: {
                    '2H24': '24 hours per day, workweek only',
                    '2HX': 'Variable hours, workweek only',
                    '2HN': 'Nighttime hours, workweek only',
                    '2HJ': 'Daylight hours, workweek only',
                    '2HT': 'Twilight hours, workweek only'
                }
            },
            '3': {
                description: 'Occasional Service',
                usage: 'Operates on an irregular, intermittent, or as-needed basis',
                subCodes: {
                    '3H24': 'Any time during 24-hour period',
                    '3HX': 'Variable hours, occasional use',
                    '3HN': 'Nighttime hours, occasional use',
                    '3HJ': 'Daylight hours, occasional use',
                    '3HT': 'Twilight hours, occasional use'
                }
            },
            '4': {
                description: 'Occasional Workweek Service',
                usage: 'Operates occasionally during normal working hours and days',
                subCodes: {
                    '4H24': 'Any time during workweek',
                    '4HX': 'Variable hours, occasional workweek',
                    '4HN': 'Nighttime hours, occasional workweek',
                    '4HJ': 'Daylight hours, occasional workweek',
                    '4HT': 'Twilight hours, occasional workweek'
                }
            }
        }
    },
            PowerTypes: {
                'C': {
                    description: 'Carrier Power',
                    usage: 'Use this for "N0N" and for "A3E" sound broadcasting service (Station Class "BC")'
                },
                'M': {
                    description: 'Mean Power',
                    usage: 'For all air to air (A/A) & air/ground/air (A/G/A). Use this for most AM emissions using unkeyed full carrier and all frequency modulated emissions. Typical emissions include A2A, A2B, A3C, A3E, A3F, A7B, AXX, F1B, F1C, F2B, F3E, F3F, F7B, FXX, H2A, H3E, and H7B'
                },
                'P': {
                    description: 'Peak Envelope Power',
                    usage: 'Use this for all pulsed equipment, C3F Television, and the following classes: A1A, A1B, A7B, B7B, B8C, B8E, BXX, C3F, G3E, J2B, J3E, J7B, JXX, K1B, K2B, K3E, K3F, L2B, M2B, M3E, P0N, PXX, R2B and R3C'
                }
            }
        };

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SFAF_REFERENCE_DATA;
}
if (typeof window !== 'undefined') {
    window.SFAF_REFERENCE_DATA = SFAF_REFERENCE_DATA;
}